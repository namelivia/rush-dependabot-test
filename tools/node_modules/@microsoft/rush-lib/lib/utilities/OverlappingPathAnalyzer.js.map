{"version":3,"file":"OverlappingPathAnalyzer.js","sourceRoot":"","sources":["../../src/utilities/OverlappingPathAnalyzer.ts"],"names":[],"mappings":";;;AAMA;;;GAGG;AACH,MAAa,uBAAuB;IAApC;QACmB,UAAK,GAA0B;YAC9C,iBAAiB,EAAE,IAAI,GAAG,EAAU;YACpC,KAAK,EAAE,EAAE;SACV,CAAC;IA4CJ,CAAC;IA1CQ,mCAAmC,CAAC,IAAY,EAAE,KAAa;QACpE,MAAM,SAAS,GAAa,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC5C,IAAI,WAAW,GAA0B,IAAI,CAAC,KAAK,CAAC;QACpD,IAAI,gBAAgB,GAAY,KAAK,CAAC;QACtC,IAAI,mCAAmC,GAAY,KAAK,CAAC;QACzD,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE;YAChC,IAAI,QAAQ,KAAK,EAAE,EAAE;gBACnB,SAAS;aACV;YAED,IAAI,WAAW,CAAC,KAAK,EAAE;gBACrB,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;aAC5B;YAED,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE;gBAChC,gBAAgB,GAAG,IAAI,CAAC;gBACxB,WAAW,GAAG,WAAW,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG;oBAC1C,iBAAiB,EAAE,IAAI,GAAG,EAAU;oBACpC,KAAK,EAAE,EAAE;iBACV,CAAC;aACH;iBAAM;gBACL,gBAAgB,GAAG,KAAK,CAAC;gBACzB,WAAW,GAAG,WAAW,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;aAC3C;YAED,mCAAmC,GAAG,WAAW,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAC/E,IAAI,CAAC,mCAAmC,EAAE;gBACxC,WAAW,CAAC,iBAAiB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;aAC1C;SACF;QAED,IAAI,gBAAgB,EAAE;YACpB,WAAW,CAAC,KAAK,GAAG,KAAK,CAAC;YAC1B,OAAO,SAAS,CAAC;SAClB;aAAM,IAAI,mCAAmC,EAAE;YAC9C,OAAO,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,iBAAiB,CAAC,CAAC;SAClD;aAAM;YACL,MAAM,uBAAuB,GAAgB,IAAI,GAAG,CAAS,WAAW,CAAC,iBAAiB,CAAC,CAAC;YAC5F,uBAAuB,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACtC,OAAO,KAAK,CAAC,IAAI,CAAC,uBAAuB,CAAC,CAAC;SAC5C;IACH,CAAC;CACF;AAhDD,0DAgDC","sourcesContent":["interface IPathTreeNode<TLabel> {\n  encounteredLabels: Set<TLabel>;\n  label?: TLabel;\n  paths: Record<string, IPathTreeNode<TLabel>>;\n}\n\n/**\n * This is a tool for determining if a set of paths overlap. For example 'lib' and 'lib/x' overlap,\n * 'lib/x' and 'lib/y' do not.\n */\nexport class OverlappingPathAnalyzer<TLabel> {\n  private readonly _root: IPathTreeNode<TLabel> = {\n    encounteredLabels: new Set<TLabel>(),\n    paths: {}\n  };\n\n  public addPathAndGetFirstEncounteredLabels(path: string, label: TLabel): TLabel[] | undefined {\n    const pathParts: string[] = path.split('/');\n    let currentNode: IPathTreeNode<TLabel> = this._root;\n    let currentNodeIsNew: boolean = false;\n    let labelWasAlreadyPresentInCurrentNode: boolean = false;\n    for (const pathPart of pathParts) {\n      if (pathPart === '') {\n        continue;\n      }\n\n      if (currentNode.label) {\n        return [currentNode.label];\n      }\n\n      if (!currentNode.paths[pathPart]) {\n        currentNodeIsNew = true;\n        currentNode = currentNode.paths[pathPart] = {\n          encounteredLabels: new Set<TLabel>(),\n          paths: {}\n        };\n      } else {\n        currentNodeIsNew = false;\n        currentNode = currentNode.paths[pathPart];\n      }\n\n      labelWasAlreadyPresentInCurrentNode = currentNode.encounteredLabels.has(label);\n      if (!labelWasAlreadyPresentInCurrentNode) {\n        currentNode.encounteredLabels.add(label);\n      }\n    }\n\n    if (currentNodeIsNew) {\n      currentNode.label = label;\n      return undefined;\n    } else if (labelWasAlreadyPresentInCurrentNode) {\n      return Array.from(currentNode.encounteredLabels);\n    } else {\n      const clonedEncounteredLabels: Set<TLabel> = new Set<TLabel>(currentNode.encounteredLabels);\n      clonedEncounteredLabels.delete(label);\n      return Array.from(clonedEncounteredLabels);\n    }\n  }\n}\n"]}