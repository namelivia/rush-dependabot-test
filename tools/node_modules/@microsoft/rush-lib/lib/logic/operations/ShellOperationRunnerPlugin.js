"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShellOperationRunnerPlugin = void 0;
const RushConstants_1 = require("../RushConstants");
const NullOperationRunner_1 = require("./NullOperationRunner");
const ShellOperationRunner_1 = require("./ShellOperationRunner");
const OperationStatus_1 = require("./OperationStatus");
const PLUGIN_NAME = 'ShellOperationRunnerPlugin';
/**
 * Core phased command plugin that provides the functionality for executing an operation via shell command.
 */
class ShellOperationRunnerPlugin {
    apply(hooks) {
        hooks.createOperations.tap(PLUGIN_NAME, createShellOperations);
    }
}
exports.ShellOperationRunnerPlugin = ShellOperationRunnerPlugin;
function createShellOperations(operations, context) {
    const { buildCacheConfiguration, isIncrementalBuildAllowed, phaseSelection: selectedPhases, projectChangeAnalyzer, rushConfiguration } = context;
    const customParametersByPhase = new Map();
    function getCustomParameterValuesForPhase(phase) {
        let customParameterValues = customParametersByPhase.get(phase);
        if (!customParameterValues) {
            customParameterValues = [];
            for (const tsCommandLineParameter of phase.associatedParameters) {
                tsCommandLineParameter.appendToArgList(customParameterValues);
            }
            customParametersByPhase.set(phase, customParameterValues);
        }
        return customParameterValues;
    }
    for (const operation of operations) {
        const { associatedPhase: phase, associatedProject: project } = operation;
        if (phase && project && !operation.runner) {
            // This is a shell command. In the future, may consider having a property on the initial operation
            // to specify a runner type requested in rush-project.json
            const customParameterValues = getCustomParameterValuesForPhase(phase);
            const commandToRun = getScriptToRun(project, phase.name, customParameterValues);
            if (commandToRun === undefined && !phase.ignoreMissingScript) {
                throw new Error(`The project '${project.packageName}' does not define a '${phase.name}' command in the 'scripts' section of its package.json`);
            }
            const displayName = getDisplayName(phase, project);
            if (commandToRun) {
                operation.runner = new ShellOperationRunner_1.ShellOperationRunner({
                    buildCacheConfiguration,
                    commandToRun: commandToRun || '',
                    displayName,
                    isIncrementalBuildAllowed,
                    phase,
                    projectChangeAnalyzer,
                    rushConfiguration,
                    rushProject: project,
                    selectedPhases
                });
            }
            else {
                // Empty build script indicates a no-op, so use a no-op runner
                operation.runner = new NullOperationRunner_1.NullOperationRunner({
                    name: displayName,
                    result: OperationStatus_1.OperationStatus.NoOp,
                    silent: false
                });
            }
        }
    }
    return operations;
}
function getScriptToRun(rushProject, commandToRun, customParameterValues) {
    const { scripts } = rushProject.packageJson;
    const rawCommand = scripts === null || scripts === void 0 ? void 0 : scripts[commandToRun];
    if (rawCommand === undefined || rawCommand === null) {
        return undefined;
    }
    if (!rawCommand) {
        return '';
    }
    else {
        const shellCommand = `${rawCommand} ${customParameterValues.join(' ')}`;
        return process.platform === 'win32' ? (0, ShellOperationRunner_1.convertSlashesForWindows)(shellCommand) : shellCommand;
    }
}
function getDisplayName(phase, project) {
    if (phase.isSynthetic) {
        // Because this is a synthetic phase, just use the project name because there aren't any other phases
        return project.packageName;
    }
    else {
        const phaseNameWithoutPrefix = phase.name.slice(RushConstants_1.RushConstants.phaseNamePrefix.length);
        return `${project.packageName} (${phaseNameWithoutPrefix})`;
    }
}
//# sourceMappingURL=ShellOperationRunnerPlugin.js.map