/**
 * A library for writing scripts that interact with the {@link https://rushjs.io/ | Rush} tool.
 * @packageDocumentation
 */

/// <reference types="node" />

import { AsyncParallelHook } from 'tapable';
import { AsyncSeriesHook } from 'tapable';
import { AsyncSeriesWaterfallHook } from 'tapable';
import type { CollatedWriter } from '@rushstack/stream-collator';
import type { CommandLineParameter } from '@rushstack/ts-command-line';
import { HookMap } from 'tapable';
import { IPackageJson } from '@rushstack/node-core-library';
import { ITerminal } from '@rushstack/node-core-library';
import { ITerminalProvider } from '@rushstack/node-core-library';
import { JsonObject } from '@rushstack/node-core-library';
import { PackageNameParser } from '@rushstack/node-core-library';
import type { StdioSummarizer } from '@rushstack/terminal';
import { SyncHook } from 'tapable';
import { Terminal } from '@rushstack/node-core-library';

/**
 * This represents the JSON file specified via the "approvedPackagesFile" option in rush.json.
 * @public
 */
export declare class ApprovedPackagesConfiguration {
    private static _jsonSchema;
    items: ApprovedPackagesItem[];
    private _itemsByName;
    private _loadedJson;
    private _jsonFilename;
    constructor(jsonFilename: string);
    /**
     * Clears all the settings, returning to an empty state.
     */
    clear(): void;
    getItemByName(packageName: string): ApprovedPackagesItem | undefined;
    addOrUpdatePackage(packageName: string, reviewCategory: string): boolean;
    /**
     * If the file exists, calls loadFromFile().
     */
    tryLoadFromFile(approvedPackagesPolicyEnabled: boolean): boolean;
    /**
     * Loads the configuration data from the filename that was passed to the constructor.
     */
    loadFromFile(): void;
    /**
     * Loads the configuration data to the filename that was passed to the constructor.
     */
    saveToFile(): void;
    /**
     * Helper function only used by the constructor when loading the file.
     */
    private _addItemJson;
    /**
     * Helper function that adds an already created ApprovedPackagesItem to the
     * list and set.
     */
    private _addItem;
}

/**
 * An item returned by ApprovedPackagesConfiguration
 * @public
 */
export declare class ApprovedPackagesItem {
    /**
     * The NPM package name
     */
    packageName: string;
    /**
     * The project categories that are allowed to use this package.
     */
    allowedCategories: Set<string>;
    /**
     * @internal
     */
    constructor(packageName: string);
}

/**
 * This is a helper object for RushConfiguration.
 * It exposes the "approvedPackagesPolicy" feature from rush.json.
 * @public
 */
export declare class ApprovedPackagesPolicy {
    private _enabled;
    private _ignoredNpmScopes;
    private _reviewCategories;
    private _browserApprovedPackages;
    private _nonbrowserApprovedPackages;
    /** @internal */
    constructor(rushConfiguration: RushConfiguration, rushConfigurationJson: IRushConfigurationJson);
    /**
     * Whether the feature is enabled.  The feature is enabled if the "approvedPackagesPolicy"
     * field is assigned in rush.json.
     */
    get enabled(): boolean;
    /**
     * A list of NPM package scopes that will be excluded from review (e.g. `@types`)
     */
    get ignoredNpmScopes(): Set<string>;
    /**
     * A list of category names that are valid for usage as the RushConfigurationProject.reviewCategory field.
     * This array will never be undefined.
     */
    get reviewCategories(): Set<string>;
    /**
     * Packages approved for usage in a web browser.  This is the stricter of the two types, so by default
     * all new packages are added to this file.
     *
     * @remarks
     *
     * This is part of an optional approval workflow, whose purpose is to review any new dependencies
     * that are introduced (e.g. maybe a legal review is required, or maybe we are trying to minimize bloat).
     * When Rush discovers a new dependency has been added to package.json, it will update the file.
     * The intent is that the file will be stored in Git and tracked by a branch policy that notifies
     * reviewers when a PR attempts to modify the file.
     *
     * Example filename: `C:\MyRepo\common\config\rush\browser-approved-packages.json`
     */
    get browserApprovedPackages(): ApprovedPackagesConfiguration;
    /**
     * Packages approved for usage everywhere *except* in a web browser.
     *
     * @remarks
     *
     * This is part of an optional approval workflow, whose purpose is to review any new dependencies
     * that are introduced (e.g. maybe a legal review is required, or maybe we are trying to minimize bloat).
     * The intent is that the file will be stored in Git and tracked by a branch policy that notifies
     * reviewers when a PR attempts to modify the file.
     *
     * Example filename: `C:\MyRepo\common\config\rush\browser-approved-packages.json`
     */
    get nonbrowserApprovedPackages(): ApprovedPackagesConfiguration;
}

/**
 * Use this class to load and save the "common/config/rush/build-cache.json" config file.
 * This file provides configuration options for cached project build output.
 * @beta
 */
export declare class BuildCacheConfiguration {
    private static _jsonSchema;
    /**
     * Indicates whether the build cache feature is enabled.
     * Typically it is enabled in the build-cache.json config file.
     */
    readonly buildCacheEnabled: boolean;
    /**
     * Indicates whether or not writing to the cache is enabled.
     */
    cacheWriteEnabled: boolean;
    /**
     * Method to calculate the cache entry id for a project, phase, and project state.
     */
    readonly getCacheEntryId: GetCacheEntryIdFunction;
    /**
     * The provider for interacting with the local build cache.
     */
    readonly localCacheProvider: FileSystemBuildCacheProvider;
    /**
     * The provider for interacting with the cloud build cache, if configured.
     */
    readonly cloudCacheProvider: ICloudBuildCacheProvider | undefined;
    private constructor();
    /**
     * Attempts to load the build-cache.json data from the standard file path `common/config/rush/build-cache.json`.
     * If the file has not been created yet, then undefined is returned.
     */
    static tryLoadAsync(terminal: ITerminal, rushConfiguration: RushConfiguration, rushSession: RushSession): Promise<BuildCacheConfiguration | undefined>;
    /**
     * Loads the build-cache.json data from the standard file path `common/config/rush/build-cache.json`.
     * If the file has not been created yet, or if the feature is not enabled, then an error is reported.
     */
    static loadAndRequireEnabledAsync(terminal: ITerminal, rushConfiguration: RushConfiguration, rushSession: RushSession): Promise<BuildCacheConfiguration>;
    /**
     * Gets the absolute path to the build-cache.json file in the specified rush workspace.
     */
    static getBuildCacheConfigFilePath(rushConfiguration: RushConfiguration): string;
    private static _loadAsync;
}

/**
 * Type of version bumps
 * @public
 */
export declare enum BumpType {
    'none' = 0,
    'prerelease' = 1,
    'patch' = 2,
    'preminor' = 3,
    'minor' = 4,
    'major' = 5
}

/**
 * A class that helps with programmatically interacting with Rush's change files.
 * @public
 */
export declare class ChangeManager {
    /**
     * Creates a change file that has a 'none' type.
     * @param rushConfiguration - The rush configuration we are working with
     * @param projectName - The name of the project for which to create a change file
     * @param emailAddress - The email address which should be associated with this change
     * @returns the path to the file that was created, or undefined if no file was written
     */
    static createEmptyChangeFiles(rushConfiguration: RushConfiguration, projectName: string, emailAddress: string): string | undefined;
}

/**
 * @beta
 */
export declare type CloudBuildCacheProviderFactory = (buildCacheJson: IBuildCacheJson) => ICloudBuildCacheProvider;

/**
 * Use this class to load and save the "common/config/rush/common-versions.json" config file.
 * This config file stores dependency version information that affects all projects in the repo.
 * @public
 */
export declare class CommonVersionsConfiguration {
    private static _jsonSchema;
    private _filePath;
    private _preferredVersions;
    private _implicitlyPreferredVersions;
    private _allowedAlternativeVersions;
    private _modified;
    private constructor();
    /**
     * Loads the common-versions.json data from the specified file path.
     * If the file has not been created yet, then an empty object is returned.
     */
    static loadFromFile(jsonFilename: string): CommonVersionsConfiguration;
    private static _deserializeTable;
    private static _serializeTable;
    /**
     * Get the absolute file path of the common-versions.json file.
     */
    get filePath(): string;
    /**
     * Get a sha1 hash of the preferred versions.
     */
    getPreferredVersionsHash(): string;
    /**
     * Writes the "common-versions.json" file to disk, using the filename that was passed to loadFromFile().
     */
    save(): boolean;
    /**
     * A table that specifies a "preferred version" for a given NPM package.  This feature is typically used
     * to hold back an indirect dependency to a specific older version, or to reduce duplication of indirect dependencies.
     *
     * @remarks
     * The "preferredVersions" value can be any SemVer range specifier (e.g. `~1.2.3`).  Rush injects these values into
     * the "dependencies" field of the top-level common/temp/package.json, which influences how the package manager
     * will calculate versions.  The specific effect depends on your package manager.  Generally it will have no
     * effect on an incompatible or already constrained SemVer range.  If you are using PNPM, similar effects can be
     * achieved using the pnpmfile.js hook.  See the Rush documentation for more details.
     *
     * After modifying this field, it's recommended to run `rush update --full` so that the package manager
     * will recalculate all version selections.
     */
    get preferredVersions(): Map<string, string>;
    /**
     * When set to true, for all projects in the repo, all dependencies will be automatically added as preferredVersions,
     * except in cases where different projects specify different version ranges for a given dependency.  For older
     * package managers, this tended to reduce duplication of indirect dependencies.  However, it can sometimes cause
     * trouble for indirect dependencies with incompatible peerDependencies ranges.
     *
     * If the value is `undefined`, then the default value is `true`.
     */
    get implicitlyPreferredVersions(): boolean | undefined;
    /**
     * A table that stores, for a given dependency, a list of SemVer ranges that will be accepted
     * by "rush check" in addition to the normal version range.
     *
     * @remarks
     * The "rush check" command can be used to enforce that every project in the repo
     * must specify the same SemVer range for a given dependency.  However, sometimes
     * exceptions are needed.  The allowedAlternativeVersions table allows you to list
     * other SemVer ranges that will be accepted by "rush check" for a given dependency.
     * Note that the normal version range (as inferred by looking at all projects in the repo)
     * should NOT be included in this list.
     */
    get allowedAlternativeVersions(): Map<string, ReadonlyArray<string>>;
    /**
     * Returns preferredVersions.
     */
    getAllPreferredVersions(): Map<string, string>;
    private _onSetPreferredVersions;
    private _onSetAllowedAlternativeVersions;
    private _serialize;
}

/**
 * @beta
 */
export declare class CredentialCache {
    private readonly _cacheFilePath;
    private readonly _cacheEntries;
    private _modified;
    private _disposed;
    private _supportsEditing;
    private readonly _lockfile;
    private constructor();
    static initializeAsync(options: ICredentialCacheOptions): Promise<CredentialCache>;
    static usingAsync(options: ICredentialCacheOptions, doActionAsync: (credentialCache: CredentialCache) => Promise<void> | void): Promise<void>;
    setCacheEntry(cacheId: string, credential: string, expires?: Date): void;
    tryGetCacheEntry(cacheId: string): ICredentialCacheEntry | undefined;
    deleteCacheEntry(cacheId: string): void;
    trimExpiredEntries(): void;
    saveIfModifiedAsync(): Promise<void>;
    dispose(): void;
    private _validate;
}

/**
 * @public
 */
export declare enum DependencyType {
    Regular = "dependencies",
    Dev = "devDependencies",
    Optional = "optionalDependencies",
    Peer = "peerDependencies",
    YarnResolutions = "resolutions"
}

/**
 * Provides Rush-specific environment variable data. All Rush environment variables must start with "RUSH_". This class
 * is designed to be used by RushConfiguration.
 * @beta
 *
 * @remarks
 * Initialize will throw if any unknown parameters are present.
 */
export declare class EnvironmentConfiguration {
    private static _hasBeenValidated;
    private static _rushTempFolderOverride;
    private static _absoluteSymlinks;
    private static _allowUnsupportedNodeVersion;
    private static _allowWarningsInSuccessfulBuild;
    private static _pnpmStorePathOverride;
    private static _rushGlobalFolderOverride;
    private static _buildCacheCredential;
    private static _buildCacheEnabled;
    private static _buildCacheWriteAllowed;
    private static _gitBinaryPath;
    private static _tarBinaryPath;
    /**
     * An override for the common/temp folder path.
     */
    static get rushTempFolderOverride(): string | undefined;
    /**
     * If "1", create symlinks with absolute paths instead of relative paths.
     * See {@link EnvironmentVariableNames.RUSH_ABSOLUTE_SYMLINKS}
     */
    static get absoluteSymlinks(): boolean;
    /**
     * If this environment variable is set to "1", the Node.js version check will print a warning
     * instead of causing a hard error if the environment's Node.js version doesn't match the
     * version specifier in `rush.json`'s "nodeSupportedVersionRange" property.
     *
     * See {@link EnvironmentVariableNames.RUSH_ALLOW_UNSUPPORTED_NODEJS}.
     */
    static get allowUnsupportedNodeVersion(): boolean;
    /**
     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`
     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,
     * or `0` to disallow them. (See the comments in the command-line.json file for more information).
     */
    static get allowWarningsInSuccessfulBuild(): boolean;
    /**
     * An override for the PNPM store path, if `pnpmStore` configuration is set to 'path'
     * See {@link EnvironmentVariableNames.RUSH_PNPM_STORE_PATH}
     */
    static get pnpmStorePathOverride(): string | undefined;
    /**
     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.
     * See {@link EnvironmentVariableNames.RUSH_GLOBAL_FOLDER}
     */
    static get rushGlobalFolderOverride(): string | undefined;
    /**
     * Provides a credential for reading from and writing to a remote build cache, if configured.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_CREDENTIAL}
     */
    static get buildCacheCredential(): string | undefined;
    /**
     * If set, enables or disables the cloud build cache feature.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_ENABLED}
     */
    static get buildCacheEnabled(): boolean | undefined;
    /**
     * If set, enables or disables writing to the cloud build cache.
     * See {@link EnvironmentVariableNames.RUSH_BUILD_CACHE_WRITE_ALLOWED}
     */
    static get buildCacheWriteAllowed(): boolean | undefined;
    /**
     * Allows the git binary path to be explicitly provided.
     * See {@link EnvironmentVariableNames.RUSH_GIT_BINARY_PATH}
     */
    static get gitBinaryPath(): string | undefined;
    /**
     * Allows the tar binary path to be explicitly provided.
     * See {@link EnvironmentVariableNames.RUSH_TAR_BINARY_PATH}
     */
    static get tarBinaryPath(): string | undefined;
    /**
     * The front-end RushVersionSelector relies on `RUSH_GLOBAL_FOLDER`, so its value must be read before
     * `EnvironmentConfiguration` is initialized (and actually before the correct version of `EnvironmentConfiguration`
     * is even installed). Thus we need to read this environment variable differently from all the others.
     * @internal
     */
    static _getRushGlobalFolderOverride(processEnv: IEnvironment): string | undefined;
    /**
     * Reads and validates environment variables. If any are invalid, this function will throw.
     */
    static validate(options?: IEnvironmentConfigurationInitializeOptions): void;
    /**
     * Resets EnvironmentConfiguration into an un-initialized state.
     */
    static reset(): void;
    private static _ensureValidated;
    static parseBooleanEnvironmentVariable(name: string, value: string | undefined): boolean | undefined;
    /**
     * Given a path to a folder (that may or may not exist), normalize the path, including casing,
     * to the first existing parent folder in the path.
     *
     * If no existing path can be found (for example, if the root is a volume that doesn't exist),
     * this function returns undefined.
     *
     * @example
     * If the following path exists on disk: `C:\Folder1\folder2\`
     * _normalizeFirstExistingFolderPath('c:\\folder1\\folder2\\temp\\subfolder')
     * returns 'C:\\Folder1\\folder2\\temp\\subfolder'
     */
    private static _normalizeDeepestParentFolderPath;
}

/**
 * Names of environment variables used by Rush.
 * @beta
 */
export declare enum EnvironmentVariableNames {
    /**
     * This variable overrides the temporary folder used by Rush.
     * The default value is "common/temp" under the repository root.
     *
     * @remarks This environment variable is not compatible with workspace installs. If attempting
     * to move the PNPM store path, see the `RUSH_PNPM_STORE_PATH` environment variable.
     */
    RUSH_TEMP_FOLDER = "RUSH_TEMP_FOLDER",
    /**
     * This variable overrides the version of Rush that will be installed by
     * the version selector.  The default value is determined by the "rushVersion"
     * field from rush.json.
     */
    RUSH_PREVIEW_VERSION = "RUSH_PREVIEW_VERSION",
    /**
     * If this variable is set to "1", Rush will not fail the build when running a version
     * of Node that does not match the criteria specified in the "nodeSupportedVersionRange"
     * field from rush.json.
     */
    RUSH_ALLOW_UNSUPPORTED_NODEJS = "RUSH_ALLOW_UNSUPPORTED_NODEJS",
    /**
     * Setting this environment variable overrides the value of `allowWarningsInSuccessfulBuild`
     * in the `command-line.json` configuration file. Specify `1` to allow warnings in a successful build,
     * or `0` to disallow them. (See the comments in the command-line.json file for more information).
     */
    RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD = "RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD",
    /**
     * This variable selects a specific installation variant for Rush to use when installing
     * and linking package dependencies.
     * For more information, see the command-line help for the `--variant` parameter
     * and this article:  https://rushjs.io/pages/advanced/installation_variants/
     */
    RUSH_VARIANT = "RUSH_VARIANT",
    /**
     * Specifies the maximum number of concurrent processes to launch during a build.
     * For more information, see the command-line help for the `--parallelism` parameter for "rush build".
     */
    RUSH_PARALLELISM = "RUSH_PARALLELISM",
    /**
     * If this variable is set to "1", Rush will create symlinks with absolute paths instead
     * of relative paths. This can be necessary when a repository is moved during a build or
     * if parts of a repository are moved into a sandbox.
     */
    RUSH_ABSOLUTE_SYMLINKS = "RUSH_ABSOLUTE_SYMLINKS",
    /**
     * When using PNPM as the package manager, this variable can be used to configure the path that
     * PNPM will use as the store directory.
     *
     * If a relative path is used, then the store path will be resolved relative to the process's
     * current working directory.  An absolute path is recommended.
     */
    RUSH_PNPM_STORE_PATH = "RUSH_PNPM_STORE_PATH",
    /**
     * This environment variable can be used to specify the `--target-folder` parameter
     * for the "rush deploy" command.
     */
    RUSH_DEPLOY_TARGET_FOLDER = "RUSH_DEPLOY_TARGET_FOLDER",
    /**
     * Overrides the location of the `~/.rush` global folder where Rush stores temporary files.
     *
     * @remarks
     *
     * Most of the temporary files created by Rush are stored separately for each monorepo working folder,
     * to avoid issues of concurrency and compatibility between tool versions.  However, a small set
     * of files (e.g. installations of the `@microsoft/rush-lib` engine and the package manager) are stored
     * in a global folder to speed up installations.  The default location is `~/.rush` on POSIX-like
     * operating systems or `C:\Users\YourName` on Windows.
     *
     * Use `RUSH_GLOBAL_FOLDER` to specify a different folder path.  This is useful for example if a Windows
     * group policy forbids executing scripts installed in a user's home directory.
     *
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    RUSH_GLOBAL_FOLDER = "RUSH_GLOBAL_FOLDER",
    /**
     * Provides a credential for a remote build cache, if configured. Setting this environment variable
     * overrides whatever credential has been saved in the local cloud cache credentials using
     * `rush update-cloud-credentials`.
     *
     * @remarks
     * This credential overrides any cached credentials.
     *
     * If Azure Blob Storage is used to store cache entries, this must be a SAS token serialized as query
     * parameters.
     *
     * For information on SAS tokens, see here: https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview
     */
    RUSH_BUILD_CACHE_CREDENTIAL = "RUSH_BUILD_CACHE_CREDENTIAL",
    /**
     * Setting this environment variable overrides the value of `buildCacheEnabled` in the `build-cache.json`
     * configuration file. Specify `1` to enable the build cache or `0` to disable it.
     *
     * If set to `0`, this is equivalent to passing the `--disable-build-cache` flag.
     */
    RUSH_BUILD_CACHE_ENABLED = "RUSH_BUILD_CACHE_ENABLED",
    /**
     * Setting this environment variable overrides the value of `isCacheWriteAllowed` in the `build-cache.json`
     * configuration file. Specify `1` to allow cache write and `0` to disable it.
     */
    RUSH_BUILD_CACHE_WRITE_ALLOWED = "RUSH_BUILD_CACHE_WRITE_ALLOWED",
    /**
     * Allows the git binary path to be explicitly specified.
     */
    RUSH_GIT_BINARY_PATH = "RUSH_GIT_BINARY_PATH",
    /**
     * Allows the tar binary path to be explicitly specified.
     */
    RUSH_TAR_BINARY_PATH = "RUSH_TAR_BINARY_PATH",
    /**
     * When Rush executes shell scripts, it sometimes changes the working directory to be a project folder or
     * the repository root folder.  The original working directory (where the Rush command was invoked) is assigned
     * to the the child process's `RUSH_INVOKED_FOLDER` environment variable, in case it is needed by the script.
     *
     * @remarks
     * The `RUSH_INVOKED_FOLDER` variable is the same idea as the `INIT_CWD` variable that package managers
     * assign when they execute lifecycle scripts.
     */
    RUSH_INVOKED_FOLDER = "RUSH_INVOKED_FOLDER"
}

/**
 * Events happen during Rush runs.
 * @beta
 */
export declare enum Event {
    /**
     * Pre Rush install event
     */
    preRushInstall = 1,
    /**
     * Post Rush install event
     */
    postRushInstall = 2,
    /**
     * Pre Rush build event
     */
    preRushBuild = 3,
    /**
     * Post Rush build event
     */
    postRushBuild = 4
}

/**
 * This class represents Rush event hooks configured for this repo.
 * Hooks are customized script actions that Rush executes when specific events occur.
 * The actions are expressed as a command-line that is executed using the operating system shell.
 * @beta
 */
export declare class EventHooks {
    private _hooks;
    /**
     * @internal
     */
    constructor(eventHooksJson: IEventHooksJson);
    /**
     * Return all the scripts associated with the specified event.
     * @param event - Rush event
     */
    get(event: Event): string[];
}

/**
 * Use this class to load the "common/config/rush/experiments.json" config file.
 * This file allows repo maintainers to enable and disable experimental Rush features.
 * @public
 */
export declare class ExperimentsConfiguration {
    private static _jsonSchema;
    private _experimentConfiguration;
    private _jsonFileName;
    /**
     * @internal
     */
    constructor(jsonFileName: string);
    /**
     * Get the experiments configuration.
     * @beta
     */
    get configuration(): Readonly<IExperimentsJson>;
}

/**
 * A build cache provider using the local file system.
 * Required by all cloud cache providers.
 * @beta
 */
export declare class FileSystemBuildCacheProvider {
    private readonly _cacheFolderPath;
    constructor(options: IFileSystemBuildCacheProviderOptions);
    /**
     * Returns the absolute disk path for the specified cache id.
     */
    getCacheEntryPath(cacheId: string): string;
    /**
     * Validates that the specified cache id exists on disk, and returns the path if it does.
     */
    tryGetCacheEntryPathByIdAsync(terminal: ITerminal, cacheId: string): Promise<string | undefined>;
    /**
     * Writes the specified buffer to the corresponding file system path for the cache id.
     */
    trySetCacheEntryBufferAsync(terminal: ITerminal, cacheId: string, entryBuffer: Buffer): Promise<string>;
}

/**
 * Calculates the cache entry id string for an operation.
 * @beta
 */
export declare type GetCacheEntryIdFunction = (options: IGenerateCacheEntryIdOptions) => string;

/**
 * Part of IRushConfigurationJson.
 */
declare interface IApprovedPackagesPolicyJson {
    reviewCategories?: string[];
    ignoredNpmScopes?: string[];
}

/**
 * Describes the file structure for the "common/config/rush/build-cache.json" config file.
 */
declare interface IBaseBuildCacheJson {
    buildCacheEnabled: boolean;
    cacheProvider: string;
    cacheEntryNamePattern?: string;
}

/**
 * @beta
 */
declare type IBuildCacheJson = ICloudBuildCacheJson | ILocalBuildCacheJson;

/**
 * @internal
 */
export declare interface _IBuiltInPluginConfiguration extends _IRushPluginConfigurationBase {
    pluginPackageFolder: string;
}

/**
 * @beta
 */
declare interface ICloudBuildCacheJson extends IBaseBuildCacheJson {
    readonly cacheProvider: string;
    [otherConfigKey: string]: JsonObject;
}

/**
 * @beta
 */
export declare interface ICloudBuildCacheProvider {
    readonly isCacheWriteAllowed: boolean;
    tryGetCacheEntryBufferByIdAsync(terminal: ITerminal, cacheId: string): Promise<Buffer | undefined>;
    trySetCacheEntryBufferAsync(terminal: ITerminal, cacheId: string, entryBuffer: Buffer): Promise<boolean>;
    updateCachedCredentialAsync(terminal: ITerminal, credential: string): Promise<void>;
    updateCachedCredentialInteractiveAsync(terminal: ITerminal): Promise<void>;
    deleteCachedCredentialsAsync(terminal: ITerminal): Promise<void>;
}

/**
 * A collection of environment variables
 * @public
 */
export declare interface IConfigurationEnvironment {
    /**
     * Environment variables
     */
    [environmentVariableName: string]: IConfigurationEnvironmentVariable;
}

/**
 * Represents the value of an environment variable, and if the value should be overridden if the variable is set
 * in the parent environment.
 * @public
 */
export declare interface IConfigurationEnvironmentVariable {
    /**
     * Value of the environment variable
     */
    value: string;
    /**
     * Set to true to override the environment variable even if it is set in the parent environment.
     * The default value is false.
     */
    override?: boolean;
}

/**
 * Context used for creating operations to be executed.
 * @alpha
 */
export declare interface ICreateOperationsContext {
    /**
     * The configuration for the build cache, if the feature is enabled.
     */
    readonly buildCacheConfiguration: BuildCacheConfiguration | undefined;
    /**
     * The set of custom parameters for the executing command.
     * Maps from the `longName` field in command-line.json to the parser configuration in ts-command-line.
     */
    readonly customParameters: ReadonlyMap<string, CommandLineParameter>;
    /**
     * If true, projects may read their output from cache or be skipped if already up to date.
     * If false, neither of the above may occur, e.g. "rush rebuild"
     */
    readonly isIncrementalBuildAllowed: boolean;
    /**
     * If true, this is the initial run of the command.
     * If false, this execution is in response to changes.
     */
    readonly isInitial: boolean;
    /**
     * If true, the command is running in watch mode.
     */
    readonly isWatch: boolean;
    /**
     * The set of phases selected for the current command execution.
     */
    readonly phaseSelection: ReadonlySet<IPhase>;
    /**
     * The current state of the repository
     */
    readonly projectChangeAnalyzer: ProjectChangeAnalyzer;
    /**
     * The set of Rush projects selected for the current command execution.
     */
    readonly projectSelection: ReadonlySet<RushConfigurationProject>;
    /**
     * The set of Rush projects that have not been built in the current process since they were last modified.
     * When `isInitial` is true, this will be an exact match of `projectSelection`.
     */
    readonly projectsInUnknownState: ReadonlySet<RushConfigurationProject>;
    /**
     * The Rush configuration
     */
    readonly rushConfiguration: RushConfiguration;
}

/**
 * @beta
 */
export declare interface ICredentialCacheEntry {
    expires?: Date;
    credential: string;
}

/**
 * @beta
 */
export declare interface ICredentialCacheOptions {
    supportEditing: boolean;
}

declare interface IEnvironment {
    [environmentVariableName: string]: string | undefined;
}

/**
 * @beta
 */
export declare interface IEnvironmentConfigurationInitializeOptions {
    doNotNormalizePaths?: boolean;
}

/**
 * Part of IRushConfigurationJson.
 * @beta
 */
declare interface IEventHooksJson {
    /**
     * The list of scripts to run after every Rush build command finishes
     */
    postRushBuild?: string[];
}

/**
 * The `IExecutionResult` interface represents the results of executing a set of {@link Operation}s.
 * @alpha
 */
export declare interface IExecutionResult {
    /**
     * The results for each scheduled operation.
     */
    readonly operationResults: ReadonlyMap<Operation, IOperationExecutionResult>;
    /**
     * The overall result.
     */
    readonly status: OperationStatus;
}

/**
 * This interface represents the raw experiments.json file which allows repo
 * maintainers to enable and disable experimental Rush features.
 * @beta
 */
export declare interface IExperimentsJson {
    /**
     * By default, 'rush install' passes --no-prefer-frozen-lockfile to 'pnpm install'.
     * Set this option to true to pass '--frozen-lockfile' instead.
     */
    usePnpmFrozenLockfileForRushInstall?: boolean;
    /**
     * By default, 'rush update' passes --no-prefer-frozen-lockfile to 'pnpm install'.
     * Set this option to true to pass '--prefer-frozen-lockfile' instead.
     */
    usePnpmPreferFrozenLockfileForRushUpdate?: boolean;
    /**
     * If using the 'preventManualShrinkwrapChanges' option, restricts the hash to only include the layout of external dependencies.
     * Used to allow links between workspace projects or the addition/removal of references to existing dependency versions to not
     * cause hash changes.
     */
    omitImportersFromPreventManualShrinkwrapChanges?: boolean;
    /**
     * If true, the chmod field in temporary project tar headers will not be normalized.
     * This normalization can help ensure consistent tarball integrity across platforms.
     */
    noChmodFieldInTarHeaderNormalization?: boolean;
    /**
     * If true, build caching will respect the allowWarningsInSuccessfulBuild flag and cache builds with warnings.
     * This will not replay warnings from the cached build.
     */
    buildCacheWithAllowWarningsInSuccessfulBuild?: boolean;
    /**
     * If true, the phased commands feature is enabled. To use this feature, create a "phased" command
     * in common/config/rush/command-line.json.
     */
    phasedCommands?: boolean;
}

/**
 * Options for creating a file system build cache provider.
 * @beta
 */
export declare interface IFileSystemBuildCacheProviderOptions {
    /**
     * The workspace Rush configuration
     */
    rushConfiguration: RushConfiguration;
    /**
     * The user Rush configuration
     */
    rushUserConfiguration: RushUserConfiguration;
}

/**
 * Options for generating the cache id for an operation.
 * @beta
 */
export declare interface IGenerateCacheEntryIdOptions {
    /**
     * The name of the project
     */
    projectName: string;
    /**
     * The name of the phase
     */
    phaseName: string;
    /**
     * A hash of the input files
     */
    projectStateHash: string;
}

/**
 * @beta
 */
export declare interface IGetChangedProjectsOptions {
    targetBranchName: string;
    terminal: ITerminal;
    shouldFetch?: boolean;
    /**
     * If set to `true`, consider a project's external dependency installation layout as defined in the
     * package manager lockfile when determining if it has changed.
     */
    includeExternalDependencies: boolean;
    /**
     * If set to `true` apply the `incrementalBuildIgnoredGlobs` property in a project's `rush-project.json`
     * and exclude matched files from change detection.
     */
    enableFiltering: boolean;
}

/**
 * Information about the currently executing global script command (as defined in command-line.json) provided to plugins.
 * @beta
 */
export declare interface IGlobalCommand extends IRushCommand {
}

declare interface IIndividualVersionJson extends IVersionPolicyJson {
    lockedMajor?: number;
}

/**
 * Options to pass to the rush "launch" functions.
 *
 * @public
 */
export declare interface ILaunchOptions {
    /**
     * True if the tool was invoked from within a project with a rush.json file, otherwise false. We
     * consider a project without a rush.json to be "unmanaged" and we'll print that to the command line when
     * the tool is executed. This is mainly used for debugging purposes.
     */
    isManaged: boolean;
    /**
     * If true, the wrapper process already printed a warning that the version of Node.js hasn't been tested
     * with this version of Rush, so we shouldn't print a similar error.
     */
    alreadyReportedNodeTooNewError?: boolean;
    /**
     * Used to specify Rush plugins that are dependencies of the "\@microsoft/rush" package.
     *
     * @internal
     */
    builtInPluginConfigurations?: _IBuiltInPluginConfiguration[];
    /**
     * Used to specify terminal how to write a message
     */
    terminalProvider?: ITerminalProvider;
}

/**
 * @public
 */
declare interface ILocalBuildCacheJson extends IBaseBuildCacheJson {
    readonly cacheProvider: 'local-only';
}

declare interface ILockStepVersionJson extends IVersionPolicyJson {
    version: string;
    nextBump?: string;
    mainProject?: string;
}

/**
 * @beta
 */
export declare interface ILogger {
    readonly terminal: Terminal;
    /**
     * Call this function to emit an error to the Rush runtime.
     */
    emitError(error: Error): void;
    /**
     * Call this function to emit a warning to the Rush runtime.
     */
    emitWarning(warning: Error): void;
}

/**
 * This policy indicates all related projects get version bump driven by their own changes.
 * @public
 */
export declare class IndividualVersionPolicy extends VersionPolicy {
    private _lockedMajor;
    /**
     * @internal
     */
    constructor(versionPolicyJson: IIndividualVersionJson);
    /**
     * The major version that has been locked
     */
    get lockedMajor(): number | undefined;
    /**
     * Serialized json for this policy
     *
     * @internal
     */
    get _json(): IIndividualVersionJson;
    /**
     * Returns an updated package json that satisfies the version policy.
     *
     * @param project - input package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    ensure(project: IPackageJson, force?: boolean): IPackageJson | undefined;
    /**
     * Bumps version.
     * Individual version policy lets change files drive version bump. This method currently does not do anything.
     *
     * @param bumpType - bump type
     * @param identifier - prerelease id
     */
    bump(bumpType?: BumpType, identifier?: string): void;
    /**
     * Validates the specified version and throws if the version does not satisfy the policy.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    validate(versionString: string, packageName: string): void;
}

/**
 * Part of IRushConfigurationJson.
 * @internal
 */
export declare interface _INpmOptionsJson extends IPackageManagerOptionsJsonBase {
}

/**
 * The `IOperationExecutionResult` interface represents the results of executing an {@link Operation}.
 * @alpha
 */
export declare interface IOperationExecutionResult {
    /**
     * The current execution status of an operation. Operations start in the 'ready' state,
     * but can be 'blocked' if an upstream operation failed. It is 'executing' when
     * the operation is executing. Once execution is complete, it is either 'success' or
     * 'failure'.
     */
    readonly status: OperationStatus;
    /**
     * The error which occurred while executing this operation, this is stored in case we need
     * it later (for example to re-print errors at end of execution).
     */
    readonly error: Error | undefined;
    /**
     * Object tracking execution timing.
     */
    readonly stopwatch: IStopwatchResult;
    /**
     * Object used to report a summary at the end of the Rush invocation.
     */
    readonly stdioSummarizer: StdioSummarizer;
}

/**
 * Options for constructing a new Operation.
 * @alpha
 */
export declare interface IOperationOptions {
    /**
     * The Rush phase associated with this Operation, if any
     */
    phase?: IPhase | undefined;
    /**
     * The Rush project associated with this Operation, if any
     */
    project?: RushConfigurationProject | undefined;
    /**
     * When the scheduler is ready to process this `Operation`, the `runner` implements the actual work of
     * running the operation.
     */
    runner?: IOperationRunner | undefined;
}

/**
 * The `Operation` class is a node in the dependency graph of work that needs to be scheduled by the
 * `OperationExecutionManager`. Each `Operation` has a `runner` member of type `IOperationRunner`, whose
 * implementation manages the actual process for running a single operation.
 *
 * @beta
 */
export declare interface IOperationRunner {
    /**
     * Name of the operation, for logging.
     */
    readonly name: string;
    /**
     * This flag determines if the operation is allowed to be skipped if up to date.
     */
    isSkipAllowed: boolean;
    /**
     * Indicates that this runner's duration has meaning.
     */
    reportTiming: boolean;
    /**
     * Indicates that this runner is architectural and should not be reported on.
     */
    silent: boolean;
    /**
     * If set to true, a warning result should not make Rush exit with a nonzero
     * exit code
     */
    warningsAreAllowed: boolean;
    /**
     * Indicates if the output of this operation may be written to the cache
     */
    isCacheWriteAllowed: boolean;
    /**
     * Method to be executed for the operation.
     */
    executeAsync(context: IOperationRunnerContext): Promise<OperationStatus>;
}

/**
 * Information passed to the executing `IOperationRunner`
 *
 * @beta
 */
export declare interface IOperationRunnerContext {
    /**
     * The writer into which this `IOperationRunner` should write its logs.
     */
    collatedWriter: CollatedWriter;
    /**
     * If Rush was invoked with `--debug`
     */
    debugMode: boolean;
    /**
     * Defaults to `true`. Will be `false` if Rush was invoked with `--verbose`.
     */
    quietMode: boolean;
    /**
     * Object used to report a summary at the end of the Rush invocation.
     */
    stdioSummarizer: StdioSummarizer;
}

/**
 * Options for the package manager.
 * @public
 */
export declare interface IPackageManagerOptionsJsonBase {
    /**
     * Environment variables for the package manager
     */
    environmentVariables?: IConfigurationEnvironment;
}

/**
 * Metadata about a phase.
 * @alpha
 */
export declare interface IPhase {
    /**
     * The name of this phase.
     */
    name: string;
    /**
     * If set to "true," this this phase was generated from a bulk command, and
     * was not explicitly defined in the command-line.json file.
     */
    isSynthetic: boolean;
    /**
     * This property is used in the name of the filename for the logs generated by this
     * phase. This is a filesystem-safe version of the phase name. For example,
     * a phase with name "_phase:compile" has a `logFilenameIdentifier` of "_phase_compile".
     */
    logFilenameIdentifier: string;
    /**
     * The set of custom command line parameters that are relevant to this phase.
     */
    associatedParameters: Set<CommandLineParameter>;
    /**
     * The resolved dependencies of the phase
     */
    dependencies: {
        self: Set<IPhase>;
        upstream: Set<IPhase>;
    };
    /**
     * Normally Rush requires that each project's package.json has a \"scripts\" entry matching the phase name. To disable this check, set \"ignoreMissingScript\" to true.
     */
    ignoreMissingScript: boolean;
    /**
     * By default, Rush returns a nonzero exit code if errors or warnings occur during a command. If this option is set to \"true\", Rush will return a zero exit code if warnings occur during the execution of this phase.
     */
    allowWarningsOnSuccess: boolean;
}

/**
 * Information about the currently executing phased script command (as defined in command-line.json, or default "build" or "rebuild") provided to plugins.
 * @beta
 */
export declare interface IPhasedCommand extends IRushCommand {
    /**
     * Hooks into the execution of the current phased command
     * @alpha
     */
    readonly hooks: PhasedCommandHooks;
}

/**
 * Part of IRushConfigurationJson.
 * @internal
 */
export declare interface _IPnpmOptionsJson extends IPackageManagerOptionsJsonBase {
    /**
     * The store resolution method for PNPM to use
     */
    pnpmStore?: PnpmStoreOptions;
    /**
     * Should PNPM fail if peer dependencies aren't installed?
     */
    strictPeerDependencies?: boolean;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.preventManualShrinkwrapChanges}
     */
    preventManualShrinkwrapChanges?: boolean;
    /**
     * {@inheritDoc PnpmOptionsConfiguration.useWorkspaces}
     */
    useWorkspaces?: boolean;
}

/**
 * Information about the currently executing command provided to plugins.
 * @beta
 */
export declare interface IRushCommand {
    /**
     * The name of this command, as seen on the command line
     */
    readonly actionName: string;
}

/**
 * This represents the JSON data structure for the "rush.json" configuration file.
 * See rush.schema.json for documentation.
 */
declare interface IRushConfigurationJson {
    $schema: string;
    npmVersion?: string;
    pnpmVersion?: string;
    yarnVersion?: string;
    rushVersion: string;
    repository?: IRushRepositoryJson;
    nodeSupportedVersionRange?: string;
    suppressNodeLtsWarning?: boolean;
    projectFolderMinDepth?: number;
    projectFolderMaxDepth?: number;
    allowMostlyStandardPackageNames?: boolean;
    approvedPackagesPolicy?: IApprovedPackagesPolicyJson;
    gitPolicy?: IRushGitPolicyJson;
    telemetryEnabled?: boolean;
    allowedProjectTags?: string[];
    projects: IRushConfigurationProjectJson[];
    eventHooks?: IEventHooksJson;
    hotfixChangeEnabled?: boolean;
    npmOptions?: _INpmOptionsJson;
    pnpmOptions?: _IPnpmOptionsJson;
    yarnOptions?: _IYarnOptionsJson;
    ensureConsistentVersions?: boolean;
    variants?: IRushVariantOptionsJson[];
}

/**
 * This represents the JSON data object for a project entry in the rush.json configuration file.
 */
declare interface IRushConfigurationProjectJson {
    packageName: string;
    projectFolder: string;
    reviewCategory?: string;
    cyclicDependencyProjects: string[];
    versionPolicyName?: string;
    shouldPublish?: boolean;
    skipRushCheck?: boolean;
    publishFolder?: string;
    tags?: string[];
}

/**
 * @internal
 */
declare interface IRushConfigurationProjectOptions {
    /**
     * The raw JSON representation from rush.json
     */
    projectJson: IRushConfigurationProjectJson;
    /**
     * The enclosing configuration
     */
    rushConfiguration: RushConfiguration;
    /**
     * A unique string name for this project
     */
    tempProjectName: string;
    /**
     * If specified, validate project tags against this list.
     */
    allowedProjectTags: Set<string> | undefined;
}

/**
 * Part of IRushConfigurationJson.
 */
declare interface IRushGitPolicyJson {
    allowedEmailRegExps?: string[];
    sampleEmail?: string;
    versionBumpCommitMessage?: string;
    changeLogUpdateCommitMessage?: string;
    tagSeparator?: string;
}

/**
 * @beta
 */
export declare interface IRushPlugin {
    apply(rushSession: RushSession, rushConfiguration: RushConfiguration): void;
}

declare interface IRushPluginConfiguration extends _IRushPluginConfigurationBase {
    autoinstallerName: string;
}

/**
 * @internal
 */
export declare interface _IRushPluginConfigurationBase {
    packageName: string;
    pluginName: string;
}

declare interface IRushPluginsConfigurationJson {
    plugins: IRushPluginConfiguration[];
}

declare type IRushRepositoryJson = IRushRepositoryJsonSingleUrl | IRushRepositoryJsonMultipleUrls;

/**
 * Part of IRushConfigurationJson.
 */
declare interface IRushRepositoryJsonBase {
    /**
     * The default branch name. This tells "rush change" which remote branch to compare against.
     */
    defaultBranch?: string;
    /**
     * The default remote. This tells "rush change" which remote to compare against if the remote URL is not set
     * or if a remote matching the provided remote URL is not found.
     */
    defaultRemote?: string;
}

declare interface IRushRepositoryJsonMultipleUrls extends IRushRepositoryJsonBase {
    /**
     * Remote url(s) of the repository. If a value is provided, \"rush change\" will
     * use one of these to find the right remote to compare against. Specifying multiple URLs
     * is useful if a GitHub repository is renamed or for "<projectName>.visualstudio.com" vs
     * "dev.azure.com/<projectName>" URLs.
     */
    urls?: string[];
}

declare interface IRushRepositoryJsonSingleUrl extends IRushRepositoryJsonBase {
    /**
     * The remote url of the repository. If a value is provided,
     * \"rush change\" will use it to find the right remote to compare against.
     *
     * @deprecated Use "urls" instead.
     */
    url?: string;
}

/**
 * @beta
 */
export declare interface IRushSessionOptions {
    terminalProvider: ITerminalProvider;
    getIsDebugMode: () => boolean;
}

/**
 * Options defining an allowed variant as part of IRushConfigurationJson.
 */
declare interface IRushVariantOptionsJson {
    variantName: string;
    description: string;
}

/**
 * Represents a readonly view of a `Stopwatch`.
 * @alpha
 */
export declare interface IStopwatchResult {
    /**
     * Displays how long the stopwatch has been executing in a human readable format.
     */
    toString(): string;
    /**
     * Get the duration in seconds.
     */
    get duration(): number;
    /**
     * Return the start time of the most recent stopwatch run.
     */
    get startTime(): number | undefined;
    /**
     * Return the end time of the most recent stopwatch run.
     */
    get endTime(): number | undefined;
}

/**
 * @beta
 */
export declare interface ITelemetryData {
    /**
     * Command name
     * @example 'build'
     */
    readonly name: string;
    /**
     * Duration in seconds
     */
    readonly durationInSeconds: number;
    /**
     * The result of the command
     */
    readonly result: 'Succeeded' | 'Failed';
    /**
     * The timestamp of the telemetry logging
     * @example 1648001893024
     */
    readonly timestamp?: number;
    /**
     * The platform the command was executed on, reads from process.platform
     * @example darwin, win32, linux...
     */
    readonly platform?: string;
    /**
     * The rush version
     * @example 5.63.0
     */
    readonly rushVersion?: string;
    readonly extraData?: {
        [key: string]: string | number | boolean;
    };
}

/**
 * Options for `RushConfiguration.tryFindRushJsonLocation`.
 * @public
 */
export declare interface ITryFindRushJsonLocationOptions {
    /**
     * Whether to show verbose console messages.  Defaults to false.
     */
    showVerbose?: boolean;
    /**
     * The folder path where the search will start.  Defaults tot he current working directory.
     */
    startingFolder?: string;
}

declare interface IVersionPolicyDependencyJson {
    versionFormatForPublish?: VersionFormatForPublish;
    versionFormatForCommit?: VersionFormatForCommit;
}

declare interface IVersionPolicyJson {
    policyName: string;
    definitionName: string;
    dependencies?: IVersionPolicyDependencyJson;
    exemptFromRushChange?: boolean;
    includeEmailInChangeFile?: boolean;
}

/**
 * Part of IRushConfigurationJson.
 * @internal
 */
export declare interface _IYarnOptionsJson extends IPackageManagerOptionsJsonBase {
    /**
     * If true, then Rush will add the "--ignore-engines" option when invoking Yarn.
     * This allows "rush install" to succeed if there are dependencies with engines defined in
     * package.json which do not match the current environment.
     *
     * The default value is false.
     */
    ignoreEngines?: boolean;
}

/**
 * A helper class for managing last-install flags, which are persistent and
 * indicate that something installed in the folder was successfully completed.
 * It also compares state, so that if something like the Node.js version has changed,
 * it can invalidate the last install.
 * @internal
 */
export declare class _LastInstallFlag {
    private _path;
    private _state;
    /**
     * Creates a new LastInstall flag
     * @param folderPath - the folder that this flag is managing
     * @param state - optional, the state that should be managed or compared
     */
    constructor(folderPath: string, state?: JsonObject);
    /**
     * Returns true if the file exists and the contents match the current state.
     */
    isValid(): boolean;
    /**
     * Same as isValid(), but with an additional check:  If the current state is not equal to the previous
     * state, and an the current state causes an error, then throw an exception with a friendly message.
     *
     * @internal
     */
    checkValidAndReportStoreIssues(): boolean;
    private _isValid;
    /**
     * Writes the flag file to disk with the current state
     */
    create(): void;
    /**
     * Removes the flag file
     */
    clear(): void;
    /**
     * Returns the full path to the flag file
     */
    get path(): string;
    /**
     * Returns the name of the flag file
     */
    protected get flagName(): string;
}

/**
 * This policy indicates all related projects should use the same version.
 * @public
 */
export declare class LockStepVersionPolicy extends VersionPolicy {
    private _version;
    private _nextBump;
    private _mainProject;
    /**
     * @internal
     */
    constructor(versionPolicyJson: ILockStepVersionJson);
    /**
     * The value of the lockstep version
     */
    get version(): string;
    /**
     * The type of bump for next bump.
     */
    get nextBump(): BumpType | undefined;
    /**
     * The main project for the version policy.
     *
     * If the value is provided, change logs will only be generated in that project.
     * If the value is not provided, change logs will be hosted in each project associated with the policy.
     */
    get mainProject(): string | undefined;
    /**
     * Serialized json for this policy
     *
     * @internal
     */
    get _json(): ILockStepVersionJson;
    /**
     * Returns an updated package json that satisfies the version policy.
     *
     * @param project - input package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    ensure(project: IPackageJson, force?: boolean): IPackageJson | undefined;
    /**
     * Bumps the version of the lockstep policy
     *
     * @param bumpType - Overwrite bump type in version-policy.json with the provided value.
     * @param identifier - Prerelease identifier if bump type is prerelease.
     */
    bump(bumpType?: BumpType, identifier?: string): void;
    /**
     * Updates the version of the policy directly with a new value
     * @param newVersionString - New version
     */
    update(newVersionString: string): boolean;
    /**
     * Validates the specified version and throws if the version does not satisfy lockstep version.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    validate(versionString: string, packageName: string): void;
    private _updatePackageVersion;
    private _getReleaseType;
}

/**
 * This class is used to associate POSIX relative paths, such as those returned by `git` commands,
 * with entities that correspond with ancestor folders, such as Rush Projects.
 *
 * It is optimized for efficiently locating the nearest ancestor path with an associated value.
 *
 * @example
 * ```ts
 * const tree = new LookupByPath([['foo', 1], ['bar', 2], ['foo/bar', 3]]);
 * tree.getNearestAncestor('foo'); // returns 1
 * tree.getNearestAncestor('foo/baz'); // returns 1
 * tree.getNearestAncestor('baz'); // returns undefined
 * tree.getNearestAncestor('foo/bar/baz'); returns 3
 * tree.getNearestAncestor('bar/foo/bar'); returns 2
 * ```
 * @beta
 */
export declare class LookupByPath<TItem> {
    /**
     * The delimiter used to split paths
     */
    readonly delimiter: string;
    /**
     * The root node of the tree, corresponding to the path ''
     */
    private readonly _root;
    /**
     * Constructs a new `LookupByPath`
     *
     * @param entries - Initial path-value pairs to populate the tree.
     */
    constructor(entries?: Iterable<[string, TItem]>, delimiter?: string);
    /**
     * Iterates over the segments of a serialized path.
     *
     * @example
     *
     * `LookupByPath.iteratePathSegments('foo/bar/baz')` yields 'foo', 'bar', 'baz'
     *
     * `LookupByPath.iteratePathSegments('foo\\bar\\baz', '\\')` yields 'foo', 'bar', 'baz'
     */
    static iteratePathSegments(serializedPath: string, delimiter?: string): Iterable<string>;
    /**
     * Associates the value with the specified serialized path.
     * If a value is already associated, will overwrite.
     *
     * @returns this, for chained calls
     */
    setItem(serializedPath: string, value: TItem): this;
    /**
     * Associates the value with the specified path.
     * If a value is already associated, will overwrite.
     *
     * @returns this, for chained calls
     */
    setItemFromSegments(pathSegments: Iterable<string>, value: TItem): this;
    /**
     * Searches for the item associated with `childPath`, or the nearest ancestor of that path that
     * has an associated item.
     *
     * @returns the found item, or `undefined` if no item was found
     *
     * @example
     * ```ts
     * const tree = new LookupByPath([['foo', 1], ['foo/bar', 2]]);
     * tree.findChildPath('foo/baz'); // returns 1
     * tree.findChildPath('foo/bar/baz'); // returns 2
     * ```
     */
    findChildPath(childPath: string): TItem | undefined;
    /**
     * Searches for the item associated with `childPathSegments`, or the nearest ancestor of that path that
     * has an associated item.
     *
     * @returns the found item, or `undefined` if no item was found
     *
     * @example
     * ```ts
     * const tree = new LookupByPath([['foo', 1], ['foo/bar', 2]]);
     * tree.findChildPathFromSegments(['foo', 'baz']); // returns 1
     * tree.findChildPathFromSegments(['foo','bar', 'baz']); // returns 2
     * ```
     */
    findChildPathFromSegments(childPathSegments: Iterable<string>): TItem | undefined;
}

/**
 * Options that are only used when the NPM package manager is selected.
 *
 * @remarks
 * It is valid to define these options in rush.json even if the NPM package manager
 * is not being used.
 *
 * @public
 */
export declare class NpmOptionsConfiguration extends PackageManagerOptionsConfigurationBase {
    /** @internal */
    constructor(json: _INpmOptionsJson);
}

/**
 * The `Operation` class is a node in the dependency graph of work that needs to be scheduled by the
 * `OperationExecutionManager`. Each `Operation` has a `runner` member of type `IOperationRunner`, whose
 * implementation manages the actual process of running a single operation.
 *
 * The graph of `Operation` instances will be cloned into a separate execution graph after processing.
 *
 * @alpha
 */
export declare class Operation {
    /**
     * The Rush phase associated with this Operation, if any
     */
    readonly associatedPhase: IPhase | undefined;
    /**
     * The Rush project associated with this Operation, if any
     */
    readonly associatedProject: RushConfigurationProject | undefined;
    /**
     * A set of all operations which depend on this operation.
     */
    readonly consumers: ReadonlySet<Operation>;
    /**
     * A set of all dependencies which must be executed before this operation is complete.
     */
    readonly dependencies: ReadonlySet<Operation>;
    /**
     * When the scheduler is ready to process this `Operation`, the `runner` implements the actual work of
     * running the operation.
     */
    runner: IOperationRunner | undefined;
    /**
     * The weight for this operation. This scalar is the contribution of this operation to the
     * `criticalPathLength` calculation above. Modify to indicate the following:
     * - `weight` === 1: indicates that this operation has an average duration
     * - `weight` &gt; 1: indicates that this operation takes longer than average and so the scheduler
     *     should try to favor starting it over other, shorter operations. An example might be an operation that
     *     bundles an entire application and runs whole-program optimization.
     * - `weight` &lt; 1: indicates that this operation takes less time than average and so the scheduler
     *     should favor other, longer operations over it. An example might be an operation to unpack a cached
     *     output, or an operation using NullOperationRunner, which might use a value of 0.
     */
    weight: number;
    constructor(options?: IOperationOptions);
    /**
     * The name of this operation, for logging.
     */
    get name(): string | undefined;
    /**
     * Adds the specified operation as a dependency and updates the consumer list.
     */
    addDependency(dependency: Operation): void;
    /**
     * Deletes the specified operation as a dependency and updates the consumer list.
     */
    deleteDependency(dependency: Operation): void;
}

/**
 * Enumeration defining potential states of an operation
 * @beta
 */
export declare enum OperationStatus {
    /**
     * The Operation is on the queue, ready to execute (but may be waiting for dependencies)
     */
    Ready = "READY",
    /**
     * The Operation is currently executing
     */
    Executing = "EXECUTING",
    /**
     * The Operation completed successfully and did not write to standard output
     */
    Success = "SUCCESS",
    /**
     * The Operation completed successfully, but wrote to standard output
     */
    SuccessWithWarning = "SUCCESS WITH WARNINGS",
    /**
     * The Operation was skipped via the legacy incremental build logic
     */
    Skipped = "SKIPPED",
    /**
     * The Operation had its outputs restored from the build cache
     */
    FromCache = "FROM CACHE",
    /**
     * The Operation failed
     */
    Failure = "FAILURE",
    /**
     * The Operation could not be executed because one or more of its dependencies failed
     */
    Blocked = "BLOCKED",
    /**
     * The Operation was a no-op (for example, it had an empty script)
     */
    NoOp = "NO OP"
}

/**
 * @public
 */
export declare class PackageJsonDependency {
    private _type;
    private _name;
    private _version;
    private _onChange;
    constructor(name: string, version: string, type: DependencyType, onChange: () => void);
    get name(): string;
    get version(): string;
    setVersion(newVersion: string): void;
    get dependencyType(): DependencyType;
}

/**
 * @public
 */
export declare class PackageJsonEditor {
    private readonly _filePath;
    private readonly _dependencies;
    private readonly _devDependencies;
    private readonly _resolutions;
    private _modified;
    private _sourceData;
    private constructor();
    static load(filePath: string): PackageJsonEditor;
    static fromObject(object: IPackageJson, filename: string): PackageJsonEditor;
    get name(): string;
    get version(): string;
    get filePath(): string;
    /**
     * The list of dependencies of type DependencyType.Regular, DependencyType.Optional, or DependencyType.Peer.
     */
    get dependencyList(): ReadonlyArray<PackageJsonDependency>;
    /**
     * The list of dependencies of type DependencyType.Dev.
     */
    get devDependencyList(): ReadonlyArray<PackageJsonDependency>;
    /**
     * This field is a Yarn-specific feature that allows overriding of package resolution.
     *
     * @remarks
     * See the {@link https://github.com/yarnpkg/rfcs/blob/master/implemented/0000-selective-versions-resolutions.md
     * | 0000-selective-versions-resolutions.md RFC} for details.
     */
    get resolutionsList(): ReadonlyArray<PackageJsonDependency>;
    tryGetDependency(packageName: string): PackageJsonDependency | undefined;
    tryGetDevDependency(packageName: string): PackageJsonDependency | undefined;
    addOrUpdateDependency(packageName: string, newVersion: string, dependencyType: DependencyType): void;
    saveIfModified(): boolean;
    /**
     * Get the normalized package.json that represents the current state of the
     * PackageJsonEditor. This method does not save any changes that were made to the
     * package.json, but instead returns the object representation of what would be saved
     * if saveIfModified() is called.
     */
    saveToObject(): IPackageJson;
    private _onChange;
    /**
     * Create a normalized shallow copy of the provided package.json without modifying the
     * original. If the result of this method is being returned via a public facing method,
     * it will still need to be deep-cloned to avoid propogating changes back to the
     * original dataset.
     */
    private _normalize;
}

/**
 * An abstraction for controlling the supported package managers: PNPM, NPM, and Yarn.
 * @public
 */
export declare abstract class PackageManager {
    /**
     * The package manager.
     */
    readonly packageManager: PackageManagerName;
    /**
     * The SemVer version of the package manager.
     */
    readonly version: string;
    protected _shrinkwrapFilename: string;
    /** @internal */
    protected constructor(version: string, packageManager: PackageManagerName);
    /**
     * The filename of the shrinkwrap file that is used by the package manager.
     *
     * @remarks
     * Example: `npm-shrinkwrap.json` or `pnpm-lock.yaml`
     */
    get shrinkwrapFilename(): string;
}

/**
 * This represents the available Package Manager tools as a string
 * @public
 */
export declare type PackageManagerName = 'pnpm' | 'npm' | 'yarn';

/**
 * Options that all package managers share.
 *
 * @public
 */
export declare abstract class PackageManagerOptionsConfigurationBase implements IPackageManagerOptionsJsonBase {
    /**
     * Environment variables for the package manager
     */
    readonly environmentVariables?: IConfigurationEnvironment;
    /** @internal */
    protected constructor(json: IPackageManagerOptionsJsonBase);
}

/**
 * Hooks into the execution process for phased commands
 * @alpha
 */
export declare class PhasedCommandHooks {
    /**
     * Hook invoked to create operations for execution.
     * Use the context to distinguish between the initial run and phased runs.
     */
    readonly createOperations: AsyncSeriesWaterfallHook<[Set<Operation>, ICreateOperationsContext]>;
    /**
     * Hook invoked after executing a set of operations.
     * Use the context to distinguish between the initial run and phased runs.
     * Hook is series for stable output.
     */
    readonly afterExecuteOperations: AsyncSeriesHook<[IExecutionResult, ICreateOperationsContext]>;
    /**
     * Hook invoked after a run has finished and the command is watching for changes.
     * May be used to display additional relevant data to the user.
     * Only relevant when running in watch mode.
     */
    readonly waitingForChanges: SyncHook<void>;
}

/**
 * Options that are only used when the PNPM package manager is selected.
 *
 * @remarks
 * It is valid to define these options in rush.json even if the PNPM package manager
 * is not being used.
 *
 * @public
 */
export declare class PnpmOptionsConfiguration extends PackageManagerOptionsConfigurationBase {
    /**
     * The method used to resolve the store used by PNPM.
     *
     * @remarks
     * Available options:
     *  - local: Use the standard Rush store path: common/temp/pnpm-store
     *  - global: Use PNPM's global store path
     */
    readonly pnpmStore: PnpmStoreOptions;
    /**
     * The path for PNPM to use as the store directory.
     *
     * Will be overridden by environment variable RUSH_PNPM_STORE_PATH
     */
    readonly pnpmStorePath: string;
    /**
     * If true, then Rush will add the "--strict-peer-dependencies" option when invoking PNPM.
     *
     * @remarks
     * This causes "rush install" to fail if there are unsatisfied peer dependencies, which is
     * an invalid state that can cause build failures or incompatible dependency versions.
     * (For historical reasons, JavaScript package managers generally do not treat this invalid state
     * as an error.)
     *
     * The default value is false.  (For now.)
     */
    readonly strictPeerDependencies: boolean;
    /**
     * If true, then `rush install` will report an error if manual modifications
     * were made to the PNPM shrinkwrap file without running `rush update` afterwards.
     *
     * @remarks
     * This feature protects against accidental inconsistencies that may be introduced
     * if the PNPM shrinkwrap file (`pnpm-lock.yaml`) is manually edited.  When this
     * feature is enabled, `rush update` will write a hash of the shrinkwrap contents to repo-state.json,
     * and then `rush update` and `rush install` will validate the hash.  Note that this does not prohibit
     * manual modifications, but merely requires `rush update` be run
     * afterwards, ensuring that PNPM can report or repair any potential inconsistencies.
     *
     * To temporarily disable this validation when invoking `rush install`, use the
     * `--bypass-policy` command-line parameter.
     *
     * The default value is false.
     */
    readonly preventManualShrinkwrapChanges: boolean;
    /**
     * If true, then Rush will use the workspaces feature to install and link packages when invoking PNPM.
     *
     * @remarks
     * The default value is false.  (For now.)
     */
    readonly useWorkspaces: boolean;
    /** @internal */
    constructor(json: _IPnpmOptionsJson, commonTempFolder: string);
}

/**
 * This represents the available PNPM store options
 * @public
 */
export declare type PnpmStoreOptions = 'local' | 'global';

/**
 * @beta
 */
export declare class ProjectChangeAnalyzer {
    /**
     * UNINITIALIZED === we haven't looked
     * undefined === data isn't available (i.e. - git isn't present)
     */
    private _data;
    private readonly _filteredData;
    private readonly _projectStateCache;
    private readonly _rushConfiguration;
    private readonly _git;
    constructor(rushConfiguration: RushConfiguration);
    /**
     * Try to get a list of the specified project's dependencies and their hashes.
     *
     * @remarks
     * If the data can't be generated (i.e. - if Git is not present) this returns undefined.
     *
     * @internal
     */
    _tryGetProjectDependenciesAsync(project: RushConfigurationProject, terminal: ITerminal): Promise<Map<string, string> | undefined>;
    /**
     * The project state hash is calculated in the following way:
     * - Project dependencies are collected (see ProjectChangeAnalyzer.getPackageDeps)
     *   - If project dependencies cannot be collected (i.e. - if Git isn't available),
     *     this function returns `undefined`
     * - The (path separator normalized) repo-root-relative dependencies' file paths are sorted
     * - A SHA1 hash is created and each (sorted) file path is fed into the hash and then its
     *   Git SHA is fed into the hash
     * - A hex digest of the hash is returned
     *
     * @internal
     */
    _tryGetProjectStateHashAsync(project: RushConfigurationProject, terminal: ITerminal): Promise<string | undefined>;
    _filterProjectDataAsync<T>(project: RushConfigurationProject, unfilteredProjectData: Map<string, T>, rootDir: string, terminal: ITerminal): Promise<Map<string, T>>;
    /**
     * Gets a list of projects that have changed in the current state of the repo
     * when compared to the specified branch, optionally taking the shrinkwrap and settings in
     * the rush-project.json file into consideration.
     */
    getChangedProjectsAsync(options: IGetChangedProjectsOptions): Promise<Set<RushConfigurationProject>>;
    private _getData;
    private _getIgnoreMatcherForProjectAsync;
    private _getRepoDeps;
}

/**
 * This file is used to track the state of various Rush-related features. It is generated
 * and updated by Rush.
 *
 * @public
 */
export declare class RepoStateFile {
    private static _jsonSchema;
    private _repoStateFilePath;
    private _variant;
    private _pnpmShrinkwrapHash;
    private _preferredVersionsHash;
    private _isValid;
    private _modified;
    private constructor();
    /**
     * Get the absolute file path of the repo-state.json file.
     */
    get filePath(): string;
    /**
     * The hash of the pnpm shrinkwrap file at the end of the last update.
     */
    get pnpmShrinkwrapHash(): string | undefined;
    /**
     * The hash of all preferred versions at the end of the last update.
     */
    get preferredVersionsHash(): string | undefined;
    /**
     * If false, the repo-state.json file is not valid and its values cannot be relied upon
     */
    get isValid(): boolean;
    /**
     * Loads the repo-state.json data from the specified file path.
     * If the file has not been created yet, then an empty object is returned.
     *
     * @param jsonFilename - The path to the repo-state.json file.
     * @param variant - The variant currently being used by Rush.
     */
    static loadFromFile(jsonFilename: string, variant: string | undefined): RepoStateFile;
    /**
     * Refresh the data contained in repo-state.json using the current state
     * of the Rush repo, and save the file if changes were made.
     *
     * @param rushConfiguration - The Rush configuration for the repo.
     *
     * @returns true if the file was modified, otherwise false.
     */
    refreshState(rushConfiguration: RushConfiguration): boolean;
    /**
     * Writes the "repo-state.json" file to disk, using the filename that was passed to loadFromFile().
     */
    private _saveIfModified;
    private _serialize;
}

/**
 * General operations for the Rush engine.
 *
 * @public
 */
export declare class Rush {
    private static _version;
    /**
     * This API is used by the `@microsoft/rush` front end to launch the "rush" command-line.
     * Third-party tools should not use this API.  Instead, they should execute the "rush" binary
     * and start a new Node.js process.
     *
     * @remarks
     * Earlier versions of the rush frontend used a different API contract. In the old contract,
     * the second argument was the `isManaged` value of the {@link ILaunchOptions} object.
     *
     * Even though this API isn't documented, it is still supported for legacy compatibility.
     */
    static launch(launcherVersion: string, arg: ILaunchOptions): void;
    /**
     * This API is used by the `@microsoft/rush` front end to launch the "rushx" command-line.
     * Third-party tools should not use this API.  Instead, they should execute the "rushx" binary
     * and start a new Node.js process.
     */
    static launchRushX(launcherVersion: string, options: ILaunchOptions): void;
    /**
     * This API is used by the `@microsoft/rush` front end to launch the "rush-pnpm" command-line.
     * Third-party tools should not use this API.  Instead, they should execute the "rush-pnpm" binary
     * and start a new Node.js process.
     */
    static launchRushPnpm(launcherVersion: string, options: ILaunchOptions): void;
    /**
     * The currently executing version of the "rush-lib" library.
     * This is the same as the Rush tool version for that release.
     */
    static get version(): string;
    /**
     * Assign the `RUSH_INVOKED_FOLDER` environment variable during startup.  This is only applied when
     * Rush is invoked via the CLI, not via the `@microsoft/rush-lib` automation API.
     *
     * @remarks
     * Modifying the parent process's environment is not a good design.  The better design is (1) to consolidate
     * Rush's code paths that invoke scripts, and (2) to pass down the invoked folder with each code path,
     * so that it can finally be applied in a centralized helper like `Utilities._createEnvironmentForRushCommand()`.
     * The natural time to do that refactoring is when we rework `Utilities.executeCommand()` to use
     * `Executable.spawn()` or rushell.
     */
    private static _assignRushInvokedFolder;
    /**
     * This function normalizes legacy options to the current {@link ILaunchOptions} object.
     */
    private static _normalizeLaunchOptions;
}

/**
 * This represents the Rush configuration for a repository, based on the "rush.json"
 * configuration file.
 * @public
 */
export declare class RushConfiguration {
    private static _jsonSchema;
    private _rushJsonFile;
    private _rushJsonFolder;
    private _changesFolder;
    private _commonFolder;
    private _commonTempFolder;
    private _commonScriptsFolder;
    private _commonRushConfigFolder;
    private _packageManager;
    private _packageManagerWrapper;
    private _npmCacheFolder;
    private _npmTmpFolder;
    private _yarnCacheFolder;
    private _shrinkwrapFilename;
    private _tempShrinkwrapFilename;
    private _tempShrinkwrapPreinstallFilename;
    private _currentVariantJsonFilename;
    private _packageManagerToolVersion;
    private _packageManagerToolFilename;
    private _projectFolderMinDepth;
    private _projectFolderMaxDepth;
    private _allowMostlyStandardPackageNames;
    private _ensureConsistentVersions;
    private _suppressNodeLtsWarning;
    private _variants;
    private readonly _pathTrees;
    private _approvedPackagesPolicy;
    private _gitAllowedEmailRegExps;
    private _gitSampleEmail;
    private _gitVersionBumpCommitMessage;
    private _gitChangeLogUpdateCommitMessage;
    private _gitTagSeparator;
    private _hotfixChangeEnabled;
    private _repositoryUrls;
    private _repositoryDefaultBranch;
    private _repositoryDefaultRemote;
    private _npmOptions;
    private _pnpmOptions;
    private _yarnOptions;
    private _packageManagerConfigurationOptions;
    private _eventHooks;
    private readonly _packageNameParser;
    private _telemetryEnabled;
    private _projects;
    private _projectsByName;
    private _projectsByTag;
    private _commonVersionsConfigurationsByVariant;
    private _versionPolicyConfiguration;
    private _versionPolicyConfigurationFilePath;
    private _experimentsConfiguration;
    private __rushPluginsConfiguration;
    private readonly _rushConfigurationJson;
    /**
     * Use RushConfiguration.loadFromConfigurationFile() or Use RushConfiguration.loadFromDefaultLocation()
     * instead.
     */
    private constructor();
    private _initializeAndValidateLocalProjects;
    /**
     * Loads the configuration data from an Rush.json configuration file and returns
     * an RushConfiguration object.
     */
    static loadFromConfigurationFile(rushJsonFilename: string): RushConfiguration;
    static loadFromDefaultLocation(options?: ITryFindRushJsonLocationOptions): RushConfiguration;
    /**
     * Find the rush.json location and return the path, or undefined if a rush.json can't be found.
     *
     * @privateRemarks
     * Keep this in sync with `findRushJsonLocation` in `rush-sdk/src/index.ts`.
     */
    static tryFindRushJsonLocation(options?: ITryFindRushJsonLocationOptions): string | undefined;
    /**
     * This generates the unique names that are used to create temporary projects
     * in the Rush common folder.
     * NOTE: sortedProjectJsons is sorted by the caller.
     */
    private static _generateTempNameForProject;
    /**
     * If someone adds a config file in the "common/rush/config" folder, it would be a bad
     * experience for Rush to silently ignore their file simply because they misspelled the
     * filename, or maybe it's an old format that's no longer supported.  The
     * _validateCommonRushConfigFolder() function makes sure that this folder only contains
     * recognized config files.
     */
    private static _validateCommonRushConfigFolder;
    /**
     * The name of the package manager being used to install dependencies
     */
    get packageManager(): PackageManagerName;
    /**
     * {@inheritdoc PackageManager}
     *
     * @privateremarks
     * In the next major breaking API change, we will rename this property to "packageManager" and eliminate the
     * old property with that name.
     *
     * @beta
     */
    get packageManagerWrapper(): PackageManager;
    /**
     * Gets the JSON data structure for the "rush.json" configuration file.
     *
     * @internal
     */
    get rushConfigurationJson(): IRushConfigurationJson;
    /**
     * The absolute path to the "rush.json" configuration file that was loaded to construct this object.
     */
    get rushJsonFile(): string;
    /**
     * The absolute path of the folder that contains rush.json for this project.
     */
    get rushJsonFolder(): string;
    /**
     * The folder that contains all change files.
     */
    get changesFolder(): string;
    /**
     * The fully resolved path for the "common" folder where Rush will store settings that
     * affect all Rush projects.  This is always a subfolder of the folder containing "rush.json".
     * Example: `C:\MyRepo\common`
     */
    get commonFolder(): string;
    /**
     * The folder where Rush's additional config files are stored.  This folder is always a
     * subfolder called `config\rush` inside the common folder.  (The `common\config` folder
     * is reserved for configuration files used by other tools.)  To avoid confusion or mistakes,
     * Rush will report an error if this this folder contains any unrecognized files.
     *
     * Example: `C:\MyRepo\common\config\rush`
     */
    get commonRushConfigFolder(): string;
    /**
     * The folder where temporary files will be stored.  This is always a subfolder called "temp"
     * under the common folder.
     * Example: `C:\MyRepo\common\temp`
     */
    get commonTempFolder(): string;
    /**
     * The folder where automation scripts are stored.  This is always a subfolder called "scripts"
     * under the common folder.
     * Example: `C:\MyRepo\common\scripts`
     */
    get commonScriptsFolder(): string;
    /**
     * The fully resolved path for the "autoinstallers" folder.
     * Example: `C:\MyRepo\common\autoinstallers`
     */
    get commonAutoinstallersFolder(): string;
    /**
     * The folder where rush-plugin options json files are stored.
     * Example: `C:\MyRepo\common\config\rush-plugins`
     */
    get rushPluginOptionsFolder(): string;
    /**
     * The local folder that will store the NPM package cache.  Rush does not rely on the
     * npm's default global cache folder, because npm's caching implementation does not
     * reliably handle multiple processes.  (For example, if a build box is running
     * "rush install" simultaneously for two different working folders, it may fail randomly.)
     *
     * Example: `C:\MyRepo\common\temp\npm-cache`
     */
    get npmCacheFolder(): string;
    /**
     * The local folder where npm's temporary files will be written during installation.
     * Rush does not rely on the global default folder, because it may be on a different
     * hard disk.
     *
     * Example: `C:\MyRepo\common\temp\npm-tmp`
     */
    get npmTmpFolder(): string;
    /**
     * The local folder that will store the Yarn package cache.
     *
     * Example: `C:\MyRepo\common\temp\yarn-cache`
     */
    get yarnCacheFolder(): string;
    /**
     * The full path of the shrinkwrap file that is tracked by Git.  (The "rush install"
     * command uses a temporary copy, whose path is tempShrinkwrapFilename.)
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `C:\MyRepo\common\npm-shrinkwrap.json` or `C:\MyRepo\common\pnpm-lock.yaml`
     *
     * @deprecated Use `getCommittedShrinkwrapFilename` instead, which gets the correct common
     * shrinkwrap file name for a given active variant.
     */
    get committedShrinkwrapFilename(): string;
    /**
     * The filename (without any path) of the shrinkwrap file that is used by the package manager.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `npm-shrinkwrap.json` or `pnpm-lock.yaml`
     */
    get shrinkwrapFilename(): string;
    /**
     * The full path of the temporary shrinkwrap file that is used during "rush install".
     * This file may get rewritten by the package manager during installation.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `C:\MyRepo\common\temp\npm-shrinkwrap.json` or `C:\MyRepo\common\temp\pnpm-lock.yaml`
     */
    get tempShrinkwrapFilename(): string;
    /**
     * The full path of a backup copy of tempShrinkwrapFilename. This backup copy is made
     * before installation begins, and can be compared to determine how the package manager
     * modified tempShrinkwrapFilename.
     * @remarks
     * This property merely reports the filename; the file itself may not actually exist.
     * Example: `C:\MyRepo\common\temp\npm-shrinkwrap-preinstall.json`
     * or `C:\MyRepo\common\temp\pnpm-lock-preinstall.yaml`
     */
    get tempShrinkwrapPreinstallFilename(): string;
    /**
     * Returns an English phrase such as "shrinkwrap file" that can be used in logging messages
     * to refer to the shrinkwrap file using appropriate terminology for the currently selected
     * package manager.
     */
    get shrinkwrapFilePhrase(): string;
    /**
     * The filename of the build dependency data file.  By default this is
     * called 'rush-link.json' resides in the Rush common folder.
     * Its data structure is defined by IRushLinkJson.
     *
     * Example: `C:\MyRepo\common\temp\rush-link.json`
     *
     * @deprecated The "rush-link.json" file was removed in Rush 5.30.0.
     * Use `RushConfigurationProject.localDependencyProjects` instead.
     */
    get rushLinkJsonFilename(): string;
    /**
     * The filename of the variant dependency data file.  By default this is
     * called 'current-variant.json' resides in the Rush common folder.
     * Its data structure is defined by ICurrentVariantJson.
     *
     * Example: `C:\MyRepo\common\temp\current-variant.json`
     */
    get currentVariantJsonFilename(): string;
    /**
     * The version of the locally installed NPM tool.  (Example: "1.2.3")
     */
    get packageManagerToolVersion(): string;
    /**
     * The absolute path to the locally installed NPM tool.  If "rush install" has not
     * been run, then this file may not exist yet.
     * Example: `C:\MyRepo\common\temp\npm-local\node_modules\.bin\npm`
     */
    get packageManagerToolFilename(): string;
    /**
     * The minimum allowable folder depth for the projectFolder field in the rush.json file.
     * This setting provides a way for repository maintainers to discourage nesting of project folders
     * that makes the directory tree more difficult to navigate.  The default value is 2,
     * which implements a standard 2-level hierarchy of <categoryFolder>/<projectFolder>/package.json.
     */
    get projectFolderMinDepth(): number;
    /**
     * The maximum allowable folder depth for the projectFolder field in the rush.json file.
     * This setting provides a way for repository maintainers to discourage nesting of project folders
     * that makes the directory tree more difficult to navigate.  The default value is 2,
     * which implements on a standard convention of <categoryFolder>/<projectFolder>/package.json.
     */
    get projectFolderMaxDepth(): number;
    /**
     * Today the npmjs.com registry enforces fairly strict naming rules for packages, but in the early
     * days there was no standard and hardly any enforcement.  A few large legacy projects are still using
     * nonstandard package names, and private registries sometimes allow it.  Set "allowMostlyStandardPackageNames"
     * to true to relax Rush's enforcement of package names.  This allows upper case letters and in the future may
     * relax other rules, however we want to minimize these exceptions.  Many popular tools use certain punctuation
     * characters as delimiters, based on the assumption that they will never appear in a package name; thus if we relax
     * the rules too much it is likely to cause very confusing malfunctions.
     *
     * The default value is false.
     */
    get allowMostlyStandardPackageNames(): boolean;
    /**
     * The "approvedPackagesPolicy" settings.
     */
    get approvedPackagesPolicy(): ApprovedPackagesPolicy;
    /**
     * [Part of the "gitPolicy" feature.]
     * A list of regular expressions describing allowable email patterns for Git commits.
     * They are case-insensitive anchored JavaScript RegExps.
     * Example: `".*@example\.com"`
     * This array will never be undefined.
     */
    get gitAllowedEmailRegExps(): string[];
    /**
     * [Part of the "gitPolicy" feature.]
     * An example valid email address that conforms to one of the allowedEmailRegExps.
     * Example: `"foxtrot@example\.com"`
     * This will never be undefined, and will always be nonempty if gitAllowedEmailRegExps is used.
     */
    get gitSampleEmail(): string;
    /**
     * [Part of the "gitPolicy" feature.]
     * The commit message to use when committing changes during 'rush publish'
     */
    get gitVersionBumpCommitMessage(): string | undefined;
    /**
     * [Part of the "gitPolicy" feature.]
     * The commit message to use when committing change log files 'rush version'
     */
    get gitChangeLogUpdateCommitMessage(): string | undefined;
    /**
     * [Part of the "gitPolicy" feature.]
     * The separator between package name and version in git tag.
     */
    get gitTagSeparator(): string | undefined;
    /**
     * [Part of the "hotfixChange" feature.]
     * Enables creating hotfix changes
     */
    get hotfixChangeEnabled(): boolean;
    /**
     * Remote URL(s) of the repository. If a value is provided, \"rush change\" will
     * use one of these to find the right remote to compare against. Specifying multiple URLs
     * is useful if a GitHub repository is renamed or for "<projectName>.visualstudio.com" vs
     * "dev.azure.com/<projectName>" URLs.
     */
    get repositoryUrls(): string[];
    /**
     * The default branch name. This tells "rush change" which remote branch to compare against.
     */
    get repositoryDefaultBranch(): string;
    /**
     * The default remote. This tells "rush change" which remote to compare against if the remote URL is not set
     * or if a remote matching the provided remote URL is not found.
     */
    get repositoryDefaultRemote(): string;
    /**
     * The default fully-qualified git remote branch of the repository. This helps "rush change" find the right branch to compare against.
     */
    get repositoryDefaultFullyQualifiedRemoteBranch(): string;
    /**
     * Odd-numbered major versions of Node.js are experimental.  Even-numbered releases
     * spend six months in a stabilization period before the first Long Term Support (LTS) version.
     * For example, 8.9.0 was the first LTS version of Node.js 8.  Pre-LTS versions are not recommended
     * for production usage because they frequently have bugs.  They may cause Rush itself
     * to malfunction.
     *
     * Rush normally prints a warning if it detects a pre-LTS Node.js version.  If you are testing
     * pre-LTS versions in preparation for supporting the first LTS version, you can use this setting
     * to disable Rush's warning.
     */
    get suppressNodeLtsWarning(): boolean;
    /**
     * If true, then consistent version specifiers for dependencies will be enforced.
     * I.e. "rush check" is run before some commands.
     */
    get ensureConsistentVersions(): boolean;
    /**
     * Indicates whether telemetry collection is enabled for Rush runs.
     * @beta
     */
    get telemetryEnabled(): boolean;
    get projects(): RushConfigurationProject[];
    get projectsByName(): Map<string, RushConfigurationProject>;
    /**
     * Obtains the mapping from custom tags to projects.
     * @beta
     */
    get projectsByTag(): ReadonlyMap<string, ReadonlySet<RushConfigurationProject>>;
    /**
     * {@inheritDoc NpmOptionsConfiguration}
     */
    get npmOptions(): NpmOptionsConfiguration;
    /**
     * {@inheritDoc PnpmOptionsConfiguration}
     */
    get pnpmOptions(): PnpmOptionsConfiguration;
    /**
     * {@inheritDoc YarnOptionsConfiguration}
     */
    get yarnOptions(): YarnOptionsConfiguration;
    /**
     * The configuration options used by the current package manager.
     * @remarks
     * For package manager specific variants, reference {@link RushConfiguration.npmOptions | npmOptions},
     * {@link RushConfiguration.pnpmOptions | pnpmOptions}, or {@link RushConfiguration.yarnOptions | yarnOptions}.
     */
    get packageManagerOptions(): PackageManagerOptionsConfigurationBase;
    /**
     * Settings from the common-versions.json config file.
     * @remarks
     * If the common-versions.json file is missing, this property will not be undefined.
     * Instead it will be initialized in an empty state, and calling CommonVersionsConfiguration.save()
     * will create the file.
     *
     * @deprecated Use `getCommonVersions` instead, which gets the correct common version data
     * for a given active variant.
     */
    get commonVersions(): CommonVersionsConfiguration;
    /**
     * Gets the currently-installed variant, if an installation has occurred.
     * For Rush operations which do not take a --variant parameter, this method
     * determines which variant, if any, was last specified when performing "rush install"
     * or "rush update".
     */
    get currentInstalledVariant(): string | undefined;
    /**
     * The rush hooks. It allows customized scripts to run at the specified point.
     * @beta
     */
    get eventHooks(): EventHooks;
    /**
     * The rush hooks. It allows customized scripts to run at the specified point.
     */
    get packageNameParser(): PackageNameParser;
    /**
     * Gets the path to the common-versions.json config file for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getCommonVersionsFilePath(variant?: string | undefined): string;
    /**
     * Gets the settings from the common-versions.json config file for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getCommonVersions(variant?: string | undefined): CommonVersionsConfiguration;
    /**
     * Returns a map of all direct dependencies that only have a single semantic version specifier.
     * @param variant - The name of the current variant in use by the active command.
     *
     * @returns A map of dependency name --\> version specifier for implicitly preferred versions.
     */
    getImplicitlyPreferredVersions(variant?: string | undefined): Map<string, string>;
    /**
     * Gets the path to the repo-state.json file for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getRepoStateFilePath(variant?: string | undefined): string;
    /**
     * Gets the contents from the repo-state.json file for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getRepoState(variant?: string | undefined): RepoStateFile;
    /**
     * Gets the committed shrinkwrap file name for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     */
    getCommittedShrinkwrapFilename(variant?: string | undefined): string;
    /**
     * Gets the absolute path for "pnpmfile.js" for a specific variant.
     * @param variant - The name of the current variant in use by the active command.
     * @remarks
     * The file path is returned even if PNPM is not configured as the package manager.
     */
    getPnpmfilePath(variant?: string | undefined): string;
    /**
     * Looks up a project in the projectsByName map.  If the project is not found,
     * then undefined is returned.
     */
    getProjectByName(projectName: string): RushConfigurationProject | undefined;
    /**
     * This is used e.g. by command-line interfaces such as "rush build --to example".
     * If "example" is not a project name, then it also looks for a scoped name
     * like `@something/example`.  If exactly one project matches this heuristic, it
     * is returned.  Otherwise, undefined is returned.
     */
    findProjectByShorthandName(shorthandProjectName: string): RushConfigurationProject | undefined;
    /**
     * Looks up a project by its RushConfigurationProject.tempProjectName field.
     * @returns The found project, or undefined if no match was found.
     */
    findProjectByTempName(tempProjectName: string): RushConfigurationProject | undefined;
    /**
     * @returns An optimized lookup engine to find a project by its path relative to the specified root.
     * @beta
     */
    getProjectLookupForRoot(rootPath: string): LookupByPath<RushConfigurationProject>;
    /**
     * @beta
     */
    get versionPolicyConfiguration(): VersionPolicyConfiguration;
    /**
     * @beta
     */
    get versionPolicyConfigurationFilePath(): string;
    /**
     * This configuration object contains settings repo maintainers have specified to enable
     * and disable experimental Rush features.
     *
     * @beta
     */
    get experimentsConfiguration(): ExperimentsConfiguration;
    /**
     * @internal
     */
    get _rushPluginsConfiguration(): RushPluginsConfiguration;
    /**
     * Returns the project for which the specified path is underneath that project's folder.
     * If the path is not under any project's folder, returns undefined.
     */
    tryGetProjectForPath(currentFolderPath: string): RushConfigurationProject | undefined;
    private _getVariantConfigFolderPath;
}

/**
 * This represents the configuration of a project that is built by Rush, based on
 * the Rush.json configuration file.
 * @public
 */
export declare class RushConfigurationProject {
    private readonly _packageName;
    private readonly _projectFolder;
    private readonly _projectRelativeFolder;
    private readonly _projectRushConfigFolder;
    private readonly _projectRushTempFolder;
    private readonly _reviewCategory;
    private readonly _packageJson;
    private readonly _packageJsonEditor;
    private readonly _tempProjectName;
    private readonly _unscopedTempProjectName;
    private readonly _cyclicDependencyProjects;
    private readonly _versionPolicyName;
    private readonly _shouldPublish;
    private readonly _skipRushCheck;
    private readonly _publishFolder;
    private readonly _rushConfiguration;
    private readonly _tags;
    private _versionPolicy;
    private _dependencyProjects;
    private _consumingProjects;
    /** @internal */
    constructor(options: IRushConfigurationProjectOptions);
    /**
     * The name of the NPM package.  An error is reported if this name is not
     * identical to packageJson.name.
     *
     * Example: `@scope/MyProject`
     */
    get packageName(): string;
    /**
     * The full path of the folder that contains the project to be built by Rush.
     *
     * Example: `C:\MyRepo\libraries\my-project`
     */
    get projectFolder(): string;
    /**
     * The relative path of the folder that contains the project to be built by Rush.
     *
     * Example: `libraries/my-project`
     */
    get projectRelativeFolder(): string;
    /**
     * The project-specific Rush configuration folder.
     *
     * Example: `C:\MyRepo\libraries\my-project\config\rush`
     */
    get projectRushConfigFolder(): string;
    /**
     * The project-specific Rush temp folder. This folder is used to store Rush-specific temporary files.
     *
     * Example: `C:\MyRepo\libraries\my-project\.rush\temp`
     */
    get projectRushTempFolder(): string;
    /**
     * The Rush configuration for the monorepo that the project belongs to.
     */
    get rushConfiguration(): RushConfiguration;
    /**
     * The review category name, or undefined if no category was assigned.
     * This name must be one of the valid choices listed in RushConfiguration.reviewCategories.
     */
    get reviewCategory(): string | undefined;
    /**
     * A list of local projects that appear as devDependencies for this project, but cannot be
     * locally linked because it would create a cyclic dependency; instead, the last published
     * version will be installed in the Common folder.
     *
     * These are package names that would be found by RushConfiguration.getProjectByName().
     */
    get cyclicDependencyProjects(): Set<string>;
    /**
     * An array of projects within the Rush configuration which directly depend on this package.
     * @deprecated Use `consumingProjectNames` instead, as it has Set semantics, which better reflect the nature
     * of the data.
     */
    get downstreamDependencyProjects(): string[];
    /**
     * An array of projects within the Rush configuration which this project declares as dependencies.
     * @deprecated Use `dependencyProjects` instead, as it has Set semantics, which better reflect the nature
     * of the data.
     */
    get localDependencyProjects(): ReadonlyArray<RushConfigurationProject>;
    /**
     * The set of projects within the Rush configuration which this project declares as dependencies.
     *
     * @remarks
     * Can be used recursively to walk the project dependency graph to find all projects that are directly or indirectly
     * referenced from this project.
     */
    get dependencyProjects(): ReadonlySet<RushConfigurationProject>;
    /**
     * The set of projects within the Rush configuration which declare this project as a dependency.
     * Excludes those that declare this project as a `cyclicDependencyProject`.
     *
     * @remarks
     * This field is the counterpart to `dependencyProjects`, and can be used recursively to walk the project dependency
     * graph to find all projects which will be impacted by changes to this project.
     */
    get consumingProjects(): ReadonlySet<RushConfigurationProject>;
    /**
     * The parsed NPM "package.json" file from projectFolder.
     */
    get packageJson(): IPackageJson;
    /**
     * A useful wrapper around the package.json file for making modifications
     * @beta
     */
    get packageJsonEditor(): PackageJsonEditor;
    /**
     * The unique name for the temporary project that will be generated in the Common folder.
     * For example, if the project name is `@scope/MyProject`, the temporary project name
     * might be `@rush-temp/MyProject-2`.
     *
     * Example: `@rush-temp/MyProject-2`
     */
    get tempProjectName(): string;
    /**
     * The unscoped temporary project name
     *
     * Example: `my-project-2`
     */
    get unscopedTempProjectName(): string;
    /**
     * A flag which indicates whether changes to this project should be published. This controls
     * whether or not the project would show up when running `rush change`, and whether or not it
     * should be published during `rush publish`.
     */
    get shouldPublish(): boolean;
    /**
     * If true, then this project will be ignored by the "rush check" command.
     * The default value is false.
     */
    get skipRushCheck(): boolean;
    /**
     * Name of the version policy used by this project.
     * @beta
     */
    get versionPolicyName(): string | undefined;
    /**
     * The full path of the folder that will get published by Rush.
     *
     * @remarks
     * By default this is the same as the project folder, but a custom folder can be specified
     * using the the "publishFolder" setting in rush.json.
     *
     * Example: `C:\MyRepo\libraries\my-project\temp\publish`
     */
    get publishFolder(): string;
    /**
     * Version policy of the project
     * @beta
     */
    get versionPolicy(): VersionPolicy | undefined;
    /**
     * Indicate whether this project is the main project for the related version policy.
     *
     * False if the project is not for publishing.
     * True if the project is individually versioned or if its lockstep version policy does not specify main project.
     * False if the project is lockstepped and is not the main project for its version policy.
     *
     * @beta
     */
    get isMainProject(): boolean;
    /**
     * The set of tags applied to this project.
     * @beta
     */
    get tags(): ReadonlySet<string>;
}

/**
 * Constants used by the Rush tool.
 * @beta
 *
 * @remarks
 *
 * These are NOT part of the public API surface for rush-lib.
 * The rationale is that we don't want people implementing custom parsers for
 * the Rush config files; instead, they should rely on the official APIs from rush-lib.
 */
export declare class RushConstants {
    /**
     * The filename ("browser-approved-packages.json") for an optional policy configuration file
     * that stores a list of NPM packages that have been approved for usage by Rush projects.
     * This is part of a pair of config files, one for projects that run in a web browser
     * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else
     * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).
     */
    static readonly browserApprovedPackagesFilename: string;
    /**
     * The folder name ("changes") where change files will be stored.
     */
    static readonly changeFilesFolderName: string;
    /**
     * The filename ("nonbrowser-approved-packages.json") for an optional policy configuration file
     * that stores a list of NPM packages that have been approved for usage by Rush projects.
     * This is part of a pair of config files, one for projects that run in a web browser
     * (e.g. whose approval criteria mostly focuses on licensing and code size), and one for everywhere else
     * (e.g. tooling projects whose approval criteria mostly focuses on avoiding node_modules sprawl).
     */
    static readonly nonbrowserApprovedPackagesFilename: string;
    /**
     * The folder name ("common") where Rush's common data will be stored.
     */
    static readonly commonFolderName: string;
    /**
     * The NPM scope ("\@rush-temp") that is used for Rush's temporary projects.
     */
    static readonly rushTempNpmScope: string;
    /**
     * The folder name ("temp") under the common folder, or under the .rush folder in each project's directory where
     * temporary files will be stored.
     * Example: `C:\MyRepo\common\temp`
     */
    static readonly rushTempFolderName: string;
    /**
     * The folder name ("projects") where temporary projects will be stored.
     * Example: `C:\MyRepo\common\temp\projects`
     */
    static readonly rushTempProjectsFolderName: string;
    /**
     * The folder name ("variants") under which named variant configurations for
     * alternate dependency sets may be found.
     * Example: `C:\MyRepo\common\config\rush\variants`
     */
    static readonly rushVariantsFolderName: string;
    /**
     * The filename ("npm-shrinkwrap.json") used to store an installation plan for the NPM package manger.
     */
    static readonly npmShrinkwrapFilename: string;
    /**
     * Number of installation attempts
     */
    static readonly defaultMaxInstallAttempts: number;
    /**
     * The filename ("pnpm-lock.yaml") used to store an installation plan for the PNPM package manger
     * (PNPM version 3.x and later).
     */
    static readonly pnpmV3ShrinkwrapFilename: string;
    /**
     * The filename ("pnpmfile.js") used to add custom configuration to PNPM (PNPM version 1.x and later).
     */
    static readonly pnpmfileV1Filename: string;
    /**
     * The filename (".pnpmfile.cjs") used to add custom configuration to PNPM (PNPM version 6.x and later).
     */
    static readonly pnpmfileV6Filename: string;
    /**
     * The filename ("shrinkwrap.yaml") used to store state for pnpm
     */
    static readonly yarnShrinkwrapFilename: string;
    /**
     * The folder name ("node_modules") where NPM installs its packages.
     */
    static readonly nodeModulesFolderName: string;
    /**
     * The filename ("pinned-versions.json") for an old configuration file that
     * that is no longer supported.
     *
     * @deprecated This feature has been superseded by the "preferredVersions" setting
     * in common-versions.json
     */
    static readonly pinnedVersionsFilename: string;
    /**
     * The filename ("common-versions.json") for an optional configuration file
     * that stores dependency version information that affects all projects in the repo.
     * This configuration file should go in the "common/config/rush" folder.
     */
    static readonly commonVersionsFilename: string;
    /**
     * The filename ("repo-state.json") for a file used by Rush to
     * store the state of various features as they stand in the repo.
     */
    static readonly repoStateFilename: string;
    /**
     * The name of the per-project folder where project-specific Rush files are stored. For example,
     * the package-deps files, which are used by commands to determine if a particular project needs to be rebuilt.
     */
    static readonly projectRushFolderName: string;
    /**
     * Custom command line configuration file, which is used by rush for implementing
     * custom command and options.
     */
    static readonly commandLineFilename: string;
    static readonly versionPoliciesFilename: string;
    /**
     * Experiments configuration file.
     */
    static readonly experimentsFilename: string;
    /**
     * Rush plugins configuration file name.
     */
    static readonly rushPluginsConfigFilename: string;
    /**
     * Rush plugin manifest file name.
     */
    static readonly rushPluginManifestFilename: string;
    /**
     * The artifactory.json configuration file name.
     */
    static readonly artifactoryFilename: string;
    /**
     * Build cache configuration file.
     */
    static readonly buildCacheFilename: string;
    /**
     * Build cache version number, incremented when the logic to create cache entries changes.
     * Changing this ensures that cache entries generated by an old version will no longer register as a cache hit.
     */
    static readonly buildCacheVersion: number;
    /**
     * Per-project configuration filename.
     */
    static readonly rushProjectConfigFilename: string;
    /**
     * The URL ("http://rushjs.io") for the Rush web site.
     */
    static readonly rushWebSiteUrl: string;
    /**
     * The name of the NPM package for the Rush tool ("\@microsoft/rush").
     */
    static readonly rushPackageName: string;
    /**
     * The folder name ("rush-recycler") where Rush moves large folder trees
     * before asynchronously deleting them.
     */
    static readonly rushRecyclerFolderName: string;
    /**
     * The name of the file to drop in project-folder/.rush/temp/ containing a listing of the project's direct
     * and indirect dependencies. This is used to detect if a project's dependencies have changed since the last build.
     */
    static readonly projectShrinkwrapFilename: string;
    /**
     * The value of the "commandKind" property for a bulk command in command-line.json
     */
    static readonly bulkCommandKind: 'bulk';
    /**
     * The value of the "commandKind" property for a global command in command-line.json
     */
    static readonly globalCommandKind: 'global';
    /**
     * The value of the "commandKind" property for a phased command in command-line.json
     */
    static readonly phasedCommandKind: 'phased';
    /**
     * The name of the incremental build command.
     */
    static readonly buildCommandName: string;
    /**
     * The name of the non-incremental build command.
     */
    static readonly rebuildCommandName: string;
    static readonly updateCloudCredentialsCommandName: string;
    /**
     * When a hash generated that contains multiple input segments, this character may be used
     * to separate them to avoid issues like
     * crypto.createHash('sha1').update('a').update('bc').digest('hex') === crypto.createHash('sha1').update('ab').update('c').digest('hex')
     */
    static readonly hashDelimiter: string;
    /**
     * The name of the per-user Rush configuration data folder.
     */
    static readonly rushUserConfigurationFolderName: string;
    /**
     * The name of the project `rush-logs` folder.
     */
    static readonly rushLogsFolderName: string;
    /**
     * The expected prefix for phase names in "common/config/rush/command-line.json"
     */
    static readonly phaseNamePrefix: '_phase:';
}

/**
 * This class provides global folders that are used for rush's internal install locations.
 *
 * @internal
 */
export declare class _RushGlobalFolder {
    private _rushGlobalFolder;
    private _rushNodeSpecificUserFolder;
    /**
     * The global folder where Rush stores temporary files.
     *
     * @remarks
     *
     * Most of the temporary files created by Rush are stored separately for each monorepo working folder,
     * to avoid issues of concurrency and compatibility between tool versions.  However, a small set
     * of files (e.g. installations of the `@microsoft/rush-lib` engine and the package manager) are stored
     * in a global folder to speed up installations.  The default location is `~/.rush` on POSIX-like
     * operating systems or `C:\Users\YourName` on Windows.
     *
     * You can use the {@link EnvironmentVariableNames.RUSH_GLOBAL_FOLDER} environment  variable to specify
     * a different folder path.  This is useful for example if a Windows group policy forbids executing scripts
     * installed in a user's home directory.
     *
     * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
     */
    get path(): string;
    /**
     * The absolute path to Rush's storage in the home directory for the current user and node version.
     * On Windows, it would be something like `C:\Users\YourName\.rush\node-v3.4.5`.
     */
    get nodeSpecificPath(): string;
    constructor();
}

/**
 * Hooks into the lifecycle of the Rush process invocation that plugins may tap into.
 *
 * @beta
 */
export declare class RushLifecycleHooks {
    /**
     * The hook to run before executing any Rush CLI Command.
     */
    initialize: AsyncSeriesHook<IRushCommand>;
    /**
     * The hook to run before executing any global Rush CLI Command (defined in command-line.json).
     */
    runAnyGlobalCustomCommand: AsyncSeriesHook<IGlobalCommand>;
    /**
     * A hook map to allow plugins to hook specific named global commands (defined in command-line.json) before execution.
     */
    runGlobalCustomCommand: HookMap<AsyncSeriesHook<IGlobalCommand>>;
    /**
     * The hook to run before executing any phased Rush CLI Command (defined in command-line.json, or the default "build" or "rebuild").
     */
    runAnyPhasedCommand: AsyncSeriesHook<IPhasedCommand>;
    /**
     * A hook map to allow plugins to hook specific named phased commands (defined in command-line.json) before execution.
     */
    runPhasedCommand: HookMap<AsyncSeriesHook<IPhasedCommand>>;
    /**
     * A hook to allow plugins to hook custom logic to process telemetry data.
     */
    flushTelemetry: AsyncParallelHook<[ReadonlyArray<ITelemetryData>]>;
}

declare class RushPluginsConfiguration {
    private static _jsonSchema;
    private _rushPluginsConfigurationJson;
    private _jsonFilename;
    constructor(jsonFilename: string);
    get configuration(): Readonly<IRushPluginsConfigurationJson>;
}

/**
 * @beta
 */
export declare class RushSession {
    private readonly _options;
    private readonly _cloudBuildCacheProviderFactories;
    readonly hooks: RushLifecycleHooks;
    constructor(options: IRushSessionOptions);
    getLogger(name: string): ILogger;
    get terminalProvider(): ITerminalProvider;
    registerCloudBuildCacheProviderFactory(cacheProviderName: string, factory: CloudBuildCacheProviderFactory): void;
    getCloudBuildCacheProviderFactory(cacheProviderName: string): CloudBuildCacheProviderFactory | undefined;
}

/**
 * Rush per-user configuration data.
 *
 * @beta
 */
export declare class RushUserConfiguration {
    private static _schema;
    /**
     * If provided, store build cache in the specified folder. Must be an absolute path.
     */
    readonly buildCacheFolder: string | undefined;
    private constructor();
    static initializeAsync(): Promise<RushUserConfiguration>;
    static getRushUserFolderPath(): string;
}

declare enum VersionFormatForCommit {
    wildcard = "wildcard",
    original = "original"
}

declare enum VersionFormatForPublish {
    original = "original",
    exact = "exact"
}

/**
 * This is the base class for version policy which controls how versions get bumped.
 * @public
 */
export declare abstract class VersionPolicy {
    private _policyName;
    private _definitionName;
    private _exemptFromRushChange;
    private _includeEmailInChangeFile;
    private _versionFormatForCommit;
    private _versionFormatForPublish;
    /**
     * @internal
     */
    constructor(versionPolicyJson: IVersionPolicyJson);
    /**
     * Loads from version policy json
     *
     * @param versionPolicyJson - version policy Json
     *
     * @internal
     */
    static load(versionPolicyJson: IVersionPolicyJson): VersionPolicy | undefined;
    /**
     * Version policy name
     */
    get policyName(): string;
    /**
     * Version policy definition name
     */
    get definitionName(): VersionPolicyDefinitionName;
    /**
     * Whether it is a lockstepped version policy
     */
    get isLockstepped(): boolean;
    /**
     * Determines if a version policy wants to opt out of changelog files.
     */
    get exemptFromRushChange(): boolean;
    /**
     * Determines if a version policy wants to opt in to including email.
     */
    get includeEmailInChangeFile(): boolean;
    /**
     * Returns an updated package json that satisfies the policy.
     *
     * @param project - package json
     * @param force - force update even when the project version is higher than the policy version.
     */
    abstract ensure(project: IPackageJson, force?: boolean): IPackageJson | undefined;
    /**
     * Bumps version based on the policy
     *
     * @param bumpType - (optional) override bump type
     * @param identifier - (optional) override prerelease Id
     */
    abstract bump(bumpType?: BumpType, identifier?: string): void;
    /**
     * Serialized json for the policy
     *
     * @internal
     */
    abstract get _json(): IVersionPolicyJson;
    /**
     * Validates the specified version and throws if the version does not satisfy the policy.
     *
     * @param versionString - version string
     * @param packageName - package name
     */
    abstract validate(versionString: string, packageName: string): void;
    /**
     * Tells the version policy to modify any dependencies in the target package
     * to values used for publishing.
     */
    setDependenciesBeforePublish(packageName: string, configuration: RushConfiguration): void;
    /**
     * Tells the version policy to modify any dependencies in the target package
     * to values used for checked-in source.
     */
    setDependenciesBeforeCommit(packageName: string, configuration: RushConfiguration): void;
}

/**
 * Use this class to load and save the "common/config/rush/version-policies.json" config file.
 * This config file configures how different groups of projects will be published by Rush,
 * and how their version numbers will be determined.
 * @public
 */
export declare class VersionPolicyConfiguration {
    private static _jsonSchema;
    private _versionPolicies;
    private _jsonFileName;
    /**
     * @internal
     */
    constructor(jsonFileName: string);
    /**
     * Validate the version policy configuration against the rush config
     */
    validate(projectsByName: Map<string, RushConfigurationProject>): void;
    /**
     * Gets the version policy by its name.
     * Throws error if the version policy is not found.
     * @param policyName - Name of the version policy
     */
    getVersionPolicy(policyName: string): VersionPolicy;
    /**
     * Gets all the version policies
     */
    get versionPolicies(): Map<string, VersionPolicy>;
    /**
     * Bumps up versions for the specified version policy or all version policies
     *
     * @param versionPolicyName - version policy name
     * @param bumpType - bump type to override what policy has defined.
     * @param identifier - prerelease identifier to override what policy has defined.
     * @param shouldCommit - should save to disk
     */
    bump(versionPolicyName?: string, bumpType?: BumpType, identifier?: string, shouldCommit?: boolean): void;
    /**
     * Updates the version directly for the specified version policy
     * @param versionPolicyName - version policy name
     * @param newVersion - new version
     */
    update(versionPolicyName: string, newVersion: string, shouldCommit?: boolean): void;
    private _loadFile;
    private _saveFile;
}

/**
 * Version policy base type names
 * @public
 */
export declare enum VersionPolicyDefinitionName {
    'lockStepVersion' = 0,
    'individualVersion' = 1
}

/**
 * Options that are only used when the yarn package manager is selected.
 *
 * @remarks
 * It is valid to define these options in rush.json even if the yarn package manager
 * is not being used.
 *
 * @public
 */
export declare class YarnOptionsConfiguration extends PackageManagerOptionsConfigurationBase {
    /**
     * If true, then Rush will add the "--ignore-engines" option when invoking Yarn.
     * This allows "rush install" to succeed if there are dependencies with engines defined in
     * package.json which do not match the current environment.
     *
     * The default value is false.
     */
    readonly ignoreEngines: boolean;
    /** @internal */
    constructor(json: _IYarnOptionsJson);
}

export { }
