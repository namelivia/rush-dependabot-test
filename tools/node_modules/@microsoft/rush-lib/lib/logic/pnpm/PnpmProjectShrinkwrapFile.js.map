{"version":3,"file":"PnpmProjectShrinkwrapFile.js","sourceRoot":"","sources":["../../../src/logic/pnpm/PnpmProjectShrinkwrapFile.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,+CAAiC;AACjC,oEAAuE;AAEvE,iFAA8E;AAG9E,oDAAiD;AAEjD;;GAEG;AACH,MAAa,yBAA0B,SAAQ,qDAAyB;IACtE;;;OAGG;IACI,KAAK,CAAC,4BAA4B;QACvC,MAAM,oBAAoB,GAAoC,IAAI,CAAC,4BAA4B,EAAE,CAAC;QAElG,OAAO,oBAAoB,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,mBAAmB,EAAE,CAAC;IAClG,CAAC;IAEM,UAAU,CAAC,eAA0C;QAC1D,IACE,CAAC,eAAe,CAAC,cAAc,CAAC,qBAAqB;YACrD,CAAC,eAAe,CAAC,cAAc,CAAC,2BAA2B,CAAC,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,EACzF;YACA,6CAA6C;YAC7C,OAAO,IAAI,CAAC;SACb;QAED,MAAM,QAAQ,GAAoC,eAAe,CAAC,4BAA4B,EAAE,CAAC;QACjG,MAAM,OAAO,GAAoC,IAAI,CAAC,4BAA4B,EAAE,CAAC;QAErF,IAAI,CAAC,OAAO,IAAI,CAAC,QAAQ,EAAE;YACzB,sCAAsC;YACtC,OAAO,CAAC,CAAC,CAAC,OAAO,IAAI,QAAQ,CAAC,CAAC;SAChC;QAED,IAAI,OAAO,CAAC,IAAI,KAAK,QAAQ,CAAC,IAAI,EAAE;YAClC,2BAA2B;YAC3B,OAAO,IAAI,CAAC;SACb;QAED,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,OAAO,EAAE;YAClC,IAAI,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,KAAK,EAAE;gBAC/B,4CAA4C;gBAC5C,OAAO,IAAI,CAAC;aACb;SACF;QAED,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;OAEG;IACO,4BAA4B;QACpC,MAAM,oBAAoB,GAAoC,IAAI,CAAC,cAAc,CAAC,qBAAqB;YACrG,CAAC,CAAC,IAAI,CAAC,qCAAqC,EAAE;YAC9C,CAAC,CAAC,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAE9C,OAAO,oBAAoB,CAAC;IAC9B,CAAC;IAES,qCAAqC;QAC7C,uFAAuF;QACvF,MAAM,WAAW,GAAW,IAAI,CAAC,cAAc,CAAC,oBAAoB,CAClE,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC,gBAAgB,EAC/C,IAAI,CAAC,OAAO,CAAC,aAAa,CAC3B,CAAC;QAEF,MAAM,oBAAoB,GACxB,IAAI,CAAC,cAAc,CAAC,uBAAuB,CAAC,WAAW,CAAC,CAAC;QAE3D,OAAO,oBAAoB,CAAC;IAC9B,CAAC;IAES,kCAAkC;QAC1C,MAAM,wBAAwB,GAAuB,IAAI,CAAC,cAAc,CAAC,2BAA2B,CAClG,IAAI,CAAC,OAAO,CAAC,eAAe,CAC7B,CAAC;QACF,IAAI,CAAC,wBAAwB,EAAE;YAC7B,MAAM,IAAI,KAAK,CAAC,+CAA+C,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE,CAAC,CAAC;SAChG;QACD,MAAM,qBAAqB,GACzB,IAAI,CAAC,cAAc,CAAC,8CAA8C,CAAC,wBAAwB,CAAE,CAAC;QAEhG,MAAM,eAAe,GAAuB;YAC1C,GAAG,MAAM,CAAC,OAAO,CAAC,qBAAqB,CAAC,YAAY,IAAI,EAAE,CAAC;YAC3D,GAAG,MAAM,CAAC,OAAO,CAAC,qBAAqB,CAAC,oBAAoB,IAAI,EAAE,CAAC;SACpE,CAAC;QAEF,MAAM,oBAAoB,GAAwB,IAAI,GAAG,EAAE,CAAC;QAC5D,KAAK,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,eAAe,EAAE;YAC7C,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,6BAAa,CAAC,gBAAgB,GAAG,CAAC,GAAG,CAAC,EAAE;gBAC1D,2FAA2F;gBAC3F,kBAAkB;gBAClB,IAAI,CAAC,uBAAuB,CAAC,oBAAoB,EAAE,IAAI,EAAE,OAAO,EAAE,qBAAqB,CAAC,CAAC;aAC1F;SACF;QAED,kGAAkG;QAClG,yDAAyD;QACzD,IAAI,CAAC,8BAA8B,CAAC,oBAAoB,EAAE,qBAAqB,CAAC,CAAC;QAEjF,OAAO,oBAAoB,CAAC;IAC9B,CAAC;IAEO,uBAAuB,CAC7B,oBAAyC,EACzC,IAAY,EACZ,OAAe,EACf,qBAAoD,EACpD,gCAAyC,IAAI;;QAE7C,MAAM,SAAS,GAAW,GAAG,IAAI,IAAI,OAAO,EAAE,CAAC;QAC/C,IAAI,oBAAoB,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;YACvC,oEAAoE;YACpE,OAAO;SACR;QAED,MAAM,eAAe,GAA8C,IAAI,CAAC,cAAc,CAAC,kBAAkB,CACvG,IAAI,EACJ,OAAO,CACR,CAAC;QAEF,IAAI,CAAC,eAAe,EAAE;YACpB,IAAI,6BAA6B,EAAE;gBACjC,MAAM,IAAI,iCAAa,CAAC,6BAA6B,IAAI,iBAAiB,OAAO,iBAAiB,CAAC,CAAC;aACrG;YACD,OAAO;SACR;QAED,IAAI,SAAS,GAAuB,MAAA,eAAe,CAAC,UAAU,0CAAE,SAAS,CAAC;QAC1E,IAAI,CAAC,SAAS,EAAE;YACd,qGAAqG;YACrG,oGAAoG;YACpG,MAAM;YACN,2EAA2E;YAC3E,QAAQ;YACR,gBAAgB;YAChB,iHAAiH;YACjH,MAAM,YAAY,GAAW,MAAM;iBAChC,UAAU,CAAC,QAAQ,CAAC;iBACpB,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,CAAC;iBACvC,MAAM,CAAC,KAAK,CAAC,CAAC;YACjB,SAAS,GAAG,GAAG,IAAI,IAAI,OAAO,IAAI,YAAY,GAAG,CAAC;SACnD;QAED,6BAA6B;QAC7B,oBAAoB,CAAC,GAAG,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;QAE/C,yCAAyC;QACzC,KAAK,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,eAAe,CAAC,YAAY,IAAI,EAAE,CAAC,EAAE;YAChF,IAAI,CAAC,uBAAuB,CAAC,oBAAoB,EAAE,IAAI,EAAE,OAAO,EAAE,eAAe,CAAC,CAAC;SACpF;QAED,yFAAyF;QACzF,KAAK,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,eAAe,CAAC,oBAAoB,IAAI,EAAE,CAAC,EAAE;YACxF,IAAI,CAAC,uBAAuB,CAC1B,oBAAoB,EACpB,IAAI,EACJ,OAAO,EACP,eAAe;YACf,mCAAmC,CAAC,KAAK,CAC1C,CAAC;SACH;QAED,wGAAwG;QACxG,0GAA0G;QAC1G,mGAAmG;QACnG,mBAAmB;QACnB,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,qBAAqB,EAAE;YAC9C,IAAI,CAAC,8BAA8B,CAAC,oBAAoB,EAAE,eAAe,EAAE,qBAAqB,CAAC,CAAC;SACnG;IACH,CAAC;IAEO,8BAA8B,CACpC,oBAAyC,EACzC,eAA8C,EAC9C,qBAAqD;;QAErD,KAAK,MAAM,kBAAkB,IAAI,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,gBAAgB,IAAI,EAAE,CAAC,EAAE;YACpF,qEAAqE;YACrE,IAAI,kBAAkB,CAAC,OAAO,CAAC,6BAAa,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC,EAAE;gBACrE,SAAS;aACV;YAED,+EAA+E;YAC/E,6EAA6E;YAC7E,6EAA6E;YAC7E,+EAA+E;YAC/E,wEAAwE;YACxE,IACE,CAAA,MAAA,eAAe,CAAC,YAAY,0CAAE,cAAc,CAAC,kBAAkB,CAAC;iBAChE,MAAA,qBAAqB,aAArB,qBAAqB,uBAArB,qBAAqB,CAAE,YAAY,0CAAE,cAAc,CAAC,kBAAkB,CAAC,CAAA;iBACvE,MAAA,qBAAqB,aAArB,qBAAqB,uBAArB,qBAAqB,CAAE,gBAAgB,0CAAE,cAAc,CAAC,kBAAkB,CAAC,CAAA,EAC3E;gBACA,SAAS;aACV;YAED,iFAAiF;YACjF,mFAAmF;YACnF,mBAAmB;YACnB,MAAM,2BAA2B,GAC/B,IAAI,CAAC,cAAc,CAAC,4BAA4B,CAAC,kBAAkB,CAAC,CAAC;YAEvE,IAAI,2BAA2B,EAAE;gBAC/B,IAAI,CAAC,uBAAuB,CAC1B,oBAAoB,EACpB,kBAAkB,EAClB,IAAI,CAAC,cAAc,CAAC,wBAAwB,CAAC,kBAAkB,CAAE,EACjE,eAAe,CAChB,CAAC;aACH;SACF;IACH,CAAC;IAED;;OAEG;IACO,KAAK,CAAC,SAAS,CAAC,oBAAyC;QACjE,MAAM,IAAI,GAAoC,EAAE,CAAC;QACjD,MAAM,IAAI,GAAa,KAAK,CAAC,IAAI,CAAC,oBAAoB,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;QACtE,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;YACtB,IAAI,CAAC,GAAG,CAAC,GAAG,oBAAoB,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC;SAC5C;QACD,MAAM,4BAAQ,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,yBAAyB,EAAE,EAAE,kBAAkB,EAAE,IAAI,EAAE,CAAC,CAAC;IAC/F,CAAC;IAED;;OAEG;IACH,IAAc,cAAc;QAC1B,OAAO,KAAK,CAAC,cAAoC,CAAC;IACpD,CAAC;CACF;AAlOD,8DAkOC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as crypto from 'crypto';\nimport { InternalError, JsonFile } from '@rushstack/node-core-library';\n\nimport { BaseProjectShrinkwrapFile } from '../base/BaseProjectShrinkwrapFile';\nimport { PnpmShrinkwrapFile, IPnpmShrinkwrapDependencyYaml } from './PnpmShrinkwrapFile';\nimport { DependencySpecifier } from '../DependencySpecifier';\nimport { RushConstants } from '../RushConstants';\n\n/**\n *\n */\nexport class PnpmProjectShrinkwrapFile extends BaseProjectShrinkwrapFile {\n  /**\n   * Generate and write the project shrinkwrap file to <project>/.rush/temp/shrinkwrap-deps.json.\n   * @returns True if the project shrinkwrap was created or updated, false otherwise.\n   */\n  public async updateProjectShrinkwrapAsync(): Promise<void> {\n    const projectShrinkwrapMap: Map<string, string> | undefined = this.generateProjectShrinkwrapMap();\n\n    return projectShrinkwrapMap ? this.saveAsync(projectShrinkwrapMap) : this.deleteIfExistsAsync();\n  }\n\n  public hasChanges(otherShrinkwrap: PnpmProjectShrinkwrapFile): boolean {\n    if (\n      !otherShrinkwrap.shrinkwrapFile.isWorkspaceCompatible &&\n      !otherShrinkwrap.shrinkwrapFile.getTempProjectDependencyKey(this.project.tempProjectName)\n    ) {\n      // The project is new to the shrinkwrap file.\n      return true;\n    }\n\n    const otherMap: Map<string, string> | undefined = otherShrinkwrap.generateProjectShrinkwrapMap();\n    const thisMap: Map<string, string> | undefined = this.generateProjectShrinkwrapMap();\n\n    if (!thisMap || !otherMap) {\n      // Handle one or both being undefined.\n      return !!(thisMap || otherMap);\n    }\n\n    if (thisMap.size !== otherMap.size) {\n      // Entries added or removed\n      return true;\n    }\n\n    for (const [key, value] of thisMap) {\n      if (otherMap.get(key) !== value) {\n        // A dependency changed or was added/removed\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Generate the project shrinkwrap file content\n   */\n  protected generateProjectShrinkwrapMap(): Map<string, string> | undefined {\n    const projectShrinkwrapMap: Map<string, string> | undefined = this.shrinkwrapFile.isWorkspaceCompatible\n      ? this.generateWorkspaceProjectShrinkwrapMap()\n      : this.generateLegacyProjectShrinkwrapMap();\n\n    return projectShrinkwrapMap;\n  }\n\n  protected generateWorkspaceProjectShrinkwrapMap(): Map<string, string> | undefined {\n    // Obtain the workspace importer from the shrinkwrap, which lists resolved dependencies\n    const importerKey: string = this.shrinkwrapFile.getImporterKeyByPath(\n      this.project.rushConfiguration.commonTempFolder,\n      this.project.projectFolder\n    );\n\n    const projectShrinkwrapMap: Map<string, string> | undefined =\n      this.shrinkwrapFile.getIntegrityForImporter(importerKey);\n\n    return projectShrinkwrapMap;\n  }\n\n  protected generateLegacyProjectShrinkwrapMap(): Map<string, string> {\n    const tempProjectDependencyKey: string | undefined = this.shrinkwrapFile.getTempProjectDependencyKey(\n      this.project.tempProjectName\n    );\n    if (!tempProjectDependencyKey) {\n      throw new Error(`Cannot get dependency key for temp project: ${this.project.tempProjectName}`);\n    }\n    const parentShrinkwrapEntry: IPnpmShrinkwrapDependencyYaml =\n      this.shrinkwrapFile.getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey)!;\n\n    const allDependencies: [string, string][] = [\n      ...Object.entries(parentShrinkwrapEntry.dependencies || {}),\n      ...Object.entries(parentShrinkwrapEntry.optionalDependencies || {})\n    ];\n\n    const projectShrinkwrapMap: Map<string, string> = new Map();\n    for (const [name, version] of allDependencies) {\n      if (name.indexOf(`${RushConstants.rushTempNpmScope}/`) < 0) {\n        // Only select the shrinkwrap dependencies that are non-local since we already handle local\n        // project changes\n        this._addDependencyRecursive(projectShrinkwrapMap, name, version, parentShrinkwrapEntry);\n      }\n    }\n\n    // Since peer dependencies within on external packages may be hoisted up to the top-level package,\n    // we need to resolve and add these dependencies directly\n    this._resolveAndAddPeerDependencies(projectShrinkwrapMap, parentShrinkwrapEntry);\n\n    return projectShrinkwrapMap;\n  }\n\n  private _addDependencyRecursive(\n    projectShrinkwrapMap: Map<string, string>,\n    name: string,\n    version: string,\n    parentShrinkwrapEntry: IPnpmShrinkwrapDependencyYaml,\n    throwIfShrinkwrapEntryMissing: boolean = true\n  ): void {\n    const specifier: string = `${name}@${version}`;\n    if (projectShrinkwrapMap.has(specifier)) {\n      // getShrinkwrapEntry is idempotent with respect to name and version\n      return;\n    }\n\n    const shrinkwrapEntry: IPnpmShrinkwrapDependencyYaml | undefined = this.shrinkwrapFile.getShrinkwrapEntry(\n      name,\n      version\n    );\n\n    if (!shrinkwrapEntry) {\n      if (throwIfShrinkwrapEntryMissing) {\n        throw new InternalError(`Unable to find dependency ${name} with version ${version} in shrinkwrap.`);\n      }\n      return;\n    }\n\n    let integrity: string | undefined = shrinkwrapEntry.resolution?.integrity;\n    if (!integrity) {\n      // git dependency specifiers do not have an integrity entry. Instead, they specify the tarball field.\n      // So instead, we will hash the contents of the dependency entry and use that as the integrity hash.\n      // Ex:\n      // github.com/chfritz/node-xmlrpc/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38:\n      //   ...\n      //   resolution:\n      //     tarball: 'https://codeload.github.com/chfritz/node-xmlrpc/tar.gz/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38'\n      const sha256Digest: string = crypto\n        .createHash('sha256')\n        .update(JSON.stringify(shrinkwrapEntry))\n        .digest('hex');\n      integrity = `${name}@${version}:${sha256Digest}:`;\n    }\n\n    // Add the current dependency\n    projectShrinkwrapMap.set(specifier, integrity);\n\n    // Add the dependencies of the dependency\n    for (const [name, version] of Object.entries(shrinkwrapEntry.dependencies || {})) {\n      this._addDependencyRecursive(projectShrinkwrapMap, name, version, shrinkwrapEntry);\n    }\n\n    // Add the optional dependencies of the dependency, and don't blow up if they don't exist\n    for (const [name, version] of Object.entries(shrinkwrapEntry.optionalDependencies || {})) {\n      this._addDependencyRecursive(\n        projectShrinkwrapMap,\n        name,\n        version,\n        shrinkwrapEntry,\n        /* throwIfShrinkwrapEntryMissing */ false\n      );\n    }\n\n    // When using workspaces, hoisting of peer dependencies to a singular top-level project is not possible.\n    // Therefore, all packages that are consumed should be specified in the dependency tree. Given this, there\n    // is no need to look for peer dependencies, since it is simply a constraint to be validated by the\n    // package manager.\n    if (!this.shrinkwrapFile.isWorkspaceCompatible) {\n      this._resolveAndAddPeerDependencies(projectShrinkwrapMap, shrinkwrapEntry, parentShrinkwrapEntry);\n    }\n  }\n\n  private _resolveAndAddPeerDependencies(\n    projectShrinkwrapMap: Map<string, string>,\n    shrinkwrapEntry: IPnpmShrinkwrapDependencyYaml,\n    parentShrinkwrapEntry?: IPnpmShrinkwrapDependencyYaml\n  ): void {\n    for (const peerDependencyName of Object.keys(shrinkwrapEntry.peerDependencies || {})) {\n      // Skip peer dependency resolution of local package peer dependencies\n      if (peerDependencyName.indexOf(RushConstants.rushTempNpmScope) !== -1) {\n        continue;\n      }\n\n      // Check to see if the peer dependency is satisfied with the current shrinkwrap\n      // entry. If not, check the parent shrinkwrap entry. Finally, if neither have\n      // the specified dependency, check that the parent mentions the dependency in\n      // it's own peer dependencies. If it is, we can rely on the package manager and\n      // make the assumption that we've already found it further up the stack.\n      if (\n        shrinkwrapEntry.dependencies?.hasOwnProperty(peerDependencyName) ||\n        parentShrinkwrapEntry?.dependencies?.hasOwnProperty(peerDependencyName) ||\n        parentShrinkwrapEntry?.peerDependencies?.hasOwnProperty(peerDependencyName)\n      ) {\n        continue;\n      }\n\n      // As a last attempt, check if it's been hoisted up as a top-level dependency. If\n      // we can't find it, we can assume that it's already been provided somewhere up the\n      // dependency tree.\n      const topLevelDependencySpecifier: DependencySpecifier | undefined =\n        this.shrinkwrapFile.getTopLevelDependencyVersion(peerDependencyName);\n\n      if (topLevelDependencySpecifier) {\n        this._addDependencyRecursive(\n          projectShrinkwrapMap,\n          peerDependencyName,\n          this.shrinkwrapFile.getTopLevelDependencyKey(peerDependencyName)!,\n          shrinkwrapEntry\n        );\n      }\n    }\n  }\n\n  /**\n   * Save the current state of the object to project/.rush/temp/shrinkwrap-deps.json\n   */\n  protected async saveAsync(projectShrinkwrapMap: Map<string, string>): Promise<void> {\n    const file: { [specifier: string]: string } = {};\n    const keys: string[] = Array.from(projectShrinkwrapMap.keys()).sort();\n    for (const key of keys) {\n      file[key] = projectShrinkwrapMap.get(key)!;\n    }\n    await JsonFile.saveAsync(file, this.projectShrinkwrapFilePath, { ensureFolderExists: true });\n  }\n\n  /**\n   * @override\n   */\n  protected get shrinkwrapFile(): PnpmShrinkwrapFile {\n    return super.shrinkwrapFile as PnpmShrinkwrapFile;\n  }\n}\n"]}