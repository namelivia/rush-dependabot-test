{"version":3,"file":"RushProjectConfiguration.js","sourceRoot":"","sources":["../../src/api/RushProjectConfiguration.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport { AlreadyReportedError, ITerminal, Path } from '@rushstack/node-core-library';\nimport { ConfigurationFile, InheritanceType } from '@rushstack/heft-config-file';\nimport { RigConfig } from '@rushstack/rig-package';\n\nimport { RushConfigurationProject } from './RushConfigurationProject';\nimport { RushConstants } from '../logic/RushConstants';\nimport type { IPhase } from './CommandLineConfiguration';\nimport { OverlappingPathAnalyzer } from '../utilities/OverlappingPathAnalyzer';\n\n/**\n * Describes the file structure for the \"<project root>/config/rush-project.json\" config file.\n */\nexport interface IRushProjectJson {\n  /**\n   * The incremental analyzer can skip Rush commands for projects whose input files have\n   * not changed since the last build. Normally, every Git-tracked file under the project\n   * folder is assumed to be an input. Set incrementalBuildIgnoredGlobs to ignore specific\n   * files, specified as globs relative to the project folder. The list of file globs will\n   * be interpreted the same way your .gitignore file is.\n   */\n  incrementalBuildIgnoredGlobs?: string[];\n\n  /**\n   * Disable caching for this project. The project will never be restored from cache.\n   * This may be useful if this project affects state outside of its folder.\n   *\n   * This option is only used when the build cache is enabled for the repo. You can set\n   * disableBuildCacheForProject=true to disable caching for a specific project. This is a useful workaround\n   * if that project's build scripts violate the assumptions of the cache, for example by writing\n   * files outside the project folder. Where possible, a better solution is to improve the build scripts\n   * to be compatible with caching.\n   */\n  disableBuildCacheForProject?: boolean;\n\n  operationSettings?: IOperationSettings[];\n}\n\nexport interface IOperationSettings {\n  /**\n   * The name of the operation. This should be a key in the `package.json`'s `scripts` object.\n   */\n  operationName: string;\n\n  /**\n   * Specify the folders where this operation writes its output files. If enabled, the Rush build\n   * cache will restore these folders from the cache. The strings are folder names under the project\n   * root folder.\n   *\n   * These folders should not be tracked by Git. They must not contain symlinks.\n   */\n  outputFolderNames?: string[];\n\n  /**\n   * Disable caching for this operation. The operation will never be restored from cache.\n   * This may be useful if this operation affects state outside of its folder.\n   *\n   * This option is only used when the build cache is enabled for the repo. You can set\n   * disableBuildCacheForOperation=true to disable caching for a specific project operation.\n   * This is a useful workaround if that project's build scripts violate the assumptions of the cache,\n   * for example by writing files outside the project folder. Where possible, a better solution is to improve\n   * the build scripts to be compatible with caching.\n   */\n  disableBuildCacheForOperation?: boolean;\n}\n\ninterface IOldRushProjectJson {\n  projectOutputFolderNames?: unknown;\n  phaseOptions?: unknown;\n  buildCacheOptions?: unknown;\n}\n\nexport const RUSH_PROJECT_CONFIGURATION_FILE: ConfigurationFile<IRushProjectJson> =\n  new ConfigurationFile<IRushProjectJson>({\n    projectRelativeFilePath: `config/${RushConstants.rushProjectConfigFilename}`,\n    jsonSchemaPath: path.resolve(__dirname, '..', 'schemas', 'rush-project.schema.json'),\n    propertyInheritance: {\n      operationSettings: {\n        inheritanceType: InheritanceType.custom,\n        inheritanceFunction: (\n          child: IOperationSettings[] | undefined,\n          parent: IOperationSettings[] | undefined\n        ) => {\n          if (!child) {\n            return parent;\n          } else if (!parent) {\n            return child;\n          } else {\n            // Merge the outputFolderNames arrays\n            const resultOperationSettingsByOperationName: Map<string, IOperationSettings> = new Map();\n            for (const parentOperationSettings of parent) {\n              resultOperationSettingsByOperationName.set(\n                parentOperationSettings.operationName,\n                parentOperationSettings\n              );\n            }\n\n            const childEncounteredOperationNames: Set<string> = new Set();\n            for (const childOperationSettings of child) {\n              const operationName: string = childOperationSettings.operationName;\n              if (childEncounteredOperationNames.has(operationName)) {\n                // If the operation settings already exist, but didn't come from the parent, then\n                // it shows up multiple times in the child.\n                const childSourceFilePath: string =\n                  RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(child)!;\n                throw new Error(\n                  `The operation \"${operationName}\" occurs multiple times in the \"operationSettings\" array ` +\n                    `in \"${childSourceFilePath}\".`\n                );\n              }\n\n              childEncounteredOperationNames.add(operationName);\n\n              let mergedOperationSettings: IOperationSettings | undefined =\n                resultOperationSettingsByOperationName.get(operationName);\n              if (mergedOperationSettings) {\n                // The parent operation settings object already exists, so append to the outputFolderNames\n                const outputFolderNames: string[] | undefined =\n                  mergedOperationSettings.outputFolderNames && childOperationSettings.outputFolderNames\n                    ? [\n                        ...mergedOperationSettings.outputFolderNames,\n                        ...childOperationSettings.outputFolderNames\n                      ]\n                    : mergedOperationSettings.outputFolderNames || childOperationSettings.outputFolderNames;\n\n                mergedOperationSettings = {\n                  ...mergedOperationSettings,\n                  ...childOperationSettings,\n                  outputFolderNames\n                };\n                resultOperationSettingsByOperationName.set(operationName, mergedOperationSettings);\n              } else {\n                resultOperationSettingsByOperationName.set(operationName, childOperationSettings);\n              }\n            }\n\n            return Array.from(resultOperationSettingsByOperationName.values());\n          }\n        }\n      },\n      incrementalBuildIgnoredGlobs: {\n        inheritanceType: InheritanceType.replace\n      }\n    }\n  });\n\nconst OLD_RUSH_PROJECT_CONFIGURATION_FILE: ConfigurationFile<IOldRushProjectJson> =\n  new ConfigurationFile<IOldRushProjectJson>({\n    projectRelativeFilePath: RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath,\n    jsonSchemaPath: path.resolve(__dirname, '..', 'schemas', 'anything.schema.json')\n  });\n\n/**\n * Use this class to load the \"config/rush-project.json\" config file.\n *\n * This file provides project-specific configuration options.\n * @public\n */\nexport class RushProjectConfiguration {\n  private static readonly _configCache: Map<RushConfigurationProject, RushProjectConfiguration | false> =\n    new Map();\n\n  public readonly project: RushConfigurationProject;\n\n  /**\n   * {@inheritdoc IRushProjectJson.incrementalBuildIgnoredGlobs}\n   */\n  public readonly incrementalBuildIgnoredGlobs: ReadonlyArray<string>;\n\n  /**\n   * {@inheritdoc IRushProjectJson.disableBuildCacheForProject}\n   */\n  public readonly disableBuildCacheForProject: boolean;\n\n  public readonly operationSettingsByOperationName: ReadonlyMap<string, Readonly<IOperationSettings>>;\n\n  private readonly _validationCache: WeakSet<object> = new WeakSet();\n\n  private constructor(\n    project: RushConfigurationProject,\n    rushProjectJson: IRushProjectJson,\n    operationSettingsByOperationName: ReadonlyMap<string, IOperationSettings>\n  ) {\n    this.project = project;\n    this.incrementalBuildIgnoredGlobs = rushProjectJson.incrementalBuildIgnoredGlobs || [];\n    this.disableBuildCacheForProject = rushProjectJson.disableBuildCacheForProject || false;\n    this.operationSettingsByOperationName = operationSettingsByOperationName;\n  }\n\n  /**\n   * Validates that the requested phases are compatible.\n   * Deferral of this logic to its own method means that Rush no longer eagerly validates\n   * all defined commands in command-line.json. As such, while validation will be run for a given\n   * command upon invoking that command, defining overlapping phases in \"rush custom-command\"\n   * that are not used by \"rush build\" will not cause \"rush build\" to exit with an error.\n   */\n  public validatePhaseConfiguration(phases: Iterable<IPhase>, terminal: ITerminal): void {\n    // Don't repeatedly validate the same set of phases for the same project.\n    if (this._validationCache.has(phases)) {\n      return;\n    }\n\n    const overlappingPathAnalyzer: OverlappingPathAnalyzer<string> = new OverlappingPathAnalyzer<string>();\n\n    const { operationSettingsByOperationName, project } = this;\n\n    let hasErrors: boolean = false;\n\n    for (const phase of phases) {\n      const operationName: string = phase.name;\n      const operationSettings: IOperationSettings | undefined =\n        operationSettingsByOperationName.get(operationName);\n      if (operationSettings) {\n        if (operationSettings.outputFolderNames) {\n          for (const outputFolderName of operationSettings.outputFolderNames) {\n            const overlappingOperationNames: string[] | undefined =\n              overlappingPathAnalyzer.addPathAndGetFirstEncounteredLabels(outputFolderName, operationName);\n            if (overlappingOperationNames) {\n              const overlapsWithOwnOperation: boolean = overlappingOperationNames?.includes(operationName);\n              if (overlapsWithOwnOperation) {\n                terminal.writeErrorLine(\n                  `The project \"${project.packageName}\" has a ` +\n                    `\"${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}\" configuration that defines an ` +\n                    `operation with overlapping paths in the \"outputFolderNames\" list. The operation is ` +\n                    `\"${operationName}\", and the conflicting path is \"${outputFolderName}\".`\n                );\n              } else {\n                terminal.writeErrorLine(\n                  `The project \"${project.packageName}\" has a ` +\n                    `\"${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}\" configuration that defines ` +\n                    'two operations in the same command whose \"outputFolderNames\" would overlap. ' +\n                    'Operations outputs in the same command must be disjoint so that they can be independently cached.' +\n                    `\\n\\n` +\n                    `The \"${outputFolderName}\" path overlaps between these operations: ` +\n                    overlappingOperationNames.map((operationName) => `\"${operationName}\"`).join(', ')\n                );\n              }\n\n              hasErrors = true;\n            }\n          }\n        }\n      }\n    }\n\n    this._validationCache.add(phases);\n\n    if (hasErrors) {\n      throw new AlreadyReportedError();\n    }\n  }\n\n  /**\n   * Loads the rush-project.json data for the specified project.\n   */\n  public static async tryLoadForProjectAsync(\n    project: RushConfigurationProject,\n    terminal: ITerminal\n  ): Promise<RushProjectConfiguration | undefined> {\n    // false is a signal that the project config does not exist\n    const cacheEntry: RushProjectConfiguration | false | undefined =\n      RushProjectConfiguration._configCache.get(project);\n    if (cacheEntry !== undefined) {\n      return cacheEntry || undefined;\n    }\n\n    const rushProjectJson: IRushProjectJson | undefined = await this._tryLoadJsonForProjectAsync(\n      project,\n      terminal\n    );\n\n    if (rushProjectJson) {\n      const result: RushProjectConfiguration = RushProjectConfiguration._getRushProjectConfiguration(\n        project,\n        rushProjectJson,\n        terminal\n      );\n      RushProjectConfiguration._configCache.set(project, result);\n      return result;\n    } else {\n      RushProjectConfiguration._configCache.set(project, false);\n      return undefined;\n    }\n  }\n\n  /**\n   * Load only the `incrementalBuildIgnoredGlobs` property from the rush-project.json file, skipping\n   * validation of other parts of the config file.\n   *\n   * @remarks\n   * This function exists to allow the ProjectChangeAnalyzer to load just the ignore globs without\n   * having to validate the rest of the `rush-project.json` file against the repo's command-line configuration.\n   */\n  public static async tryLoadIgnoreGlobsForProjectAsync(\n    project: RushConfigurationProject,\n    terminal: ITerminal\n  ): Promise<ReadonlyArray<string> | undefined> {\n    const rushProjectJson: IRushProjectJson | undefined = await this._tryLoadJsonForProjectAsync(\n      project,\n      terminal\n    );\n\n    return rushProjectJson?.incrementalBuildIgnoredGlobs;\n  }\n\n  private static async _tryLoadJsonForProjectAsync(\n    project: RushConfigurationProject,\n    terminal: ITerminal\n  ): Promise<IRushProjectJson | undefined> {\n    const rigConfig: RigConfig = await RigConfig.loadForProjectFolderAsync({\n      projectFolderPath: project.projectFolder\n    });\n\n    try {\n      return await RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(\n        terminal,\n        project.projectFolder,\n        rigConfig\n      );\n    } catch (e) {\n      // Detect if the project is using the old rush-project.json schema\n      let oldRushProjectJson: IOldRushProjectJson | undefined;\n      try {\n        oldRushProjectJson =\n          await OLD_RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(\n            terminal,\n            project.projectFolder,\n            rigConfig\n          );\n      } catch (e) {\n        // Ignore\n      }\n\n      if (\n        oldRushProjectJson?.projectOutputFolderNames ||\n        oldRushProjectJson?.phaseOptions ||\n        oldRushProjectJson?.buildCacheOptions\n      ) {\n        throw new Error(\n          `The ${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file appears to be ` +\n            'in an outdated format. Please see the UPGRADING.md notes for details. ' +\n            'Quick link: https://rushjs.io/link/upgrading'\n        );\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  private static _getRushProjectConfiguration(\n    project: RushConfigurationProject,\n    rushProjectJson: IRushProjectJson,\n    terminal: ITerminal\n  ): RushProjectConfiguration {\n    const operationSettingsByOperationName: Map<string, IOperationSettings> = new Map<\n      string,\n      IOperationSettings\n    >();\n\n    let hasErrors: boolean = false;\n\n    if (rushProjectJson.operationSettings) {\n      for (const operationSettings of rushProjectJson.operationSettings) {\n        const operationName: string = operationSettings.operationName;\n        const existingOperationSettings: IOperationSettings | undefined =\n          operationSettingsByOperationName.get(operationName);\n        if (existingOperationSettings) {\n          const existingOperationSettingsJsonPath: string | undefined =\n            RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(existingOperationSettings);\n          const operationSettingsJsonPath: string | undefined =\n            RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(operationSettings);\n          hasErrors = true;\n          let errorMessage: string =\n            `The operation \"${operationName}\" appears multiple times in the \"${project.packageName}\" project's ` +\n            `${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file's ` +\n            'operationSettings property.';\n          if (existingOperationSettingsJsonPath && operationSettingsJsonPath) {\n            if (existingOperationSettingsJsonPath !== operationSettingsJsonPath) {\n              errorMessage +=\n                ` It first appears in \"${existingOperationSettingsJsonPath}\" and again ` +\n                `in \"${operationSettingsJsonPath}\".`;\n            } else if (\n              !Path.convertToSlashes(existingOperationSettingsJsonPath).startsWith(\n                Path.convertToSlashes(project.projectFolder)\n              )\n            ) {\n              errorMessage += ` It appears multiple times in \"${operationSettingsJsonPath}\".`;\n            }\n          }\n\n          terminal.writeErrorLine(errorMessage);\n        } else {\n          operationSettingsByOperationName.set(operationName, operationSettings);\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new AlreadyReportedError();\n    }\n\n    return new RushProjectConfiguration(project, rushProjectJson, operationSettingsByOperationName);\n  }\n}\n"]}