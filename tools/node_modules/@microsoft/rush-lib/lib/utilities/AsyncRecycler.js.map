{"version":3,"file":"AsyncRecycler.js","sourceRoot":"","sources":["../../src/utilities/AsyncRecycler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as child_process from 'child_process';\nimport * as os from 'os';\nimport * as path from 'path';\n\nimport { Text, Path, FileSystem, FileSystemStats } from '@rushstack/node-core-library';\n\nimport { Utilities } from './Utilities';\n\n/**\n * For deleting large folders, AsyncRecycler is significantly faster than Utilities.dangerouslyDeletePath().\n * It works by moving one or more folders into a temporary \"recycler\" folder, and then launches a separate\n * background process to recursively delete that folder.\n */\nexport class AsyncRecycler {\n  private _recyclerFolder: string;\n  private _movedFolderCount: number;\n  private _deleting: boolean;\n\n  public constructor(recyclerFolder: string) {\n    this._recyclerFolder = path.resolve(recyclerFolder);\n    this._movedFolderCount = 0;\n    this._deleting = false;\n  }\n\n  /**\n   * The full path of the recycler folder.\n   * Example: `C:\\MyRepo\\common\\rush-recycler`\n   */\n  public get recyclerFolder(): string {\n    return this._recyclerFolder;\n  }\n\n  /**\n   * Synchronously moves the specified folder into the recycler folder.  If the specified folder\n   * does not exist, then no operation is performed.  After calling this function one or more times,\n   * deleteAll() must be called to actually delete the contents of the recycler folder.\n   */\n  public moveFolder(folderPath: string): void {\n    if (this._deleting) {\n      throw new Error('AsyncRecycler.moveFolder() must not be called after deleteAll() has started');\n    }\n\n    if (Path.isUnder(this.recyclerFolder, folderPath)) {\n      throw new Error('AsyncRecycler.moveFolder() cannot be called on a parent of the recycler folder');\n    }\n\n    if (!FileSystem.exists(folderPath)) {\n      return;\n    }\n\n    ++this._movedFolderCount;\n\n    // We need to do a simple \"FileSystem.move\" here, however if the folder we're trying to rename\n    // has a lock, or if its destination container doesn't exist yet,\n    // then there seems to be some OS process (virus scanner?) that holds\n    // a lock on the folder for a split second, which causes renameSync to\n    // fail. To workaround that, retry for up to 7 seconds before giving up.\n    const maxWaitTimeMs: number = 7 * 1000;\n\n    const oldFolderName: string = path.basename(folderPath);\n    const newFolderPath: string = path.join(this.recyclerFolder, `${oldFolderName}_${new Date().getTime()}`);\n\n    if (!FileSystem.exists(this.recyclerFolder)) {\n      Utilities.createFolderWithRetry(this.recyclerFolder);\n    }\n\n    Utilities.retryUntilTimeout(\n      () => FileSystem.move({ sourcePath: folderPath, destinationPath: newFolderPath }),\n      maxWaitTimeMs,\n      (e) =>\n        new Error(\n          `Error: ${e}${os.EOL}Often this is caused by a file lock ` +\n            'from a process like the virus scanner.'\n        ),\n      'recycleFolder'\n    );\n  }\n\n  /**\n   * This deletes all items under the specified folder, except for the items in the membersToExclude.\n   * To be conservative, a case-insensitive comparison is used for membersToExclude.\n   * The membersToExclude must be file/folder names that would match readdir() results.\n   */\n  public moveAllItemsInFolder(folderPath: string, membersToExclude?: ReadonlyArray<string>): void {\n    const resolvedFolderPath: string = path.resolve(folderPath);\n\n    const excludeSet: Set<string> = new Set<string>((membersToExclude || []).map((x) => x.toUpperCase()));\n\n    for (const memberPath of FileSystem.readFolderItemNames(resolvedFolderPath, { absolutePaths: true })) {\n      const normalizedMemberName: string = path.basename(memberPath).toUpperCase();\n      if (!excludeSet.has(normalizedMemberName)) {\n        let shouldMove: boolean = false;\n        try {\n          const stats: FileSystemStats = FileSystem.getLinkStatistics(memberPath);\n          shouldMove = stats.isDirectory();\n        } catch (error) {\n          // If we fail to access the item, assume it's not a folder\n        }\n        if (shouldMove) {\n          this.moveFolder(memberPath);\n        } else {\n          FileSystem.deleteFolder(memberPath);\n        }\n      }\n    }\n  }\n\n  /**\n   * Starts an asynchronous process to delete the recycler folder.  Deleting will continue\n   * even if the current Node.js process is killed.\n   *\n   * NOTE: To avoid spawning multiple instances of the same command, moveFolder()\n   * MUST NOT be called again after deleteAll() has started.\n   */\n  public deleteAll(): void {\n    if (this._deleting) {\n      throw new Error('AsyncRecycler.deleteAll() must not be called more than once');\n    }\n\n    this._deleting = true;\n\n    if (this._movedFolderCount === 0) {\n      // Nothing to do\n      return;\n    }\n\n    // Asynchronously delete the folder contents.\n    let command: string;\n    let args: string[];\n\n    const options: child_process.SpawnOptions = {\n      detached: true,\n      // The child won't stay alive unless we detach its stdio\n      stdio: 'ignore'\n    };\n\n    if (os.platform() === 'win32') {\n      // PowerShell.exe doesn't work with a detached console, so we need cmd.exe to create\n      // the new console for us.\n      command = 'cmd.exe';\n\n      // In PowerShell single-quote literals, single quotes are escaped by doubling them\n      const escapedRecyclerFolder: string = Text.replaceAll(this.recyclerFolder, \"'\", \"''\");\n\n      // As of PowerShell 3.0, the \"\\\\?\" prefix can be used for paths that exceed MAX_PATH.\n      // (This prefix does not seem to work for cmd.exe's \"rd\" command.)\n      args = [\n        '/c',\n        '\"' +\n          'PowerShell.exe -Version 3.0 -NoLogo -NonInteractive -NoProfile -WindowStyle Hidden -Command' +\n          ` Get-ChildItem -Force '${escapedRecyclerFolder}'` +\n          // The \"^|\" here prevents cmd.exe from interpreting the \"|\" symbol\n          ` ^| ForEach ($_) { Remove-Item -ErrorAction Ignore -Force -Recurse \"\\\\\\\\?\\\\$($_.FullName)\" }` +\n          '\"'\n      ];\n\n      options.windowsVerbatimArguments = true;\n    } else {\n      command = 'rm';\n      args = ['-rf'];\n\n      let pathCount: number = 0;\n\n      // child_process.spawn() doesn't expand wildcards.  To be safe, we will do it manually\n      // rather than rely on an unknown shell.\n      for (const filename of FileSystem.readFolderItemNames(this.recyclerFolder)) {\n        // The \".\" and \"..\" are supposed to be excluded, but let's be safe\n        if (filename !== '.' && filename !== '..') {\n          args.push(path.join(this.recyclerFolder, filename));\n          ++pathCount;\n        }\n      }\n\n      if (pathCount === 0) {\n        // Nothing to do\n        return;\n      }\n    }\n\n    const process: child_process.ChildProcess = child_process.spawn(command, args, options);\n\n    // The child won't stay alive unless we unlink it from the parent process\n    process.unref();\n  }\n}\n"]}