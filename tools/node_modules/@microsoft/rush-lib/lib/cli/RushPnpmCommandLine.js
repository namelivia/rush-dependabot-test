"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RushPnpmCommandLine = void 0;
const path = __importStar(require("path"));
const node_core_library_1 = require("@rushstack/node-core-library");
const terminal_1 = require("@rushstack/terminal");
const RushConfiguration_1 = require("../api/RushConfiguration");
const NodeJsCompatibility_1 = require("../logic/NodeJsCompatibility");
const RUSH_SKIP_CHECKS_PARAMETER = '--rush-skip-checks';
class RushPnpmCommandLine {
    static launch(launcherVersion, options) {
        // Node.js can sometimes accidentally terminate with a zero exit code  (e.g. for an uncaught
        // promise exception), so we start with the assumption that the exit code is 1
        // and set it to 0 only on success.
        process.exitCode = 1;
        const { terminalProvider } = options;
        const terminal = new node_core_library_1.Terminal(terminalProvider !== null && terminalProvider !== void 0 ? terminalProvider : new node_core_library_1.ConsoleTerminalProvider());
        try {
            // Are we in a Rush repo?
            let rushConfiguration = undefined;
            if (RushConfiguration_1.RushConfiguration.tryFindRushJsonLocation()) {
                // showVerbose is false because the logging message may break JSON output
                rushConfiguration = RushConfiguration_1.RushConfiguration.loadFromDefaultLocation({ showVerbose: false });
            }
            NodeJsCompatibility_1.NodeJsCompatibility.warnAboutCompatibilityIssues({
                isRushLib: true,
                alreadyReportedNodeTooNewError: !!options.alreadyReportedNodeTooNewError,
                rushConfiguration
            });
            if (!rushConfiguration) {
                throw new Error('The "rush-pnpm" command must be executed in a folder that is under a Rush workspace folder');
            }
            if (rushConfiguration.packageManager !== 'pnpm') {
                throw new Error('The "rush-pnpm" command requires your rush.json to be configured to use the PNPM package manager');
            }
            if (!rushConfiguration.pnpmOptions.useWorkspaces) {
                throw new Error('The "rush-pnpm" command requires the "useWorkspaces" setting to be enabled in rush.json');
            }
            const workspaceFolder = rushConfiguration.commonTempFolder;
            const workspaceFilePath = path.join(workspaceFolder, 'pnpm-workspace.yaml');
            if (!node_core_library_1.FileSystem.exists(workspaceFilePath)) {
                terminal.writeErrorLine('Error: The PNPM workspace file has not been generated:');
                terminal.writeErrorLine(`  ${workspaceFilePath}\n`);
                terminal.writeLine(node_core_library_1.Colors.cyan(`Do you need to run "rush install" or "rush update"?`));
                throw new node_core_library_1.AlreadyReportedError();
            }
            if (!node_core_library_1.FileSystem.exists(rushConfiguration.packageManagerToolFilename)) {
                terminal.writeErrorLine('Error: The PNPM local binary has not been installed yet.');
                terminal.writeLine('\n' + node_core_library_1.Colors.cyan(`Do you need to run "rush install" or "rush update"?`));
                throw new node_core_library_1.AlreadyReportedError();
            }
            // 0 = node.exe
            // 1 = rush-pnpm
            const pnpmArgs = process.argv.slice(2);
            RushPnpmCommandLine._validatePnpmUsage(pnpmArgs, terminal);
            const pnpmEnvironmentMap = new node_core_library_1.EnvironmentMap(process.env);
            pnpmEnvironmentMap.set('NPM_CONFIG_WORKSPACE_DIR', workspaceFolder);
            if (rushConfiguration.pnpmOptions.pnpmStorePath) {
                pnpmEnvironmentMap.set('NPM_CONFIG_STORE_DIR', rushConfiguration.pnpmOptions.pnpmStorePath);
            }
            if (rushConfiguration.pnpmOptions.environmentVariables) {
                for (const [envKey, { value: envValue, override }] of Object.entries(rushConfiguration.pnpmOptions.environmentVariables)) {
                    if (override) {
                        pnpmEnvironmentMap.set(envKey, envValue);
                    }
                    else {
                        if (undefined === pnpmEnvironmentMap.get(envKey)) {
                            pnpmEnvironmentMap.set(envKey, envValue);
                        }
                    }
                }
            }
            const result = node_core_library_1.Executable.spawnSync(rushConfiguration.packageManagerToolFilename, pnpmArgs, {
                environmentMap: pnpmEnvironmentMap,
                stdio: 'inherit'
            });
            if (result.error) {
                throw new Error('Failed to invoke PNPM: ' + result.error);
            }
            if (result.status === null) {
                throw new Error('Failed to invoke PNPM: Spawn completed without an exit code');
            }
            process.exitCode = result.status;
        }
        catch (error) {
            if (!(error instanceof node_core_library_1.AlreadyReportedError)) {
                const prefix = 'ERROR: ';
                terminal.writeErrorLine('\n' + terminal_1.PrintUtilities.wrapWords(prefix + error.message));
            }
        }
    }
    static _validatePnpmUsage(pnpmArgs, terminal) {
        if (pnpmArgs[0] === RUSH_SKIP_CHECKS_PARAMETER) {
            pnpmArgs.shift();
            // Ignore other checks
            return;
        }
        if (pnpmArgs.length === 0) {
            return;
        }
        const firstArg = pnpmArgs[0];
        // Detect common safe invocations
        if (pnpmArgs.includes('-h') || pnpmArgs.includes('--help') || pnpmArgs.includes('-?')) {
            return;
        }
        if (pnpmArgs.length === 1) {
            if (firstArg === '-v' || firstArg === '--version') {
                return;
            }
        }
        const BYPASS_NOTICE = `To bypass this check, add "${RUSH_SKIP_CHECKS_PARAMETER}" as the very first command line option.`;
        if (!/^[a-z]+([a-z0-9\-])*$/.test(firstArg)) {
            // We can't parse this CLI syntax
            terminal.writeErrorLine(`Warning: The "rush-pnpm" wrapper expects a command verb before "${firstArg}"\n`);
            terminal.writeLine(node_core_library_1.Colors.cyan(BYPASS_NOTICE));
            throw new node_core_library_1.AlreadyReportedError();
        }
        else {
            const commandName = firstArg;
            // Also accept SKIP_RUSH_CHECKS_PARAMETER immediately after the command verb
            if (pnpmArgs[1] === RUSH_SKIP_CHECKS_PARAMETER) {
                pnpmArgs.splice(1, 1);
                return;
            }
            if (pnpmArgs.indexOf(RUSH_SKIP_CHECKS_PARAMETER) >= 0) {
                // We do not attempt to parse PNPM's complete CLI syntax, so we cannot be sure how to interpret
                // strings that appear outside of the specific patterns that this parser recognizes
                terminal.writeErrorLine(terminal_1.PrintUtilities.wrapWords(`Error: The "${RUSH_SKIP_CHECKS_PARAMETER}" option must be the first parameter for the "rush-pnpm" command.`));
                throw new node_core_library_1.AlreadyReportedError();
            }
            // Warn about commands known not to work
            /* eslint-disable no-fallthrough */
            switch (commandName) {
                // Blocked
                case 'import': {
                    terminal.writeErrorLine(terminal_1.PrintUtilities.wrapWords(`Error: The "pnpm ${commandName}" command is known to be incompatible with Rush's environment.`) + '\n');
                    terminal.writeLine(node_core_library_1.Colors.cyan(BYPASS_NOTICE));
                    throw new node_core_library_1.AlreadyReportedError();
                }
                // Show warning for install commands
                case 'add':
                case 'install':
                /* synonym */
                case 'i':
                case 'install-test':
                /* synonym */
                case 'it': {
                    terminal.writeErrorLine(terminal_1.PrintUtilities.wrapWords(`Error: The "pnpm ${commandName}" command is incompatible with Rush's environment.` +
                        ` Use the "rush install" or "rush update" commands instead.`) + '\n');
                    terminal.writeLine(node_core_library_1.Colors.cyan(BYPASS_NOTICE));
                    throw new node_core_library_1.AlreadyReportedError();
                }
                // Show warning
                case 'link':
                /* synonym */
                case 'ln':
                case 'remove':
                /* synonym */
                case 'rm':
                case 'unlink':
                case 'update':
                /* synonym */
                case 'up': {
                    terminal.writeWarningLine(terminal_1.PrintUtilities.wrapWords(`Warning: The "pnpm ${commandName}" command makes changes that may invalidate Rush's workspace state.`) + '\n');
                    terminal.writeWarningLine(`==> Consider running "rush install" or "rush update" afterwards.\n`);
                    break;
                }
                // Known safe
                case 'audit':
                case 'exec':
                case 'list':
                /* synonym */
                case 'ls':
                case 'outdated':
                case 'pack':
                case 'prune':
                case 'publish':
                case 'rebuild':
                /* synonym */
                case 'rb':
                case 'root':
                case 'run':
                case 'start':
                case 'store':
                case 'test':
                /* synonym */
                case 't':
                case 'why': {
                    break;
                }
                // Unknown
                default: {
                    terminal.writeErrorLine(terminal_1.PrintUtilities.wrapWords(`Error: The "pnpm ${commandName}" command has not been tested with Rush's environment. It may be incompatible.`) + '\n');
                    terminal.writeLine(node_core_library_1.Colors.cyan(BYPASS_NOTICE));
                    throw new node_core_library_1.AlreadyReportedError();
                }
            }
            /* eslint-enable no-fallthrough */
        }
    }
}
exports.RushPnpmCommandLine = RushPnpmCommandLine;
//# sourceMappingURL=RushPnpmCommandLine.js.map