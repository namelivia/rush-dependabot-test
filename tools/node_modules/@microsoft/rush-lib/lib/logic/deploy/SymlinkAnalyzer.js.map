{"version":3,"file":"SymlinkAnalyzer.js","sourceRoot":"","sources":["../../../src/logic/deploy/SymlinkAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { FileSystem, FileSystemStats, Sort, InternalError } from '@rushstack/node-core-library';\n\nimport * as path from 'path';\n\n/**\n * Represents a file object analyzed by {@link SymlinkAnalyzer}.\n */\nexport interface IFileNode {\n  kind: 'file';\n  nodePath: string;\n}\n\n/**\n * Represents a folder object analyzed by {@link SymlinkAnalyzer}.\n */\nexport interface IFolderNode {\n  kind: 'folder';\n  nodePath: string;\n}\n\n/**\n * Represents a symbolic link analyzed by {@link SymlinkAnalyzer}.\n */\nexport interface ILinkNode {\n  kind: 'link';\n  nodePath: string;\n\n  /**\n   * The immediate target that the symlink resolves to.\n   */\n  linkTarget: string;\n}\n\nexport type PathNode = IFileNode | IFolderNode | ILinkNode;\n\n/**\n * Represents a symbolic link reported by {@link SymlinkAnalyzer.reportSymlinks()}.\n */\nexport interface ILinkInfo {\n  kind: 'fileLink' | 'folderLink';\n\n  /**\n   * The path of the symbolic link.\n   */\n  linkPath: string;\n\n  /**\n   * The target that the link points to.\n   */\n  targetPath: string;\n}\n\nexport class SymlinkAnalyzer {\n  // The directory tree discovered so far\n  private readonly _nodesByPath: Map<string, PathNode> = new Map<string, PathNode>();\n\n  // The symlinks that we encountered while building the directory tree\n  private readonly _linkInfosByPath: Map<string, ILinkInfo> = new Map<string, ILinkInfo>();\n\n  public analyzePath(inputPath: string, preserveLinks: boolean = false): PathNode {\n    let pathSegments: string[] = path.resolve(inputPath).split(path.sep);\n    let pathSegmentsIndex: number = 0;\n\n    for (;;) {\n      const currentPath: string = pathSegments.slice(0, pathSegmentsIndex + 1).join(path.sep);\n\n      if (currentPath === '') {\n        // Edge case for a Unix path like \"/folder/file\" --> [ \"\", \"folder\", \"file\" ]\n        ++pathSegmentsIndex;\n        continue;\n      }\n\n      let currentNode: PathNode | undefined = this._nodesByPath.get(currentPath);\n      if (currentNode === undefined) {\n        const linkStats: FileSystemStats = FileSystem.getLinkStatistics(currentPath);\n\n        if (linkStats.isSymbolicLink()) {\n          const linkTargetPath: string = FileSystem.readLink(currentPath);\n          const parentFolder: string = path.join(currentPath, '..');\n          const resolvedLinkTargetPath: string = path.resolve(parentFolder, linkTargetPath);\n          currentNode = {\n            kind: 'link',\n            nodePath: currentPath,\n            linkTarget: resolvedLinkTargetPath\n          };\n        } else if (linkStats.isDirectory()) {\n          currentNode = {\n            kind: 'folder',\n            nodePath: currentPath\n          };\n        } else if (linkStats.isFile()) {\n          currentNode = {\n            kind: 'file',\n            nodePath: currentPath\n          };\n        } else {\n          throw new Error('Unknown object type: ' + currentPath);\n        }\n\n        this._nodesByPath.set(currentPath, currentNode);\n      }\n\n      ++pathSegmentsIndex;\n\n      if (!preserveLinks) {\n        while (currentNode.kind === 'link') {\n          const targetNode: PathNode = this.analyzePath(currentNode.linkTarget, true);\n\n          // Have we created an ILinkInfo for this link yet?\n          if (!this._linkInfosByPath.has(currentNode.nodePath)) {\n            // Follow any symbolic links to determine whether the final target is a directory\n            const targetIsDirectory: boolean = FileSystem.getStatistics(targetNode.nodePath).isDirectory();\n            const linkInfo: ILinkInfo = {\n              kind: targetIsDirectory ? 'folderLink' : 'fileLink',\n              linkPath: currentNode.nodePath,\n              targetPath: targetNode.nodePath\n            };\n            this._linkInfosByPath.set(currentNode.nodePath, linkInfo);\n          }\n\n          const targetSegments: string[] = targetNode.nodePath.split(path.sep);\n          const remainingSegments: string[] = pathSegments.slice(pathSegmentsIndex);\n          pathSegments = [...targetSegments, ...remainingSegments];\n          pathSegmentsIndex = targetSegments.length;\n          currentNode = targetNode;\n        }\n      }\n\n      if (pathSegmentsIndex >= pathSegments.length) {\n        // We reached the end\n        return currentNode;\n      }\n\n      if (currentNode.kind !== 'folder') {\n        // This should never happen, because analyzePath() is always supposed to receive complete paths\n        // to real filesystem objects.\n        throw new InternalError('The path ends prematurely at: ' + inputPath);\n      }\n    }\n  }\n\n  /**\n   * Returns a summary of all the symbolic links encountered by {@link SymlinkAnalyzer.analyzePath}.\n   */\n  public reportSymlinks(): ILinkInfo[] {\n    const list: ILinkInfo[] = [...this._linkInfosByPath.values()];\n    Sort.sortBy(list, (x) => x.linkPath);\n    return list;\n  }\n}\n"]}