{"version":3,"file":"BaseShrinkwrapFile.js","sourceRoot":"","sources":["../../../src/logic/base/BaseShrinkwrapFile.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport colors from 'colors/safe';\nimport * as semver from 'semver';\n\nimport { RushConstants } from '../../logic/RushConstants';\nimport { DependencySpecifier, DependencySpecifierType } from '../DependencySpecifier';\nimport { IShrinkwrapFilePolicyValidatorOptions } from '../policy/ShrinkwrapFilePolicy';\nimport { PackageManagerOptionsConfigurationBase, RushConfiguration } from '../../api/RushConfiguration';\nimport { PackageNameParsers } from '../../api/PackageNameParsers';\nimport { IExperimentsJson } from '../../api/ExperimentsConfiguration';\nimport { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport { BaseProjectShrinkwrapFile } from './BaseProjectShrinkwrapFile';\n\n/**\n * This class is a parser for both npm's npm-shrinkwrap.json and pnpm's pnpm-lock.yaml file formats.\n */\nexport abstract class BaseShrinkwrapFile {\n  public abstract readonly isWorkspaceCompatible: boolean;\n  protected _alreadyWarnedSpecs: Set<string> = new Set<string>();\n\n  protected static tryGetValue<T>(dictionary: { [key2: string]: T }, key: string): T | undefined {\n    if (dictionary.hasOwnProperty(key)) {\n      return dictionary[key];\n    }\n    return undefined;\n  }\n\n  /**\n   * Validate the shrinkwrap using the provided policy options.\n   *\n   * @virtual\n   */\n  public validate(\n    packageManagerOptionsConfig: PackageManagerOptionsConfigurationBase,\n    policyOptions: IShrinkwrapFilePolicyValidatorOptions,\n    experimentsConfig?: IExperimentsJson\n  ): void {}\n\n  /**\n   * Returns true if the shrinkwrap file includes a top-level package that would satisfy the specified\n   * package name and SemVer version range\n   *\n   * @virtual\n   */\n  public hasCompatibleTopLevelDependency(dependencySpecifier: DependencySpecifier): boolean {\n    const shrinkwrapDependency: DependencySpecifier | undefined = this.getTopLevelDependencyVersion(\n      dependencySpecifier.packageName\n    );\n    if (!shrinkwrapDependency) {\n      return false;\n    }\n\n    return this._checkDependencyVersion(dependencySpecifier, shrinkwrapDependency);\n  }\n\n  /**\n   * Returns true if the shrinkwrap file includes a package that would satisfying the specified\n   * package name and SemVer version range.  By default, the dependencies are resolved by looking\n   * at the root of the node_modules folder described by the shrinkwrap file.  However, if\n   * tempProjectName is specified, then the resolution will start in that subfolder.\n   *\n   * Consider this example:\n   *\n   * - node_modules\\\n   *   - temp-project\\\n   *     - lib-a@1.2.3\n   *     - lib-b@1.0.0\n   *   - lib-b@2.0.0\n   *\n   * In this example, hasCompatibleDependency(\"lib-b\", \">= 1.1.0\", \"temp-project\") would fail\n   * because it finds lib-b@1.0.0 which does not satisfy the pattern \">= 1.1.0\".\n   *\n   * @virtual\n   */\n  public tryEnsureCompatibleDependency(\n    dependencySpecifier: DependencySpecifier,\n    tempProjectName: string\n  ): boolean {\n    const shrinkwrapDependency: DependencySpecifier | undefined = this.tryEnsureDependencyVersion(\n      dependencySpecifier,\n      tempProjectName\n    );\n    if (!shrinkwrapDependency) {\n      return false;\n    }\n\n    return this._checkDependencyVersion(dependencySpecifier, shrinkwrapDependency);\n  }\n\n  /**\n   * Returns the list of temp projects defined in this file.\n   * Example: [ '@rush-temp/project1', '@rush-temp/project2' ]\n   *\n   * @virtual\n   */\n  public abstract getTempProjectNames(): ReadonlyArray<string>;\n\n  /** @virtual */\n  protected abstract tryEnsureDependencyVersion(\n    dependencySpecifier: DependencySpecifier,\n    tempProjectName: string\n  ): DependencySpecifier | undefined;\n\n  /** @virtual */\n  protected abstract getTopLevelDependencyVersion(dependencyName: string): DependencySpecifier | undefined;\n\n  /**\n   * Check for projects that exist in the shrinkwrap file, but don't exist\n   * in rush.json.  This might occur, e.g. if a project was recently deleted or renamed.\n   *\n   * @returns a list of orphaned projects.\n   */\n  public findOrphanedProjects(rushConfiguration: RushConfiguration): ReadonlyArray<string> {\n    const orphanedProjectNames: string[] = [];\n    // We can recognize temp projects because they are under the \"@rush-temp\" NPM scope.\n    for (const tempProjectName of this.getTempProjectNames()) {\n      if (!rushConfiguration.findProjectByTempName(tempProjectName)) {\n        orphanedProjectNames.push(tempProjectName);\n      }\n    }\n    return orphanedProjectNames;\n  }\n\n  /**\n   * Returns a project shrinkwrap file for the specified project that contains all dependencies and transitive\n   * dependencies.\n   *\n   * @virtual\n   **/\n  public abstract getProjectShrinkwrap(\n    project: RushConfigurationProject\n  ): BaseProjectShrinkwrapFile | undefined;\n\n  /**\n   * Returns whether or not the workspace specified by the shrinkwrap matches the state of\n   * a given package.json. Returns true if any dependencies are not aligned with the shrinkwrap.\n   *\n   * @param project - the Rush project that is being validated against the shrinkwrap\n   * @param variant - the variant that is being validated\n   *\n   * @virtual\n   */\n  public abstract isWorkspaceProjectModified(project: RushConfigurationProject, variant?: string): boolean;\n\n  /** @virtual */\n  protected abstract serialize(): string;\n\n  protected _getTempProjectNames(dependencies: { [key: string]: {} }): ReadonlyArray<string> {\n    const result: string[] = [];\n    for (const key of Object.keys(dependencies)) {\n      // If it starts with @rush-temp, then include it:\n      if (PackageNameParsers.permissive.getScope(key) === RushConstants.rushTempNpmScope) {\n        result.push(key);\n      }\n    }\n    result.sort(); // make the result deterministic\n    return result;\n  }\n\n  private _checkDependencyVersion(\n    projectDependency: DependencySpecifier,\n    shrinkwrapDependency: DependencySpecifier\n  ): boolean {\n    let normalizedProjectDependency: DependencySpecifier = projectDependency;\n    let normalizedShrinkwrapDependency: DependencySpecifier = shrinkwrapDependency;\n\n    // Special handling for NPM package aliases such as this:\n    //\n    // \"dependencies\": {\n    //   \"alias-name\": \"npm:target-name@^1.2.3\"\n    // }\n    //\n    // In this case, the shrinkwrap file will have a key equivalent to \"npm:target-name@1.2.5\",\n    // and so we need to unwrap the target and compare \"1.2.5\" with \"^1.2.3\".\n    if (projectDependency.specifierType === DependencySpecifierType.Alias) {\n      // Does the shrinkwrap install it as an alias?\n      if (shrinkwrapDependency.specifierType === DependencySpecifierType.Alias) {\n        // Does the shrinkwrap have the right package name?\n        if (projectDependency.packageName === shrinkwrapDependency.packageName) {\n          // Yes, the aliases match, so let's compare their targets in the logic below\n          normalizedProjectDependency = projectDependency.aliasTarget!;\n          normalizedShrinkwrapDependency = shrinkwrapDependency.aliasTarget!;\n        } else {\n          // If the names are different, then it's a mismatch\n          return false;\n        }\n      } else {\n        // A non-alias cannot satisfy an alias dependency; at least, let's avoid that idea\n        return false;\n      }\n    }\n\n    switch (normalizedProjectDependency.specifierType) {\n      case DependencySpecifierType.Version:\n      case DependencySpecifierType.Range:\n        return semver.satisfies(\n          normalizedShrinkwrapDependency.versionSpecifier,\n          normalizedProjectDependency.versionSpecifier\n        );\n      default:\n        // For other version specifier types like \"file:./blah.tgz\" or \"git://github.com/npm/cli.git#v1.0.27\"\n        // we allow the installation to continue but issue a warning.  The \"rush install\" checks will not work\n        // correctly.\n\n        // Only warn once for each versionSpecifier\n        if (!this._alreadyWarnedSpecs.has(projectDependency.versionSpecifier)) {\n          this._alreadyWarnedSpecs.add(projectDependency.versionSpecifier);\n          console.log(\n            colors.yellow(\n              `WARNING: Not validating ${projectDependency.specifierType}-based` +\n                ` specifier: \"${projectDependency.versionSpecifier}\"`\n            )\n          );\n        }\n        return true;\n    }\n  }\n}\n"]}