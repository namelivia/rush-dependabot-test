{"version":3,"file":"OperationExecutionRecord.js","sourceRoot":"","sources":["../../../src/logic/operations/OperationExecutionRecord.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D,kDAAsD;AACtD,oEAA6D;AAG7D,uDAAoD;AAGpD,yDAAsD;AAStD;;GAEG;AACH,MAAa,wBAAwB;IAiEnC,YAAmB,SAAoB,EAAE,OAAyC;;QAhElF;;;;;WAKG;QACI,WAAM,GAAoB,iCAAe,CAAC,KAAK,CAAC;QAEvD;;;WAGG;QACI,UAAK,GAAsB,SAAS,CAAC;QAE5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;WA4BG;QACI,uBAAkB,GAAuB,SAAS,CAAC;QAE1D;;WAEG;QACa,iBAAY,GAAkC,IAAI,GAAG,EAAE,CAAC;QACxE;;WAEG;QACa,cAAS,GAAkC,IAAI,GAAG,EAAE,CAAC;QAErD,cAAS,GAAc,IAAI,qBAAS,EAAE,CAAC;QACvC,oBAAe,GAAoB,IAAI,0BAAe,EAAE,CAAC;QAOjE,oBAAe,GAA+B,SAAS,CAAC;QAG9D,MAAM,EAAE,MAAM,EAAE,GAAG,SAAS,CAAC;QAE7B,IAAI,CAAC,MAAM,EAAE;YACX,MAAM,IAAI,iCAAa,CACrB,wBAAwB,MAAA,SAAS,CAAC,eAAe,0CAAE,IAAI,kBAAkB,MAAA,SAAS,CAAC,iBAAiB,0CAAE,WAAW,kBAAkB,CACpI,CAAC;SACH;QAED,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC;QAC/B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC1B,CAAC;IAED,IAAW,IAAI;QACb,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;IAC1B,CAAC;IAED,IAAW,SAAS;QAClB,OAAO,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;IACjC,CAAC;IAED,IAAW,SAAS;QAClB,OAAO,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC;IACjC,CAAC;IAED,IAAW,cAAc;QACvB,4EAA4E;QAC5E,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;YACzB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SAC7E;QACD,OAAO,IAAI,CAAC,eAAe,CAAC;IAC9B,CAAC;IAEM,KAAK,CAAC,YAAY,CAAC,QAAoD;;QAC5E,IAAI,CAAC,MAAM,GAAG,iCAAe,CAAC,SAAS,CAAC;QACxC,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;QAEvB,IAAI;YACF,IAAI,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YACnD,kCAAkC;YAClC,QAAQ,CAAC,IAAI,CAAC,CAAC;SAChB;QAAC,OAAO,KAAK,EAAE;YACd,IAAI,CAAC,MAAM,GAAG,iCAAe,CAAC,OAAO,CAAC;YACtC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;YACnB,kCAAkC;YAClC,QAAQ,CAAC,IAAI,CAAC,CAAC;SAChB;gBAAS;YACR,MAAA,IAAI,CAAC,eAAe,0CAAE,KAAK,EAAE,CAAC;YAC9B,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;YAC7B,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC;SACvB;IACH,CAAC;CACF;AAtHD,4DAsHC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { StdioSummarizer } from '@rushstack/terminal';\nimport { InternalError } from '@rushstack/node-core-library';\nimport { CollatedWriter, StreamCollator } from '@rushstack/stream-collator';\n\nimport { OperationStatus } from './OperationStatus';\nimport { IOperationRunner, IOperationRunnerContext } from './IOperationRunner';\nimport { Operation } from './Operation';\nimport { Stopwatch } from '../../utilities/Stopwatch';\n\nexport interface IOperationExecutionRecordContext {\n  streamCollator: StreamCollator;\n\n  debugMode: boolean;\n  quietMode: boolean;\n}\n\n/**\n * Internal class representing everything about executing an operation\n */\nexport class OperationExecutionRecord implements IOperationRunnerContext {\n  /**\n   * The current execution status of an operation. Operations start in the 'ready' state,\n   * but can be 'blocked' if an upstream operation failed. It is 'executing' when\n   * the operation is executing. Once execution is complete, it is either 'success' or\n   * 'failure'.\n   */\n  public status: OperationStatus = OperationStatus.Ready;\n\n  /**\n   * The error which occurred while executing this operation, this is stored in case we need\n   * it later (for example to re-print errors at end of execution).\n   */\n  public error: Error | undefined = undefined;\n\n  /**\n   * This number represents how far away this Operation is from the furthest \"root\" operation (i.e.\n   * an operation with no consumers). This helps us to calculate the critical path (i.e. the\n   * longest chain of projects which must be executed in order, thereby limiting execution speed\n   * of the entire operation tree.\n   *\n   * This number is calculated via a memoized depth-first search, and when choosing the next\n   * operation to execute, the operation with the highest criticalPathLength is chosen.\n   *\n   * Example:\n   *        (0) A\n   *             \\\n   *          (1) B     C (0)         (applications)\n   *               \\   /|\\\n   *                \\ / | \\\n   *             (2) D  |  X (1)      (utilities)\n   *                    | / \\\n   *                    |/   \\\n   *                (2) Y     Z (2)   (other utilities)\n   *\n   * All roots (A & C) have a criticalPathLength of 0.\n   * B has a score of 1, since A depends on it.\n   * D has a score of 2, since we look at the longest chain (e.g D->B->A is longer than D->C)\n   * X has a score of 1, since the only package which depends on it is A\n   * Z has a score of 2, since only X depends on it, and X has a score of 1\n   * Y has a score of 2, since the chain Y->X->C is longer than Y->C\n   *\n   * The algorithm is implemented in AsyncOperationQueue.ts as calculateCriticalPathLength()\n   */\n  public criticalPathLength: number | undefined = undefined;\n\n  /**\n   * The set of operations that must complete before this operation executes.\n   */\n  public readonly dependencies: Set<OperationExecutionRecord> = new Set();\n  /**\n   * The set of operations that depend on this operation.\n   */\n  public readonly consumers: Set<OperationExecutionRecord> = new Set();\n\n  public readonly stopwatch: Stopwatch = new Stopwatch();\n  public readonly stdioSummarizer: StdioSummarizer = new StdioSummarizer();\n\n  public readonly runner: IOperationRunner;\n  public readonly weight: number;\n\n  private readonly _context: IOperationExecutionRecordContext;\n\n  private _collatedWriter: CollatedWriter | undefined = undefined;\n\n  public constructor(operation: Operation, context: IOperationExecutionRecordContext) {\n    const { runner } = operation;\n\n    if (!runner) {\n      throw new InternalError(\n        `Operation for phase '${operation.associatedPhase?.name}' and project '${operation.associatedProject?.packageName}' has no runner.`\n      );\n    }\n\n    this.runner = runner;\n    this.weight = operation.weight;\n    this._context = context;\n  }\n\n  public get name(): string {\n    return this.runner.name;\n  }\n\n  public get debugMode(): boolean {\n    return this._context.debugMode;\n  }\n\n  public get quietMode(): boolean {\n    return this._context.quietMode;\n  }\n\n  public get collatedWriter(): CollatedWriter {\n    // Lazy instantiate because the registerTask() call affects display ordering\n    if (!this._collatedWriter) {\n      this._collatedWriter = this._context.streamCollator.registerTask(this.name);\n    }\n    return this._collatedWriter;\n  }\n\n  public async executeAsync(onResult: (record: OperationExecutionRecord) => void): Promise<void> {\n    this.status = OperationStatus.Executing;\n    this.stopwatch.start();\n\n    try {\n      this.status = await this.runner.executeAsync(this);\n      // Delegate global state reporting\n      onResult(this);\n    } catch (error) {\n      this.status = OperationStatus.Failure;\n      this.error = error;\n      // Delegate global state reporting\n      onResult(this);\n    } finally {\n      this._collatedWriter?.close();\n      this.stdioSummarizer.close();\n      this.stopwatch.stop();\n    }\n  }\n}\n"]}