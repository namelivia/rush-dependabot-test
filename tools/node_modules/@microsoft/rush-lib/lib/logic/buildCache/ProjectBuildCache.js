"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectBuildCache = void 0;
const path = __importStar(require("path"));
const events_1 = __importDefault(require("events"));
const crypto = __importStar(require("crypto"));
const tar = __importStar(require("tar"));
const node_core_library_1 = require("@rushstack/node-core-library");
const RushConstants_1 = require("../RushConstants");
const TarExecutable_1 = require("../../utilities/TarExecutable");
const Utilities_1 = require("../../utilities/Utilities");
class ProjectBuildCache {
    constructor(cacheId, options) {
        const { buildCacheConfiguration, projectConfiguration, projectOutputFolderNames } = options;
        this._project = projectConfiguration.project;
        this._localBuildCacheProvider = buildCacheConfiguration.localCacheProvider;
        this._cloudBuildCacheProvider = buildCacheConfiguration.cloudCacheProvider;
        this._buildCacheEnabled = buildCacheConfiguration.buildCacheEnabled;
        this._cacheWriteEnabled = buildCacheConfiguration.cacheWriteEnabled;
        this._projectOutputFolderNames = projectOutputFolderNames || [];
        this._cacheId = cacheId;
    }
    static _tryGetTarUtility(terminal) {
        if (ProjectBuildCache._tarUtilityPromise === null) {
            ProjectBuildCache._tarUtilityPromise = TarExecutable_1.TarExecutable.tryInitializeAsync(terminal);
        }
        return ProjectBuildCache._tarUtilityPromise;
    }
    static async tryGetProjectBuildCache(options) {
        const { terminal, projectConfiguration, projectOutputFolderNames, trackedProjectFiles } = options;
        if (!trackedProjectFiles) {
            return undefined;
        }
        if (!ProjectBuildCache._validateProject(terminal, projectConfiguration, projectOutputFolderNames, trackedProjectFiles)) {
            return undefined;
        }
        const cacheId = await ProjectBuildCache._getCacheId(options);
        return new ProjectBuildCache(cacheId, options);
    }
    static _validateProject(terminal, projectConfiguration, projectOutputFolderNames, trackedProjectFiles) {
        const normalizedProjectRelativeFolder = node_core_library_1.Path.convertToSlashes(projectConfiguration.project.projectRelativeFolder);
        const outputFolders = [];
        if (projectOutputFolderNames) {
            for (const outputFolderName of projectOutputFolderNames) {
                outputFolders.push(`${normalizedProjectRelativeFolder}/${outputFolderName}/`);
            }
        }
        const inputOutputFiles = [];
        for (const file of trackedProjectFiles) {
            for (const outputFolder of outputFolders) {
                if (file.startsWith(outputFolder)) {
                    inputOutputFiles.push(file);
                }
            }
        }
        if (inputOutputFiles.length > 0) {
            terminal.writeWarningLine('Unable to use build cache. The following files are used to calculate project state ' +
                `and are considered project output: ${inputOutputFiles.join(', ')}`);
            return false;
        }
        else {
            return true;
        }
    }
    async tryRestoreFromCacheAsync(terminal) {
        const cacheId = this._cacheId;
        if (!cacheId) {
            terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');
            return false;
        }
        if (!this._buildCacheEnabled) {
            // Skip reading local and cloud build caches, without any noise
            return false;
        }
        let localCacheEntryPath = await this._localBuildCacheProvider.tryGetCacheEntryPathByIdAsync(terminal, cacheId);
        let cacheEntryBuffer;
        let updateLocalCacheSuccess;
        if (!localCacheEntryPath && this._cloudBuildCacheProvider) {
            terminal.writeVerboseLine('This project was not found in the local build cache. Querying the cloud build cache.');
            cacheEntryBuffer = await this._cloudBuildCacheProvider.tryGetCacheEntryBufferByIdAsync(terminal, cacheId);
            if (cacheEntryBuffer) {
                try {
                    localCacheEntryPath = await this._localBuildCacheProvider.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer);
                    updateLocalCacheSuccess = true;
                }
                catch (e) {
                    updateLocalCacheSuccess = false;
                }
            }
        }
        if (!localCacheEntryPath && !cacheEntryBuffer) {
            terminal.writeVerboseLine('This project was not found in the build cache.');
            return false;
        }
        terminal.writeLine('Build cache hit.');
        const projectFolderPath = this._project.projectFolder;
        // Purge output folders
        terminal.writeVerboseLine(`Clearing cached folders: ${this._projectOutputFolderNames.join(', ')}`);
        await Promise.all(this._projectOutputFolderNames.map((outputFolderName) => node_core_library_1.FileSystem.deleteFolderAsync(`${projectFolderPath}/${outputFolderName}`)));
        const tarUtility = await ProjectBuildCache._tryGetTarUtility(terminal);
        let restoreSuccess = false;
        if (tarUtility && localCacheEntryPath) {
            const logFilePath = this._getTarLogFilePath();
            const tarExitCode = await tarUtility.tryUntarAsync({
                archivePath: localCacheEntryPath,
                outputFolderPath: projectFolderPath,
                logFilePath
            });
            if (tarExitCode === 0) {
                restoreSuccess = true;
            }
            else {
                terminal.writeWarningLine(`"tar" exited with code ${tarExitCode} while attempting to restore cache entry. ` +
                    'Rush will attempt to extract from the cache entry with a JavaScript implementation of tar. ' +
                    `See "${logFilePath}" for logs from the tar process.`);
            }
        }
        if (!restoreSuccess) {
            if (!cacheEntryBuffer && localCacheEntryPath) {
                cacheEntryBuffer = await node_core_library_1.FileSystem.readFileToBufferAsync(localCacheEntryPath);
            }
            if (!cacheEntryBuffer) {
                throw new Error('Expected the cache entry buffer to be set.');
            }
            // If we don't have tar on the PATH, if we failed to update the local cache entry,
            // or if the tar binary failed, untar in-memory
            const tarStream = tar.extract({
                cwd: projectFolderPath,
                // Set to true to omit writing mtime value for extracted entries.
                m: true
            });
            try {
                const tarPromise = events_1.default.once(tarStream, 'drain');
                tarStream.write(cacheEntryBuffer);
                await tarPromise;
                restoreSuccess = true;
            }
            catch (e) {
                restoreSuccess = false;
            }
        }
        if (restoreSuccess) {
            terminal.writeLine('Successfully restored output from the build cache.');
        }
        else {
            terminal.writeWarningLine('Unable to restore output from the build cache.');
        }
        if (updateLocalCacheSuccess === false) {
            terminal.writeWarningLine('Unable to update the local build cache with data from the cloud cache.');
        }
        return restoreSuccess;
    }
    async trySetCacheEntryAsync(terminal) {
        var _a, _b;
        if (!this._cacheWriteEnabled) {
            // Skip writing local and cloud build caches, without any noise
            return true;
        }
        const cacheId = this._cacheId;
        if (!cacheId) {
            terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');
            return false;
        }
        const projectFolderPath = this._project.projectFolder;
        const filesToCache = await this._tryCollectPathsToCacheAsync(terminal);
        if (!filesToCache) {
            return false;
        }
        terminal.writeVerboseLine(`Caching build output folders: ${filesToCache.filteredOutputFolderNames.join(', ')}`);
        let localCacheEntryPath;
        const tarUtility = await ProjectBuildCache._tryGetTarUtility(terminal);
        if (tarUtility) {
            const finalLocalCacheEntryPath = this._localBuildCacheProvider.getCacheEntryPath(cacheId);
            // Derive the temp file from the destination path to ensure they are on the same volume
            const tempLocalCacheEntryPath = `${finalLocalCacheEntryPath}.temp`;
            const logFilePath = this._getTarLogFilePath();
            const tarExitCode = await tarUtility.tryCreateArchiveFromProjectPathsAsync({
                archivePath: tempLocalCacheEntryPath,
                paths: filesToCache.outputFilePaths,
                project: this._project,
                logFilePath
            });
            if (tarExitCode === 0) {
                // Move after the archive is finished so that if the process is interrupted we aren't left with an invalid file
                await node_core_library_1.FileSystem.moveAsync({
                    sourcePath: tempLocalCacheEntryPath,
                    destinationPath: finalLocalCacheEntryPath,
                    overwrite: true
                });
                localCacheEntryPath = finalLocalCacheEntryPath;
            }
            else {
                terminal.writeWarningLine(`"tar" exited with code ${tarExitCode} while attempting to create the cache entry. ` +
                    'Rush will attempt to create the cache entry with a JavaScript implementation of tar. ' +
                    `See "${logFilePath}" for logs from the tar process.`);
            }
        }
        let cacheEntryBuffer;
        let setLocalCacheEntryPromise;
        if (!localCacheEntryPath) {
            // If we weren't able to create the cache entry with tar, try to do it with the "tar" NPM package
            const tarStream = tar.create({
                gzip: true,
                portable: true,
                strict: true,
                cwd: projectFolderPath
            }, filesToCache.outputFilePaths);
            cacheEntryBuffer = await Utilities_1.Utilities.readStreamToBufferAsync(tarStream);
            setLocalCacheEntryPromise = this._localBuildCacheProvider.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer);
        }
        else {
            setLocalCacheEntryPromise = Promise.resolve(localCacheEntryPath);
        }
        let setCloudCacheEntryPromise;
        // Note that "writeAllowed" settings (whether in config or environment) always apply to
        // the configured CLOUD cache. If the cache is enabled, rush is always allowed to read from and
        // write to the local build cache.
        if ((_a = this._cloudBuildCacheProvider) === null || _a === void 0 ? void 0 : _a.isCacheWriteAllowed) {
            if (!cacheEntryBuffer) {
                if (localCacheEntryPath) {
                    cacheEntryBuffer = await node_core_library_1.FileSystem.readFileToBufferAsync(localCacheEntryPath);
                }
                else {
                    throw new Error('Expected the local cache entry path to be set.');
                }
            }
            setCloudCacheEntryPromise = (_b = this._cloudBuildCacheProvider) === null || _b === void 0 ? void 0 : _b.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer);
        }
        let localCachePath;
        let updateCloudCacheSuccess;
        if (setCloudCacheEntryPromise) {
            [updateCloudCacheSuccess, localCachePath] = await Promise.all([
                setCloudCacheEntryPromise,
                setLocalCacheEntryPromise
            ]);
        }
        else {
            updateCloudCacheSuccess = true;
            localCachePath = await setLocalCacheEntryPromise;
        }
        const success = updateCloudCacheSuccess && !!localCachePath;
        if (success) {
            terminal.writeLine('Successfully set cache entry.');
        }
        else if (!localCachePath && updateCloudCacheSuccess) {
            terminal.writeWarningLine('Unable to set local cache entry.');
        }
        else if (localCachePath && !updateCloudCacheSuccess) {
            terminal.writeWarningLine('Unable to set cloud cache entry.');
        }
        else {
            terminal.writeWarningLine('Unable to set both cloud and local cache entries.');
        }
        return success;
    }
    /**
     * Walks the declared output folders of the project and collects a list of files.
     * @returns The list of output files as project-relative paths, or `undefined` if a
     *   symbolic link was encountered.
     */
    async _tryCollectPathsToCacheAsync(terminal) {
        const projectFolderPath = this._project.projectFolder;
        const outputFilePaths = [];
        const queue = [];
        const filteredOutputFolderNames = [];
        let hasSymbolicLinks = false;
        // Adds child directories to the queue, files to the path list, and bails on symlinks
        function processChildren(relativePath, diskPath, children) {
            for (const child of children) {
                const childRelativePath = `${relativePath}/${child.name}`;
                if (child.isSymbolicLink()) {
                    terminal.writeError(`Unable to include "${childRelativePath}" in build cache. It is a symbolic link.`);
                    hasSymbolicLinks = true;
                }
                else if (child.isDirectory()) {
                    queue.push([childRelativePath, `${diskPath}/${child.name}`]);
                }
                else {
                    outputFilePaths.push(childRelativePath);
                }
            }
        }
        // Handle declared output folders.
        for (const outputFolder of this._projectOutputFolderNames) {
            const diskPath = `${projectFolderPath}/${outputFolder}`;
            try {
                const children = await node_core_library_1.FileSystem.readFolderItemsAsync(diskPath);
                processChildren(outputFolder, diskPath, children);
                // The folder exists, record it
                filteredOutputFolderNames.push(outputFolder);
            }
            catch (error) {
                if (!node_core_library_1.FileSystem.isNotExistError(error)) {
                    throw error;
                }
                // If the folder does not exist, ignore it.
            }
        }
        for (const [relativePath, diskPath] of queue) {
            const children = await node_core_library_1.FileSystem.readFolderItemsAsync(diskPath);
            processChildren(relativePath, diskPath, children);
        }
        if (hasSymbolicLinks) {
            // Symbolic links do not round-trip safely.
            return undefined;
        }
        // Ensure stable output path order.
        outputFilePaths.sort();
        return {
            outputFilePaths,
            filteredOutputFolderNames
        };
    }
    _getTarLogFilePath() {
        return path.join(this._project.projectRushTempFolder, `${this._cacheId}.log`);
    }
    static async _getCacheId(options) {
        // The project state hash is calculated in the following method:
        // - The current project's hash (see ProjectChangeAnalyzer.getProjectStateHash) is
        //   calculated and appended to an array
        // - The current project's recursive dependency projects' hashes are calculated
        //   and appended to the array
        // - A SHA1 hash is created and the following data is fed into it, in order:
        //   1. The JSON-serialized list of output folder names for this
        //      project (see ProjectBuildCache._projectOutputFolderNames)
        //   2. The command that will be run in the project
        //   3. Each dependency project hash (from the array constructed in previous steps),
        //      in sorted alphanumerical-sorted order
        // - A hex digest of the hash is returned
        const projectChangeAnalyzer = options.projectChangeAnalyzer;
        const projectStates = [];
        const projectsThatHaveBeenProcessed = new Set();
        let projectsToProcess = new Set();
        projectsToProcess.add(options.projectConfiguration.project);
        while (projectsToProcess.size > 0) {
            const newProjectsToProcess = new Set();
            for (const projectToProcess of projectsToProcess) {
                projectsThatHaveBeenProcessed.add(projectToProcess);
                const projectState = await projectChangeAnalyzer._tryGetProjectStateHashAsync(projectToProcess, options.terminal);
                if (!projectState) {
                    // If we hit any projects with unknown state, return unknown cache ID
                    return undefined;
                }
                else {
                    projectStates.push(projectState);
                    for (const dependency of projectToProcess.dependencyProjects) {
                        if (!projectsThatHaveBeenProcessed.has(dependency)) {
                            newProjectsToProcess.add(dependency);
                        }
                    }
                }
            }
            projectsToProcess = newProjectsToProcess;
        }
        const sortedProjectStates = projectStates.sort();
        const hash = crypto.createHash('sha1');
        // This value is used to force cache bust when the build cache algorithm changes
        hash.update(`${RushConstants_1.RushConstants.buildCacheVersion}`);
        hash.update(RushConstants_1.RushConstants.hashDelimiter);
        const serializedOutputFolders = JSON.stringify(options.projectOutputFolderNames);
        hash.update(serializedOutputFolders);
        hash.update(RushConstants_1.RushConstants.hashDelimiter);
        hash.update(options.command);
        hash.update(RushConstants_1.RushConstants.hashDelimiter);
        for (const projectHash of sortedProjectStates) {
            hash.update(projectHash);
            hash.update(RushConstants_1.RushConstants.hashDelimiter);
        }
        const projectStateHash = hash.digest('hex');
        return options.buildCacheConfiguration.getCacheEntryId({
            projectName: options.projectConfiguration.project.packageName,
            projectStateHash,
            phaseName: options.phaseName
        });
    }
}
exports.ProjectBuildCache = ProjectBuildCache;
/**
 * null === we haven't tried to initialize yet
 * undefined === unable to initialize
 */
ProjectBuildCache._tarUtilityPromise = null;
//# sourceMappingURL=ProjectBuildCache.js.map