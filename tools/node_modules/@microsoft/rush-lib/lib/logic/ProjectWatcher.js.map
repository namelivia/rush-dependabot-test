{"version":3,"file":"ProjectWatcher.js","sourceRoot":"","sources":["../../src/logic/ProjectWatcher.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport { once } from 'events';\nimport { getRepoRoot } from '@rushstack/package-deps-hash';\nimport { Path, ITerminal, FileSystemStats, FileSystem } from '@rushstack/node-core-library';\n\nimport { Git } from './Git';\nimport { ProjectChangeAnalyzer } from './ProjectChangeAnalyzer';\nimport { RushConfiguration } from '../api/RushConfiguration';\nimport { RushConfigurationProject } from '../api/RushConfigurationProject';\n\nexport interface IProjectWatcherOptions {\n  debounceMilliseconds?: number;\n  rushConfiguration: RushConfiguration;\n  projectsToWatch: ReadonlySet<RushConfigurationProject>;\n  terminal: ITerminal;\n  initialState?: ProjectChangeAnalyzer | undefined;\n}\n\nexport interface IProjectChangeResult {\n  /**\n   * The set of projects that have changed since the last iteration\n   */\n  changedProjects: ReadonlySet<RushConfigurationProject>;\n  /**\n   * Contains the git hashes for all tracked files in the repo\n   */\n  state: ProjectChangeAnalyzer;\n}\n\n/**\n * This class is for incrementally watching a set of projects in the repository for changes.\n *\n * We are manually using fs.watch() instead of `chokidar` because all we want from the file system watcher is a boolean\n * signal indicating that \"at least 1 file in a watched project changed\". We then defer to ProjectChangeAnalyzer (which\n * is responsible for change detection in all incremental builds) to determine what actually chanaged.\n *\n * Calling `waitForChange()` will return a promise that resolves when the package-deps of one or\n * more projects differ from the value the previous time it was invoked. The first time will always resolve with the full selection.\n */\nexport class ProjectWatcher {\n  private readonly _debounceMilliseconds: number;\n  private readonly _repoRoot: string;\n  private readonly _rushConfiguration: RushConfiguration;\n  private readonly _projectsToWatch: ReadonlySet<RushConfigurationProject>;\n  private readonly _terminal: ITerminal;\n\n  private _initialState: ProjectChangeAnalyzer | undefined;\n  private _previousState: ProjectChangeAnalyzer | undefined;\n\n  public constructor(options: IProjectWatcherOptions) {\n    const {\n      debounceMilliseconds = 1000,\n      rushConfiguration,\n      projectsToWatch,\n      terminal,\n      initialState\n    } = options;\n\n    this._debounceMilliseconds = debounceMilliseconds;\n    this._rushConfiguration = rushConfiguration;\n    this._projectsToWatch = projectsToWatch;\n    this._terminal = terminal;\n\n    const gitPath: string = new Git(rushConfiguration).getGitPathOrThrow();\n    this._repoRoot = Path.convertToSlashes(getRepoRoot(rushConfiguration.rushJsonFolder, gitPath));\n\n    this._initialState = initialState;\n    this._previousState = initialState;\n  }\n\n  /**\n   * Waits for a change to the package-deps of one or more of the selected projects, since the previous invocation.\n   * Will return immediately the first time it is invoked, since no state has been recorded.\n   * If no change is currently present, watches the source tree of all selected projects for file changes.\n   */\n  public async waitForChange(onWatchingFiles?: () => void): Promise<IProjectChangeResult> {\n    const initialChangeResult: IProjectChangeResult = await this._computeChanged();\n    // Ensure that the new state is recorded so that we don't loop infinitely\n    this._commitChanges(initialChangeResult.state);\n    if (initialChangeResult.changedProjects.size) {\n      return initialChangeResult;\n    }\n\n    const previousState: ProjectChangeAnalyzer = initialChangeResult.state;\n    const repoRoot: string = Path.convertToSlashes(this._rushConfiguration.rushJsonFolder);\n\n    const pathsToWatch: Set<string> = new Set();\n\n    // Node 12 supports the \"recursive\" parameter to fs.watch only on win32 and OSX\n    // https://nodejs.org/docs/latest-v12.x/api/fs.html#fs_caveats\n    const useNativeRecursiveWatch: boolean = os.platform() === 'win32' || os.platform() === 'darwin';\n\n    if (useNativeRecursiveWatch) {\n      // Watch the entire repository; a single recursive watcher is cheap.\n      pathsToWatch.add(this._repoRoot);\n    } else {\n      for (const project of this._projectsToWatch) {\n        const projectState: Map<string, string> = (await previousState._tryGetProjectDependenciesAsync(\n          project,\n          this._terminal\n        ))!;\n\n        const prefixLength: number = project.projectFolder.length - repoRoot.length - 1;\n        // Watch files in the root of the project, or\n        for (const pathToWatch of ProjectWatcher._enumeratePathsToWatch(projectState.keys(), prefixLength)) {\n          pathsToWatch.add(`${this._repoRoot}/${pathToWatch}`);\n        }\n      }\n    }\n\n    const watchers: Map<string, fs.FSWatcher> = new Map();\n\n    const watchedResult: IProjectChangeResult = await new Promise(\n      (resolve: (result: IProjectChangeResult) => void, reject: (err: Error) => void) => {\n        let timeout: NodeJS.Timeout | undefined;\n        let terminated: boolean = false;\n\n        const debounceMilliseconds: number = this._debounceMilliseconds;\n\n        const resolveIfChanged = async (): Promise<void> => {\n          timeout = undefined;\n          if (terminated) {\n            return;\n          }\n\n          try {\n            const result: IProjectChangeResult = await this._computeChanged();\n\n            // Need an async tick to allow for more file system events to be handled\n            process.nextTick(() => {\n              if (timeout) {\n                // If another file has changed, wait for another pass.\n                return;\n              }\n\n              this._commitChanges(result.state);\n\n              if (result.changedProjects.size) {\n                terminated = true;\n                resolve(result);\n              }\n            });\n          } catch (err) {\n            // eslint-disable-next-line require-atomic-updates\n            terminated = true;\n            reject(err as NodeJS.ErrnoException);\n          }\n        };\n\n        for (const pathToWatch of pathsToWatch) {\n          addWatcher(pathToWatch);\n        }\n\n        if (onWatchingFiles) {\n          onWatchingFiles();\n        }\n\n        function onError(err: Error): void {\n          if (terminated) {\n            return;\n          }\n\n          terminated = true;\n          reject(err);\n        }\n\n        function addWatcher(watchedPath: string): void {\n          const listener: (event: string, fileName: string) => void = changeListener(watchedPath);\n          const watcher: fs.FSWatcher = fs.watch(\n            watchedPath,\n            {\n              encoding: 'utf-8',\n              recursive: useNativeRecursiveWatch\n            },\n            listener\n          );\n          watchers.set(watchedPath, watcher);\n          watcher.on('error', (err) => {\n            watchers.delete(watchedPath);\n            onError(err);\n          });\n        }\n\n        function innerListener(root: string, event: string, fileName: string): void {\n          try {\n            if (terminated) {\n              return;\n            }\n\n            // Handling for added directories\n            if (!useNativeRecursiveWatch) {\n              const decodedName: string = fileName && fileName.toString();\n              const normalizedName: string = decodedName && Path.convertToSlashes(decodedName);\n              const fullName: string = normalizedName && `${root}/${normalizedName}`;\n\n              if (fullName && !watchers.has(fullName)) {\n                try {\n                  const stat: FileSystemStats = FileSystem.getStatistics(fullName);\n                  if (stat.isDirectory()) {\n                    addWatcher(fullName);\n                  }\n                } catch (err) {\n                  const code: string | undefined = (err as NodeJS.ErrnoException).code;\n\n                  if (code !== 'ENOENT' && code !== 'ENOTDIR') {\n                    throw err;\n                  }\n                }\n              }\n            }\n\n            // Use a timeout to debounce changes, e.g. bulk copying files into the directory while the watcher is running.\n            if (timeout) {\n              clearTimeout(timeout);\n            }\n\n            timeout = setTimeout(resolveIfChanged, debounceMilliseconds);\n          } catch (err) {\n            terminated = true;\n            reject(err as NodeJS.ErrnoException);\n          }\n        }\n\n        function changeListener(root: string): (event: string, fileName: string) => void {\n          return innerListener.bind(0, root);\n        }\n      }\n    );\n\n    const closePromises: Promise<void>[] = [];\n    for (const [watchedPath, watcher] of watchers) {\n      closePromises.push(\n        once(watcher, 'close').then(() => {\n          watchers.delete(watchedPath);\n        })\n      );\n      watcher.close();\n    }\n\n    await Promise.all(closePromises);\n\n    return watchedResult;\n  }\n\n  /**\n   * Determines which, if any, projects (within the selection) have new hashes for files that are not in .gitignore\n   */\n  private async _computeChanged(): Promise<IProjectChangeResult> {\n    const state: ProjectChangeAnalyzer = new ProjectChangeAnalyzer(this._rushConfiguration);\n\n    const previousState: ProjectChangeAnalyzer | undefined = this._previousState;\n\n    if (!previousState) {\n      return {\n        changedProjects: this._projectsToWatch,\n        state\n      };\n    }\n\n    const changedProjects: Set<RushConfigurationProject> = new Set();\n    for (const project of this._projectsToWatch) {\n      const [previous, current] = await Promise.all([\n        previousState._tryGetProjectDependenciesAsync(project, this._terminal),\n        state._tryGetProjectDependenciesAsync(project, this._terminal)\n      ]);\n\n      if (ProjectWatcher._haveProjectDepsChanged(previous!, current!)) {\n        // May need to detect if the nature of the change will break the process, e.g. changes to package.json\n        changedProjects.add(project);\n      }\n    }\n\n    return {\n      changedProjects,\n      state\n    };\n  }\n\n  private _commitChanges(state: ProjectChangeAnalyzer): void {\n    this._previousState = state;\n    if (!this._initialState) {\n      this._initialState = state;\n    }\n  }\n\n  /**\n   * Tests for inequality of the passed Maps. Order invariant.\n   *\n   * @returns `true` if the maps are different, `false` otherwise\n   */\n  private static _haveProjectDepsChanged(prev: Map<string, string>, next: Map<string, string>): boolean {\n    if (prev.size !== next.size) {\n      return true;\n    }\n\n    for (const [key, value] of prev) {\n      if (next.get(key) !== value) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static *_enumeratePathsToWatch(paths: Iterable<string>, prefixLength: number): Iterable<string> {\n    for (const path of paths) {\n      const rootSlashIndex: number = path.indexOf('/', prefixLength);\n\n      if (rootSlashIndex < 0) {\n        yield path;\n        return;\n      }\n\n      yield path.slice(0, rootSlashIndex);\n\n      let slashIndex: number = path.indexOf('/', rootSlashIndex + 1);\n      while (slashIndex >= 0) {\n        yield path.slice(0, slashIndex);\n        slashIndex = path.indexOf('/', slashIndex + 1);\n      }\n    }\n  }\n}\n"]}