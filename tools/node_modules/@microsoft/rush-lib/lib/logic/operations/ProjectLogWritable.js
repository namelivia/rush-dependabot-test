"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectLogWritable = void 0;
const node_core_library_1 = require("@rushstack/node-core-library");
const terminal_1 = require("@rushstack/terminal");
const PackageNameParsers_1 = require("../../api/PackageNameParsers");
const RushConstants_1 = require("../RushConstants");
class ProjectLogWritable extends terminal_1.TerminalWritable {
    constructor(project, terminal, logFilenameIdentifier) {
        super();
        this._logWriter = undefined;
        this._errorLogWriter = undefined;
        this._project = project;
        this._terminal = terminal;
        function getLogFilePaths(basePath, logFilenameIdentifier) {
            const unscopedProjectName = PackageNameParsers_1.PackageNameParsers.permissive.getUnscopedName(project.packageName);
            return {
                logPath: `${basePath}/${unscopedProjectName}.${logFilenameIdentifier}.log`,
                errorLogPath: `${basePath}/${unscopedProjectName}.${logFilenameIdentifier}.error.log`
            };
        }
        const projectFolder = this._project.projectFolder;
        const { logPath: legacyLogPath, errorLogPath: legacyErrorLogPath } = getLogFilePaths(projectFolder, 'build');
        // If the phased commands experiment is enabled, put logs under `rush-logs`
        if (project.rushConfiguration.experimentsConfiguration.configuration.phasedCommands) {
            // Delete the legacy logs
            node_core_library_1.FileSystem.deleteFile(legacyLogPath);
            node_core_library_1.FileSystem.deleteFile(legacyErrorLogPath);
            const logPathPrefix = `${projectFolder}/${RushConstants_1.RushConstants.rushLogsFolderName}`;
            node_core_library_1.FileSystem.ensureFolder(logPathPrefix);
            const { logPath, errorLogPath } = getLogFilePaths(logPathPrefix, logFilenameIdentifier);
            this._logPath = logPath;
            this._errorLogPath = errorLogPath;
        }
        else {
            this._logPath = legacyLogPath;
            this._errorLogPath = legacyErrorLogPath;
        }
        node_core_library_1.FileSystem.deleteFile(this._logPath);
        node_core_library_1.FileSystem.deleteFile(this._errorLogPath);
        this._logWriter = node_core_library_1.FileWriter.open(this._logPath);
    }
    onWriteChunk(chunk) {
        if (!this._logWriter) {
            throw new node_core_library_1.InternalError('Output file was closed');
        }
        // Both stderr and stdout get written to *.<phaseName>.log
        this._logWriter.write(chunk.text);
        if (chunk.kind === "E" /* Stderr */) {
            // Only stderr gets written to *.<phaseName>.error.log
            if (!this._errorLogWriter) {
                this._errorLogWriter = node_core_library_1.FileWriter.open(this._errorLogPath);
            }
            this._errorLogWriter.write(chunk.text);
        }
    }
    onClose() {
        if (this._logWriter) {
            try {
                this._logWriter.close();
            }
            catch (error) {
                this._terminal.writeStderrLine('Failed to close file handle for ' + this._logWriter.filePath);
            }
            this._logWriter = undefined;
        }
        if (this._errorLogWriter) {
            try {
                this._errorLogWriter.close();
            }
            catch (error) {
                this._terminal.writeStderrLine('Failed to close file handle for ' + this._errorLogWriter.filePath);
            }
            this._errorLogWriter = undefined;
        }
    }
}
exports.ProjectLogWritable = ProjectLogWritable;
//# sourceMappingURL=ProjectLogWritable.js.map