"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperationExecutionManager = void 0;
const os = __importStar(require("os"));
const safe_1 = __importDefault(require("colors/safe"));
const terminal_1 = require("@rushstack/terminal");
const stream_collator_1 = require("@rushstack/stream-collator");
const node_core_library_1 = require("@rushstack/node-core-library");
const AsyncOperationQueue_1 = require("./AsyncOperationQueue");
const OperationStatus_1 = require("./OperationStatus");
const OperationExecutionRecord_1 = require("./OperationExecutionRecord");
/**
 * Format "======" lines for a shell window with classic 80 columns
 */
const ASCII_HEADER_WIDTH = 79;
/**
 * A class which manages the execution of a set of tasks with interdependencies.
 * Initially, and at the end of each task execution, all unblocked tasks
 * are added to a ready queue which is then executed. This is done continually until all
 * tasks are complete, or prematurely fails if any of the tasks fail.
 */
class OperationExecutionManager {
    constructor(operations, options) {
        this._streamCollator_onWriterActive = (writer) => {
            if (writer) {
                this._completedOperations++;
                // Format a header like this
                //
                // ==[ @rushstack/the-long-thing ]=================[ 1 of 1000 ]==
                // leftPart: "==[ @rushstack/the-long-thing "
                const leftPart = safe_1.default.gray('==[') + ' ' + safe_1.default.cyan(writer.taskName) + ' ';
                const leftPartLength = 4 + writer.taskName.length + 1;
                // rightPart: " 1 of 1000 ]=="
                const completedOfTotal = `${this._completedOperations} of ${this._totalOperations}`;
                const rightPart = ' ' + safe_1.default.white(completedOfTotal) + ' ' + safe_1.default.gray(']==');
                const rightPartLength = 1 + completedOfTotal.length + 4;
                // middlePart: "]=================["
                const twoBracketsLength = 2;
                const middlePartLengthMinusTwoBrackets = Math.max(ASCII_HEADER_WIDTH - (leftPartLength + rightPartLength + twoBracketsLength), 0);
                const middlePart = safe_1.default.gray(']' + '='.repeat(middlePartLengthMinusTwoBrackets) + '[');
                this._terminal.writeStdoutLine('\n' + leftPart + middlePart + rightPart);
                if (!this._quietMode) {
                    this._terminal.writeStdoutLine('');
                }
            }
        };
        const { quietMode, debugMode, parallelism, changedProjectsOnly } = options;
        this._completedOperations = 0;
        this._quietMode = quietMode;
        this._hasAnyFailures = false;
        this._hasAnyNonAllowedWarnings = false;
        this._changedProjectsOnly = changedProjectsOnly;
        // TERMINAL PIPELINE:
        //
        // streamCollator --> colorsNewlinesTransform --> StdioWritable
        //
        this._outputWritable = options.destination || terminal_1.StdioWritable.instance;
        this._colorsNewlinesTransform = new terminal_1.TextRewriterTransform({
            destination: this._outputWritable,
            normalizeNewlines: node_core_library_1.NewlineKind.OsDefault,
            removeColors: !safe_1.default.enabled
        });
        this._streamCollator = new stream_collator_1.StreamCollator({
            destination: this._colorsNewlinesTransform,
            onWriterActive: this._streamCollator_onWriterActive
        });
        this._terminal = this._streamCollator.terminal;
        // Convert the developer graph to the mutable execution graph
        const executionRecordContext = {
            streamCollator: this._streamCollator,
            debugMode,
            quietMode
        };
        let totalOperations = 0;
        const executionRecords = (this._executionRecords = new Map());
        for (const operation of operations) {
            const executionRecord = new OperationExecutionRecord_1.OperationExecutionRecord(operation, executionRecordContext);
            executionRecords.set(operation, executionRecord);
            if (!executionRecord.runner.silent) {
                // Only count non-silent operations
                totalOperations++;
            }
        }
        this._totalOperations = totalOperations;
        for (const [operation, consumer] of executionRecords) {
            for (const dependency of operation.dependencies) {
                const dependencyRecord = executionRecords.get(dependency);
                if (!dependencyRecord) {
                    throw new Error(`Operation "${consumer.name}" declares a dependency on operation "${dependency.name}" that is not in the set of operations to execute.`);
                }
                consumer.dependencies.add(dependencyRecord);
                dependencyRecord.consumers.add(consumer);
            }
        }
        const numberOfCores = os.cpus().length;
        if (parallelism) {
            if (parallelism === 'max') {
                this._parallelism = numberOfCores;
            }
            else {
                const parallelismAsNumber = Number(parallelism);
                if (typeof parallelism === 'string' && parallelism.trim().endsWith('%')) {
                    const parsedPercentage = Number(parallelism.trim().replace(/\%$/, ''));
                    if (parsedPercentage <= 0 || parsedPercentage > 100) {
                        throw new Error(`Invalid percentage value of '${parallelism}', value cannot be less than '0%' or more than '100%'`);
                    }
                    const workers = Math.floor((parallelismAsNumber / 100) * numberOfCores);
                    this._parallelism = Math.max(workers, 1);
                }
                else if (!isNaN(parallelismAsNumber)) {
                    this._parallelism = Math.max(parallelismAsNumber, 1);
                }
                else {
                    throw new Error(`Invalid parallelism value of '${parallelism}', expected a number, a percentage, or 'max'`);
                }
            }
        }
        else {
            // If an explicit parallelism number wasn't provided, then choose a sensible
            // default.
            if (os.platform() === 'win32') {
                // On desktop Windows, some people have complained that their system becomes
                // sluggish if Rush is using all the CPU cores.  Leave one thread for
                // other operations. For CI environments, you can use the "max" argument to use all available cores.
                this._parallelism = Math.max(numberOfCores - 1, 1);
            }
            else {
                // Unix-like operating systems have more balanced scheduling, so default
                // to the number of CPU cores
                this._parallelism = numberOfCores;
            }
        }
    }
    /**
     * Executes all operations which have been registered, returning a promise which is resolved when all the
     * operations are completed successfully, or rejects when any operation fails.
     */
    async executeAsync() {
        this._completedOperations = 0;
        const totalOperations = this._totalOperations;
        if (!this._quietMode) {
            const plural = totalOperations === 1 ? '' : 's';
            this._terminal.writeStdoutLine(`Selected ${totalOperations} operation${plural}:`);
            const nonSilentOperations = [];
            for (const record of this._executionRecords.values()) {
                if (!record.runner.silent) {
                    nonSilentOperations.push(record.name);
                }
            }
            nonSilentOperations.sort();
            for (const name of nonSilentOperations) {
                this._terminal.writeStdoutLine(`  ${name}`);
            }
            this._terminal.writeStdoutLine('');
        }
        this._terminal.writeStdoutLine(`Executing a maximum of ${this._parallelism} simultaneous processes...`);
        const maxParallelism = Math.min(totalOperations, this._parallelism);
        const prioritySort = (a, b) => {
            return a.criticalPathLength - b.criticalPathLength;
        };
        const executionQueue = new AsyncOperationQueue_1.AsyncOperationQueue(this._executionRecords.values(), prioritySort);
        // This function is a callback because it may write to the collatedWriter before
        // operation.executeAsync returns (and cleans up the writer)
        const onOperationComplete = (record) => {
            this._onOperationComplete(record);
        };
        await node_core_library_1.Async.forEachAsync(executionQueue, async (operation) => {
            await operation.executeAsync(onOperationComplete);
        }, {
            concurrency: maxParallelism
        });
        const status = this._hasAnyFailures
            ? OperationStatus_1.OperationStatus.Failure
            : this._hasAnyNonAllowedWarnings
                ? OperationStatus_1.OperationStatus.SuccessWithWarning
                : OperationStatus_1.OperationStatus.Success;
        return {
            operationResults: this._executionRecords,
            status
        };
    }
    /**
     * Handles the result of the operation and propagates any relevant effects.
     */
    _onOperationComplete(record) {
        var _a;
        const { runner, name, status } = record;
        let blockCacheWrite = !runner.isCacheWriteAllowed;
        let blockSkip = !runner.isSkipAllowed;
        const silent = runner.silent;
        switch (status) {
            /**
             * This operation failed. Mark it as such and all reachable dependents as blocked.
             */
            case OperationStatus_1.OperationStatus.Failure: {
                // Failed operations get reported, even if silent.
                // Generally speaking, silent operations shouldn't be able to fail, so this is a safety measure.
                const message = (_a = record.error) === null || _a === void 0 ? void 0 : _a.message;
                // This creates the writer, so don't do this globally
                const { terminal } = record.collatedWriter;
                if (message) {
                    terminal.writeStderrLine(message);
                }
                terminal.writeStderrLine(safe_1.default.red(`"${name}" failed to build.`));
                const blockedQueue = new Set(record.consumers);
                for (const blockedRecord of blockedQueue) {
                    if (blockedRecord.status === OperationStatus_1.OperationStatus.Ready) {
                        this._completedOperations++;
                        // Now that we have the concept of architectural no-ops, we could implement this by replacing
                        // {blockedRecord.runner} with a no-op that sets status to Blocked and logs the blocking
                        // operations. However, the existing behavior is a bit simpler, so keeping that for now.
                        if (!blockedRecord.runner.silent) {
                            terminal.writeStdoutLine(`"${blockedRecord.name}" is blocked by "${name}".`);
                        }
                        blockedRecord.status = OperationStatus_1.OperationStatus.Blocked;
                        for (const dependent of blockedRecord.consumers) {
                            blockedQueue.add(dependent);
                        }
                    }
                }
                this._hasAnyFailures = true;
                break;
            }
            /**
             * This operation was restored from the build cache.
             */
            case OperationStatus_1.OperationStatus.FromCache: {
                if (!silent) {
                    record.collatedWriter.terminal.writeStdoutLine(safe_1.default.green(`"${name}" was restored from the build cache.`));
                }
                break;
            }
            /**
             * This operation was skipped via legacy change detection.
             */
            case OperationStatus_1.OperationStatus.Skipped: {
                if (!silent) {
                    record.collatedWriter.terminal.writeStdoutLine(safe_1.default.green(`"${name}" was skipped.`));
                }
                // Skipping means cannot guarantee integrity, so prevent cache writes in dependents.
                blockCacheWrite = true;
                break;
            }
            /**
             * This operation intentionally didn't do anything.
             */
            case OperationStatus_1.OperationStatus.NoOp: {
                if (!silent) {
                    record.collatedWriter.terminal.writeStdoutLine(safe_1.default.gray(`"${name}" did not define any work.`));
                }
                break;
            }
            case OperationStatus_1.OperationStatus.Success: {
                if (!silent) {
                    record.collatedWriter.terminal.writeStdoutLine(safe_1.default.green(`"${name}" completed successfully in ${record.stopwatch.toString()}.`));
                }
                // Legacy incremental build, if asked, prevent skip in dependents if the operation executed.
                blockSkip || (blockSkip = !this._changedProjectsOnly);
                break;
            }
            case OperationStatus_1.OperationStatus.SuccessWithWarning: {
                if (!silent) {
                    record.collatedWriter.terminal.writeStderrLine(safe_1.default.yellow(`"${name}" completed with warnings in ${record.stopwatch.toString()}.`));
                }
                // Legacy incremental build, if asked, prevent skip in dependents if the operation executed.
                blockSkip || (blockSkip = !this._changedProjectsOnly);
                this._hasAnyNonAllowedWarnings = this._hasAnyNonAllowedWarnings || !runner.warningsAreAllowed;
                break;
            }
        }
        // Apply status changes to direct dependents
        for (const item of record.consumers) {
            if (blockCacheWrite) {
                item.runner.isCacheWriteAllowed = false;
            }
            if (blockSkip) {
                item.runner.isSkipAllowed = false;
            }
            // Remove this operation from the dependencies, to unblock the scheduler
            item.dependencies.delete(record);
        }
    }
}
exports.OperationExecutionManager = OperationExecutionManager;
//# sourceMappingURL=OperationExecutionManager.js.map