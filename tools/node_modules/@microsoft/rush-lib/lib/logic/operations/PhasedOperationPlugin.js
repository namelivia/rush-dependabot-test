"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.PhasedOperationPlugin = void 0;
const Operation_1 = require("./Operation");
const OperationStatus_1 = require("./OperationStatus");
const NullOperationRunner_1 = require("./NullOperationRunner");
const PLUGIN_NAME = 'PhasedOperationPlugin';
/**
 * Core phased command plugin that provides the functionality for generating a base operation graph
 * from the set of selected projects and phases.
 */
class PhasedOperationPlugin {
    apply(hooks) {
        hooks.createOperations.tap(PLUGIN_NAME, createOperations);
    }
}
exports.PhasedOperationPlugin = PhasedOperationPlugin;
function createOperations(existingOperations, context) {
    const { projectsInUnknownState: changedProjects, phaseSelection, projectSelection } = context;
    const operationsWithWork = new Set();
    const operations = new Map();
    // Create tasks for selected phases and projects
    for (const phase of phaseSelection) {
        for (const project of projectSelection) {
            getOrCreateOperation(phase, project);
        }
    }
    // Recursively expand all consumers in the `operationsWithWork` set.
    for (const operation of operationsWithWork) {
        for (const consumer of operation.consumers) {
            operationsWithWork.add(consumer);
        }
    }
    for (const [key, operation] of operations) {
        if (!operationsWithWork.has(operation)) {
            // This operation is in scope, but did not change since it was last executed by the current command.
            // However, we have no state tracking across executions, so treat as unknown.
            operation.runner = new NullOperationRunner_1.NullOperationRunner({
                name: key,
                result: OperationStatus_1.OperationStatus.Skipped,
                silent: true
            });
        }
    }
    return existingOperations;
    // Binds phaseSelection, projectSelection, operations via closure
    function getOrCreateOperation(phase, project) {
        const key = getOperationKey(phase, project);
        let operation = operations.get(key);
        if (!operation) {
            operation = new Operation_1.Operation({
                project,
                phase
            });
            if (!phaseSelection.has(phase) || !projectSelection.has(project)) {
                // Not in scope. Mark skipped because state is unknown.
                operation.runner = new NullOperationRunner_1.NullOperationRunner({
                    name: key,
                    result: OperationStatus_1.OperationStatus.Skipped,
                    silent: true
                });
            }
            else if (changedProjects.has(project)) {
                operationsWithWork.add(operation);
            }
            operations.set(key, operation);
            existingOperations.add(operation);
            const { dependencies: { self, upstream } } = phase;
            for (const depPhase of self) {
                operation.addDependency(getOrCreateOperation(depPhase, project));
            }
            if (upstream.size) {
                const { dependencyProjects } = project;
                if (dependencyProjects.size) {
                    for (const depPhase of upstream) {
                        for (const dependencyProject of dependencyProjects) {
                            operation.addDependency(getOrCreateOperation(depPhase, dependencyProject));
                        }
                    }
                }
            }
        }
        return operation;
    }
}
// Convert the [IPhase, RushConfigurationProject] into a value suitable for use as a Map key
function getOperationKey(phase, project) {
    return `${project.packageName};${phase.name}`;
}
//# sourceMappingURL=PhasedOperationPlugin.js.map