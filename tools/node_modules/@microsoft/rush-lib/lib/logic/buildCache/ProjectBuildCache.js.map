{"version":3,"file":"ProjectBuildCache.js","sourceRoot":"","sources":["../../../src/logic/buildCache/ProjectBuildCache.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE3D,2CAA6B;AAC7B,oDAA4B;AAC5B,+CAAiC;AAEjC,yCAA2B;AAC3B,oEAAuF;AAKvF,oDAAiD;AAIjD,iEAA8D;AAC9D,yDAAsD;AAkBtD,MAAa,iBAAiB;IAe5B,YAAoB,OAA2B,EAAE,OAAkC;QACjF,MAAM,EAAE,uBAAuB,EAAE,oBAAoB,EAAE,wBAAwB,EAAE,GAAG,OAAO,CAAC;QAC5F,IAAI,CAAC,QAAQ,GAAG,oBAAoB,CAAC,OAAO,CAAC;QAC7C,IAAI,CAAC,wBAAwB,GAAG,uBAAuB,CAAC,kBAAkB,CAAC;QAC3E,IAAI,CAAC,wBAAwB,GAAG,uBAAuB,CAAC,kBAAkB,CAAC;QAC3E,IAAI,CAAC,kBAAkB,GAAG,uBAAuB,CAAC,iBAAiB,CAAC;QACpE,IAAI,CAAC,kBAAkB,GAAG,uBAAuB,CAAC,iBAAiB,CAAC;QACpE,IAAI,CAAC,yBAAyB,GAAG,wBAAwB,IAAI,EAAE,CAAC;QAChE,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC1B,CAAC;IAEO,MAAM,CAAC,iBAAiB,CAAC,QAAmB;QAClD,IAAI,iBAAiB,CAAC,kBAAkB,KAAK,IAAI,EAAE;YACjD,iBAAiB,CAAC,kBAAkB,GAAG,6BAAa,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;SACnF;QAED,OAAO,iBAAiB,CAAC,kBAAkB,CAAC;IAC9C,CAAC;IAEM,MAAM,CAAC,KAAK,CAAC,uBAAuB,CACzC,OAAkC;QAElC,MAAM,EAAE,QAAQ,EAAE,oBAAoB,EAAE,wBAAwB,EAAE,mBAAmB,EAAE,GAAG,OAAO,CAAC;QAClG,IAAI,CAAC,mBAAmB,EAAE;YACxB,OAAO,SAAS,CAAC;SAClB;QAED,IACE,CAAC,iBAAiB,CAAC,gBAAgB,CACjC,QAAQ,EACR,oBAAoB,EACpB,wBAAwB,EACxB,mBAAmB,CACpB,EACD;YACA,OAAO,SAAS,CAAC;SAClB;QAED,MAAM,OAAO,GAAuB,MAAM,iBAAiB,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;QACjF,OAAO,IAAI,iBAAiB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IACjD,CAAC;IAEO,MAAM,CAAC,gBAAgB,CAC7B,QAAmB,EACnB,oBAA8C,EAC9C,wBAA+C,EAC/C,mBAA6B;QAE7B,MAAM,+BAA+B,GAAW,wBAAI,CAAC,gBAAgB,CACnE,oBAAoB,CAAC,OAAO,CAAC,qBAAqB,CACnD,CAAC;QACF,MAAM,aAAa,GAAa,EAAE,CAAC;QACnC,IAAI,wBAAwB,EAAE;YAC5B,KAAK,MAAM,gBAAgB,IAAI,wBAAwB,EAAE;gBACvD,aAAa,CAAC,IAAI,CAAC,GAAG,+BAA+B,IAAI,gBAAgB,GAAG,CAAC,CAAC;aAC/E;SACF;QAED,MAAM,gBAAgB,GAAa,EAAE,CAAC;QACtC,KAAK,MAAM,IAAI,IAAI,mBAAmB,EAAE;YACtC,KAAK,MAAM,YAAY,IAAI,aAAa,EAAE;gBACxC,IAAI,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,EAAE;oBACjC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;iBAC7B;aACF;SACF;QAED,IAAI,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE;YAC/B,QAAQ,CAAC,gBAAgB,CACvB,qFAAqF;gBACnF,sCAAsC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CACtE,CAAC;YACF,OAAO,KAAK,CAAC;SACd;aAAM;YACL,OAAO,IAAI,CAAC;SACb;IACH,CAAC;IAEM,KAAK,CAAC,wBAAwB,CAAC,QAAmB;QACvD,MAAM,OAAO,GAAuB,IAAI,CAAC,QAAQ,CAAC;QAClD,IAAI,CAAC,OAAO,EAAE;YACZ,QAAQ,CAAC,gBAAgB,CAAC,kDAAkD,CAAC,CAAC;YAC9E,OAAO,KAAK,CAAC;SACd;QAED,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE;YAC5B,+DAA+D;YAC/D,OAAO,KAAK,CAAC;SACd;QAED,IAAI,mBAAmB,GACrB,MAAM,IAAI,CAAC,wBAAwB,CAAC,6BAA6B,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QACvF,IAAI,gBAAoC,CAAC;QACzC,IAAI,uBAA4C,CAAC;QACjD,IAAI,CAAC,mBAAmB,IAAI,IAAI,CAAC,wBAAwB,EAAE;YACzD,QAAQ,CAAC,gBAAgB,CACvB,sFAAsF,CACvF,CAAC;YAEF,gBAAgB,GAAG,MAAM,IAAI,CAAC,wBAAwB,CAAC,+BAA+B,CACpF,QAAQ,EACR,OAAO,CACR,CAAC;YACF,IAAI,gBAAgB,EAAE;gBACpB,IAAI;oBACF,mBAAmB,GAAG,MAAM,IAAI,CAAC,wBAAwB,CAAC,2BAA2B,CACnF,QAAQ,EACR,OAAO,EACP,gBAAgB,CACjB,CAAC;oBACF,uBAAuB,GAAG,IAAI,CAAC;iBAChC;gBAAC,OAAO,CAAC,EAAE;oBACV,uBAAuB,GAAG,KAAK,CAAC;iBACjC;aACF;SACF;QAED,IAAI,CAAC,mBAAmB,IAAI,CAAC,gBAAgB,EAAE;YAC7C,QAAQ,CAAC,gBAAgB,CAAC,gDAAgD,CAAC,CAAC;YAC5E,OAAO,KAAK,CAAC;SACd;QAED,QAAQ,CAAC,SAAS,CAAC,kBAAkB,CAAC,CAAC;QAEvC,MAAM,iBAAiB,GAAW,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC;QAE9D,uBAAuB;QACvB,QAAQ,CAAC,gBAAgB,CAAC,4BAA4B,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QACnG,MAAM,OAAO,CAAC,GAAG,CACf,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,CAAC,gBAAwB,EAAE,EAAE,CAC9D,8BAAU,CAAC,iBAAiB,CAAC,GAAG,iBAAiB,IAAI,gBAAgB,EAAE,CAAC,CACzE,CACF,CAAC;QAEF,MAAM,UAAU,GAA8B,MAAM,iBAAiB,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QAClG,IAAI,cAAc,GAAY,KAAK,CAAC;QACpC,IAAI,UAAU,IAAI,mBAAmB,EAAE;YACrC,MAAM,WAAW,GAAW,IAAI,CAAC,kBAAkB,EAAE,CAAC;YACtD,MAAM,WAAW,GAAW,MAAM,UAAU,CAAC,aAAa,CAAC;gBACzD,WAAW,EAAE,mBAAmB;gBAChC,gBAAgB,EAAE,iBAAiB;gBACnC,WAAW;aACZ,CAAC,CAAC;YACH,IAAI,WAAW,KAAK,CAAC,EAAE;gBACrB,cAAc,GAAG,IAAI,CAAC;aACvB;iBAAM;gBACL,QAAQ,CAAC,gBAAgB,CACvB,0BAA0B,WAAW,4CAA4C;oBAC/E,6FAA6F;oBAC7F,QAAQ,WAAW,kCAAkC,CACxD,CAAC;aACH;SACF;QAED,IAAI,CAAC,cAAc,EAAE;YACnB,IAAI,CAAC,gBAAgB,IAAI,mBAAmB,EAAE;gBAC5C,gBAAgB,GAAG,MAAM,8BAAU,CAAC,qBAAqB,CAAC,mBAAmB,CAAC,CAAC;aAChF;YAED,IAAI,CAAC,gBAAgB,EAAE;gBACrB,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;aAC/D;YAED,kFAAkF;YAClF,+CAA+C;YAC/C,MAAM,SAAS,GAAoB,GAAG,CAAC,OAAO,CAAC;gBAC7C,GAAG,EAAE,iBAAiB;gBACtB,iEAAiE;gBACjE,CAAC,EAAE,IAAI;aACR,CAAC,CAAC;YACH,IAAI;gBACF,MAAM,UAAU,GAAqB,gBAAM,CAAC,IAAI,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;gBACrE,SAAS,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;gBAClC,MAAM,UAAU,CAAC;gBACjB,cAAc,GAAG,IAAI,CAAC;aACvB;YAAC,OAAO,CAAC,EAAE;gBACV,cAAc,GAAG,KAAK,CAAC;aACxB;SACF;QAED,IAAI,cAAc,EAAE;YAClB,QAAQ,CAAC,SAAS,CAAC,oDAAoD,CAAC,CAAC;SAC1E;aAAM;YACL,QAAQ,CAAC,gBAAgB,CAAC,gDAAgD,CAAC,CAAC;SAC7E;QAED,IAAI,uBAAuB,KAAK,KAAK,EAAE;YACrC,QAAQ,CAAC,gBAAgB,CAAC,wEAAwE,CAAC,CAAC;SACrG;QAED,OAAO,cAAc,CAAC;IACxB,CAAC;IAEM,KAAK,CAAC,qBAAqB,CAAC,QAAmB;;QACpD,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE;YAC5B,+DAA+D;YAC/D,OAAO,IAAI,CAAC;SACb;QAED,MAAM,OAAO,GAAuB,IAAI,CAAC,QAAQ,CAAC;QAClD,IAAI,CAAC,OAAO,EAAE;YACZ,QAAQ,CAAC,gBAAgB,CAAC,kDAAkD,CAAC,CAAC;YAC9E,OAAO,KAAK,CAAC;SACd;QAED,MAAM,iBAAiB,GAAW,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC;QAC9D,MAAM,YAAY,GAA8B,MAAM,IAAI,CAAC,4BAA4B,CAAC,QAAQ,CAAC,CAAC;QAClG,IAAI,CAAC,YAAY,EAAE;YACjB,OAAO,KAAK,CAAC;SACd;QAED,QAAQ,CAAC,gBAAgB,CACvB,iCAAiC,YAAY,CAAC,yBAAyB,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CACrF,CAAC;QAEF,IAAI,mBAAuC,CAAC;QAE5C,MAAM,UAAU,GAA8B,MAAM,iBAAiB,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QAClG,IAAI,UAAU,EAAE;YACd,MAAM,wBAAwB,GAAW,IAAI,CAAC,wBAAwB,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;YAClG,uFAAuF;YACvF,MAAM,uBAAuB,GAAW,GAAG,wBAAwB,OAAO,CAAC;YAC3E,MAAM,WAAW,GAAW,IAAI,CAAC,kBAAkB,EAAE,CAAC;YACtD,MAAM,WAAW,GAAW,MAAM,UAAU,CAAC,qCAAqC,CAAC;gBACjF,WAAW,EAAE,uBAAuB;gBACpC,KAAK,EAAE,YAAY,CAAC,eAAe;gBACnC,OAAO,EAAE,IAAI,CAAC,QAAQ;gBACtB,WAAW;aACZ,CAAC,CAAC;YAEH,IAAI,WAAW,KAAK,CAAC,EAAE;gBACrB,+GAA+G;gBAC/G,MAAM,8BAAU,CAAC,SAAS,CAAC;oBACzB,UAAU,EAAE,uBAAuB;oBACnC,eAAe,EAAE,wBAAwB;oBACzC,SAAS,EAAE,IAAI;iBAChB,CAAC,CAAC;gBACH,mBAAmB,GAAG,wBAAwB,CAAC;aAChD;iBAAM;gBACL,QAAQ,CAAC,gBAAgB,CACvB,0BAA0B,WAAW,+CAA+C;oBAClF,uFAAuF;oBACvF,QAAQ,WAAW,kCAAkC,CACxD,CAAC;aACH;SACF;QAED,IAAI,gBAAoC,CAAC;QACzC,IAAI,yBAAsD,CAAC;QAC3D,IAAI,CAAC,mBAAmB,EAAE;YACxB,iGAAiG;YACjG,MAAM,SAAS,GAAoB,GAAG,CAAC,MAAM,CAC3C;gBACE,IAAI,EAAE,IAAI;gBACV,QAAQ,EAAE,IAAI;gBACd,MAAM,EAAE,IAAI;gBACZ,GAAG,EAAE,iBAAiB;aACvB,EACD,YAAY,CAAC,eAAe,CAC7B,CAAC;YACF,gBAAgB,GAAG,MAAM,qBAAS,CAAC,uBAAuB,CAAC,SAAS,CAAC,CAAC;YACtE,yBAAyB,GAAG,IAAI,CAAC,wBAAwB,CAAC,2BAA2B,CACnF,QAAQ,EACR,OAAO,EACP,gBAAgB,CACjB,CAAC;SACH;aAAM;YACL,yBAAyB,GAAG,OAAO,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC;SAClE;QAED,IAAI,yBAAuD,CAAC;QAE5D,uFAAuF;QACvF,+FAA+F;QAC/F,kCAAkC;QAElC,IAAI,MAAA,IAAI,CAAC,wBAAwB,0CAAE,mBAAmB,EAAE;YACtD,IAAI,CAAC,gBAAgB,EAAE;gBACrB,IAAI,mBAAmB,EAAE;oBACvB,gBAAgB,GAAG,MAAM,8BAAU,CAAC,qBAAqB,CAAC,mBAAmB,CAAC,CAAC;iBAChF;qBAAM;oBACL,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAC;iBACnE;aACF;YAED,yBAAyB,GAAG,MAAA,IAAI,CAAC,wBAAwB,0CAAE,2BAA2B,CACpF,QAAQ,EACR,OAAO,EACP,gBAAgB,CACjB,CAAC;SACH;QAED,IAAI,cAAsB,CAAC;QAC3B,IAAI,uBAAgC,CAAC;QACrC,IAAI,yBAAyB,EAAE;YAC7B,CAAC,uBAAuB,EAAE,cAAc,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;gBAC5D,yBAAyB;gBACzB,yBAAyB;aAC1B,CAAC,CAAC;SACJ;aAAM;YACL,uBAAuB,GAAG,IAAI,CAAC;YAC/B,cAAc,GAAG,MAAM,yBAAyB,CAAC;SAClD;QAED,MAAM,OAAO,GAAY,uBAAuB,IAAI,CAAC,CAAC,cAAc,CAAC;QACrE,IAAI,OAAO,EAAE;YACX,QAAQ,CAAC,SAAS,CAAC,+BAA+B,CAAC,CAAC;SACrD;aAAM,IAAI,CAAC,cAAc,IAAI,uBAAuB,EAAE;YACrD,QAAQ,CAAC,gBAAgB,CAAC,kCAAkC,CAAC,CAAC;SAC/D;aAAM,IAAI,cAAc,IAAI,CAAC,uBAAuB,EAAE;YACrD,QAAQ,CAAC,gBAAgB,CAAC,kCAAkC,CAAC,CAAC;SAC/D;aAAM;YACL,QAAQ,CAAC,gBAAgB,CAAC,mDAAmD,CAAC,CAAC;SAChF;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;;;OAIG;IACK,KAAK,CAAC,4BAA4B,CAAC,QAAmB;QAC5D,MAAM,iBAAiB,GAAW,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC;QAC9D,MAAM,eAAe,GAAa,EAAE,CAAC;QACrC,MAAM,KAAK,GAAuB,EAAE,CAAC;QAErC,MAAM,yBAAyB,GAAa,EAAE,CAAC;QAE/C,IAAI,gBAAgB,GAAY,KAAK,CAAC;QAEtC,qFAAqF;QACrF,SAAS,eAAe,CAAC,YAAoB,EAAE,QAAgB,EAAE,QAAsB;YACrF,KAAK,MAAM,KAAK,IAAI,QAAQ,EAAE;gBAC5B,MAAM,iBAAiB,GAAW,GAAG,YAAY,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC;gBAClE,IAAI,KAAK,CAAC,cAAc,EAAE,EAAE;oBAC1B,QAAQ,CAAC,UAAU,CACjB,sBAAsB,iBAAiB,0CAA0C,CAClF,CAAC;oBACF,gBAAgB,GAAG,IAAI,CAAC;iBACzB;qBAAM,IAAI,KAAK,CAAC,WAAW,EAAE,EAAE;oBAC9B,KAAK,CAAC,IAAI,CAAC,CAAC,iBAAiB,EAAE,GAAG,QAAQ,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;iBAC9D;qBAAM;oBACL,eAAe,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;iBACzC;aACF;QACH,CAAC;QAED,kCAAkC;QAClC,KAAK,MAAM,YAAY,IAAI,IAAI,CAAC,yBAAyB,EAAE;YACzD,MAAM,QAAQ,GAAW,GAAG,iBAAiB,IAAI,YAAY,EAAE,CAAC;YAChE,IAAI;gBACF,MAAM,QAAQ,GAAiB,MAAM,8BAAU,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;gBAC/E,eAAe,CAAC,YAAY,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;gBAClD,+BAA+B;gBAC/B,yBAAyB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;aAC9C;YAAC,OAAO,KAAK,EAAE;gBACd,IAAI,CAAC,8BAAU,CAAC,eAAe,CAAC,KAAc,CAAC,EAAE;oBAC/C,MAAM,KAAK,CAAC;iBACb;gBAED,2CAA2C;aAC5C;SACF;QAED,KAAK,MAAM,CAAC,YAAY,EAAE,QAAQ,CAAC,IAAI,KAAK,EAAE;YAC5C,MAAM,QAAQ,GAAiB,MAAM,8BAAU,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;YAC/E,eAAe,CAAC,YAAY,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;SACnD;QAED,IAAI,gBAAgB,EAAE;YACpB,2CAA2C;YAC3C,OAAO,SAAS,CAAC;SAClB;QAED,mCAAmC;QACnC,eAAe,CAAC,IAAI,EAAE,CAAC;QAEvB,OAAO;YACL,eAAe;YACf,yBAAyB;SAC1B,CAAC;IACJ,CAAC;IAEO,kBAAkB;QACxB,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,qBAAqB,EAAE,GAAG,IAAI,CAAC,QAAQ,MAAM,CAAC,CAAC;IAChF,CAAC;IAEO,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,OAAkC;QACjE,gEAAgE;QAChE,kFAAkF;QAClF,wCAAwC;QACxC,+EAA+E;QAC/E,8BAA8B;QAC9B,4EAA4E;QAC5E,gEAAgE;QAChE,iEAAiE;QACjE,mDAAmD;QACnD,oFAAoF;QACpF,6CAA6C;QAC7C,yCAAyC;QACzC,MAAM,qBAAqB,GAA0B,OAAO,CAAC,qBAAqB,CAAC;QACnF,MAAM,aAAa,GAAa,EAAE,CAAC;QACnC,MAAM,6BAA6B,GAAkC,IAAI,GAAG,EAA4B,CAAC;QACzG,IAAI,iBAAiB,GAAkC,IAAI,GAAG,EAA4B,CAAC;QAC3F,iBAAiB,CAAC,GAAG,CAAC,OAAO,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;QAE5D,OAAO,iBAAiB,CAAC,IAAI,GAAG,CAAC,EAAE;YACjC,MAAM,oBAAoB,GAAkC,IAAI,GAAG,EAA4B,CAAC;YAChG,KAAK,MAAM,gBAAgB,IAAI,iBAAiB,EAAE;gBAChD,6BAA6B,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;gBAEpD,MAAM,YAAY,GAAuB,MAAM,qBAAqB,CAAC,4BAA4B,CAC/F,gBAAgB,EAChB,OAAO,CAAC,QAAQ,CACjB,CAAC;gBACF,IAAI,CAAC,YAAY,EAAE;oBACjB,qEAAqE;oBACrE,OAAO,SAAS,CAAC;iBAClB;qBAAM;oBACL,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;oBACjC,KAAK,MAAM,UAAU,IAAI,gBAAgB,CAAC,kBAAkB,EAAE;wBAC5D,IAAI,CAAC,6BAA6B,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;4BAClD,oBAAoB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;yBACtC;qBACF;iBACF;aACF;YAED,iBAAiB,GAAG,oBAAoB,CAAC;SAC1C;QAED,MAAM,mBAAmB,GAAa,aAAa,CAAC,IAAI,EAAE,CAAC;QAC3D,MAAM,IAAI,GAAgB,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QACpD,gFAAgF;QAChF,IAAI,CAAC,MAAM,CAAC,GAAG,6BAAa,CAAC,iBAAiB,EAAE,CAAC,CAAC;QAClD,IAAI,CAAC,MAAM,CAAC,6BAAa,CAAC,aAAa,CAAC,CAAC;QACzC,MAAM,uBAAuB,GAAW,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,wBAAwB,CAAC,CAAC;QACzF,IAAI,CAAC,MAAM,CAAC,uBAAuB,CAAC,CAAC;QACrC,IAAI,CAAC,MAAM,CAAC,6BAAa,CAAC,aAAa,CAAC,CAAC;QACzC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QAC7B,IAAI,CAAC,MAAM,CAAC,6BAAa,CAAC,aAAa,CAAC,CAAC;QACzC,KAAK,MAAM,WAAW,IAAI,mBAAmB,EAAE;YAC7C,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;YACzB,IAAI,CAAC,MAAM,CAAC,6BAAa,CAAC,aAAa,CAAC,CAAC;SAC1C;QAED,MAAM,gBAAgB,GAAW,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAEpD,OAAO,OAAO,CAAC,uBAAuB,CAAC,eAAe,CAAC;YACrD,WAAW,EAAE,OAAO,CAAC,oBAAoB,CAAC,OAAO,CAAC,WAAW;YAC7D,gBAAgB;YAChB,SAAS,EAAE,OAAO,CAAC,SAAS;SAC7B,CAAC,CAAC;IACL,CAAC;;AAtdH,8CAudC;AAtdC;;;GAGG;AACY,oCAAkB,GAA8C,IAAI,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport events from 'events';\nimport * as crypto from 'crypto';\nimport type * as stream from 'stream';\nimport * as tar from 'tar';\nimport { FileSystem, Path, ITerminal, FolderItem } from '@rushstack/node-core-library';\n\nimport { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport { ProjectChangeAnalyzer } from '../ProjectChangeAnalyzer';\nimport { RushProjectConfiguration } from '../../api/RushProjectConfiguration';\nimport { RushConstants } from '../RushConstants';\nimport { BuildCacheConfiguration } from '../../api/BuildCacheConfiguration';\nimport { ICloudBuildCacheProvider } from './ICloudBuildCacheProvider';\nimport { FileSystemBuildCacheProvider } from './FileSystemBuildCacheProvider';\nimport { TarExecutable } from '../../utilities/TarExecutable';\nimport { Utilities } from '../../utilities/Utilities';\n\nexport interface IProjectBuildCacheOptions {\n  buildCacheConfiguration: BuildCacheConfiguration;\n  projectConfiguration: RushProjectConfiguration;\n  projectOutputFolderNames: ReadonlyArray<string>;\n  command: string;\n  trackedProjectFiles: string[] | undefined;\n  projectChangeAnalyzer: ProjectChangeAnalyzer;\n  terminal: ITerminal;\n  phaseName: string;\n}\n\ninterface IPathsToCache {\n  filteredOutputFolderNames: string[];\n  outputFilePaths: string[];\n}\n\nexport class ProjectBuildCache {\n  /**\n   * null === we haven't tried to initialize yet\n   * undefined === unable to initialize\n   */\n  private static _tarUtilityPromise: Promise<TarExecutable | undefined> | null = null;\n\n  private readonly _project: RushConfigurationProject;\n  private readonly _localBuildCacheProvider: FileSystemBuildCacheProvider;\n  private readonly _cloudBuildCacheProvider: ICloudBuildCacheProvider | undefined;\n  private readonly _buildCacheEnabled: boolean;\n  private readonly _cacheWriteEnabled: boolean;\n  private readonly _projectOutputFolderNames: ReadonlyArray<string>;\n  private _cacheId: string | undefined;\n\n  private constructor(cacheId: string | undefined, options: IProjectBuildCacheOptions) {\n    const { buildCacheConfiguration, projectConfiguration, projectOutputFolderNames } = options;\n    this._project = projectConfiguration.project;\n    this._localBuildCacheProvider = buildCacheConfiguration.localCacheProvider;\n    this._cloudBuildCacheProvider = buildCacheConfiguration.cloudCacheProvider;\n    this._buildCacheEnabled = buildCacheConfiguration.buildCacheEnabled;\n    this._cacheWriteEnabled = buildCacheConfiguration.cacheWriteEnabled;\n    this._projectOutputFolderNames = projectOutputFolderNames || [];\n    this._cacheId = cacheId;\n  }\n\n  private static _tryGetTarUtility(terminal: ITerminal): Promise<TarExecutable | undefined> {\n    if (ProjectBuildCache._tarUtilityPromise === null) {\n      ProjectBuildCache._tarUtilityPromise = TarExecutable.tryInitializeAsync(terminal);\n    }\n\n    return ProjectBuildCache._tarUtilityPromise;\n  }\n\n  public static async tryGetProjectBuildCache(\n    options: IProjectBuildCacheOptions\n  ): Promise<ProjectBuildCache | undefined> {\n    const { terminal, projectConfiguration, projectOutputFolderNames, trackedProjectFiles } = options;\n    if (!trackedProjectFiles) {\n      return undefined;\n    }\n\n    if (\n      !ProjectBuildCache._validateProject(\n        terminal,\n        projectConfiguration,\n        projectOutputFolderNames,\n        trackedProjectFiles\n      )\n    ) {\n      return undefined;\n    }\n\n    const cacheId: string | undefined = await ProjectBuildCache._getCacheId(options);\n    return new ProjectBuildCache(cacheId, options);\n  }\n\n  private static _validateProject(\n    terminal: ITerminal,\n    projectConfiguration: RushProjectConfiguration,\n    projectOutputFolderNames: ReadonlyArray<string>,\n    trackedProjectFiles: string[]\n  ): boolean {\n    const normalizedProjectRelativeFolder: string = Path.convertToSlashes(\n      projectConfiguration.project.projectRelativeFolder\n    );\n    const outputFolders: string[] = [];\n    if (projectOutputFolderNames) {\n      for (const outputFolderName of projectOutputFolderNames) {\n        outputFolders.push(`${normalizedProjectRelativeFolder}/${outputFolderName}/`);\n      }\n    }\n\n    const inputOutputFiles: string[] = [];\n    for (const file of trackedProjectFiles) {\n      for (const outputFolder of outputFolders) {\n        if (file.startsWith(outputFolder)) {\n          inputOutputFiles.push(file);\n        }\n      }\n    }\n\n    if (inputOutputFiles.length > 0) {\n      terminal.writeWarningLine(\n        'Unable to use build cache. The following files are used to calculate project state ' +\n          `and are considered project output: ${inputOutputFiles.join(', ')}`\n      );\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  public async tryRestoreFromCacheAsync(terminal: ITerminal): Promise<boolean> {\n    const cacheId: string | undefined = this._cacheId;\n    if (!cacheId) {\n      terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');\n      return false;\n    }\n\n    if (!this._buildCacheEnabled) {\n      // Skip reading local and cloud build caches, without any noise\n      return false;\n    }\n\n    let localCacheEntryPath: string | undefined =\n      await this._localBuildCacheProvider.tryGetCacheEntryPathByIdAsync(terminal, cacheId);\n    let cacheEntryBuffer: Buffer | undefined;\n    let updateLocalCacheSuccess: boolean | undefined;\n    if (!localCacheEntryPath && this._cloudBuildCacheProvider) {\n      terminal.writeVerboseLine(\n        'This project was not found in the local build cache. Querying the cloud build cache.'\n      );\n\n      cacheEntryBuffer = await this._cloudBuildCacheProvider.tryGetCacheEntryBufferByIdAsync(\n        terminal,\n        cacheId\n      );\n      if (cacheEntryBuffer) {\n        try {\n          localCacheEntryPath = await this._localBuildCacheProvider.trySetCacheEntryBufferAsync(\n            terminal,\n            cacheId,\n            cacheEntryBuffer\n          );\n          updateLocalCacheSuccess = true;\n        } catch (e) {\n          updateLocalCacheSuccess = false;\n        }\n      }\n    }\n\n    if (!localCacheEntryPath && !cacheEntryBuffer) {\n      terminal.writeVerboseLine('This project was not found in the build cache.');\n      return false;\n    }\n\n    terminal.writeLine('Build cache hit.');\n\n    const projectFolderPath: string = this._project.projectFolder;\n\n    // Purge output folders\n    terminal.writeVerboseLine(`Clearing cached folders: ${this._projectOutputFolderNames.join(', ')}`);\n    await Promise.all(\n      this._projectOutputFolderNames.map((outputFolderName: string) =>\n        FileSystem.deleteFolderAsync(`${projectFolderPath}/${outputFolderName}`)\n      )\n    );\n\n    const tarUtility: TarExecutable | undefined = await ProjectBuildCache._tryGetTarUtility(terminal);\n    let restoreSuccess: boolean = false;\n    if (tarUtility && localCacheEntryPath) {\n      const logFilePath: string = this._getTarLogFilePath();\n      const tarExitCode: number = await tarUtility.tryUntarAsync({\n        archivePath: localCacheEntryPath,\n        outputFolderPath: projectFolderPath,\n        logFilePath\n      });\n      if (tarExitCode === 0) {\n        restoreSuccess = true;\n      } else {\n        terminal.writeWarningLine(\n          `\"tar\" exited with code ${tarExitCode} while attempting to restore cache entry. ` +\n            'Rush will attempt to extract from the cache entry with a JavaScript implementation of tar. ' +\n            `See \"${logFilePath}\" for logs from the tar process.`\n        );\n      }\n    }\n\n    if (!restoreSuccess) {\n      if (!cacheEntryBuffer && localCacheEntryPath) {\n        cacheEntryBuffer = await FileSystem.readFileToBufferAsync(localCacheEntryPath);\n      }\n\n      if (!cacheEntryBuffer) {\n        throw new Error('Expected the cache entry buffer to be set.');\n      }\n\n      // If we don't have tar on the PATH, if we failed to update the local cache entry,\n      // or if the tar binary failed, untar in-memory\n      const tarStream: stream.Writable = tar.extract({\n        cwd: projectFolderPath,\n        // Set to true to omit writing mtime value for extracted entries.\n        m: true\n      });\n      try {\n        const tarPromise: Promise<unknown> = events.once(tarStream, 'drain');\n        tarStream.write(cacheEntryBuffer);\n        await tarPromise;\n        restoreSuccess = true;\n      } catch (e) {\n        restoreSuccess = false;\n      }\n    }\n\n    if (restoreSuccess) {\n      terminal.writeLine('Successfully restored output from the build cache.');\n    } else {\n      terminal.writeWarningLine('Unable to restore output from the build cache.');\n    }\n\n    if (updateLocalCacheSuccess === false) {\n      terminal.writeWarningLine('Unable to update the local build cache with data from the cloud cache.');\n    }\n\n    return restoreSuccess;\n  }\n\n  public async trySetCacheEntryAsync(terminal: ITerminal): Promise<boolean> {\n    if (!this._cacheWriteEnabled) {\n      // Skip writing local and cloud build caches, without any noise\n      return true;\n    }\n\n    const cacheId: string | undefined = this._cacheId;\n    if (!cacheId) {\n      terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');\n      return false;\n    }\n\n    const projectFolderPath: string = this._project.projectFolder;\n    const filesToCache: IPathsToCache | undefined = await this._tryCollectPathsToCacheAsync(terminal);\n    if (!filesToCache) {\n      return false;\n    }\n\n    terminal.writeVerboseLine(\n      `Caching build output folders: ${filesToCache.filteredOutputFolderNames.join(', ')}`\n    );\n\n    let localCacheEntryPath: string | undefined;\n\n    const tarUtility: TarExecutable | undefined = await ProjectBuildCache._tryGetTarUtility(terminal);\n    if (tarUtility) {\n      const finalLocalCacheEntryPath: string = this._localBuildCacheProvider.getCacheEntryPath(cacheId);\n      // Derive the temp file from the destination path to ensure they are on the same volume\n      const tempLocalCacheEntryPath: string = `${finalLocalCacheEntryPath}.temp`;\n      const logFilePath: string = this._getTarLogFilePath();\n      const tarExitCode: number = await tarUtility.tryCreateArchiveFromProjectPathsAsync({\n        archivePath: tempLocalCacheEntryPath,\n        paths: filesToCache.outputFilePaths,\n        project: this._project,\n        logFilePath\n      });\n\n      if (tarExitCode === 0) {\n        // Move after the archive is finished so that if the process is interrupted we aren't left with an invalid file\n        await FileSystem.moveAsync({\n          sourcePath: tempLocalCacheEntryPath,\n          destinationPath: finalLocalCacheEntryPath,\n          overwrite: true\n        });\n        localCacheEntryPath = finalLocalCacheEntryPath;\n      } else {\n        terminal.writeWarningLine(\n          `\"tar\" exited with code ${tarExitCode} while attempting to create the cache entry. ` +\n            'Rush will attempt to create the cache entry with a JavaScript implementation of tar. ' +\n            `See \"${logFilePath}\" for logs from the tar process.`\n        );\n      }\n    }\n\n    let cacheEntryBuffer: Buffer | undefined;\n    let setLocalCacheEntryPromise: Promise<string> | undefined;\n    if (!localCacheEntryPath) {\n      // If we weren't able to create the cache entry with tar, try to do it with the \"tar\" NPM package\n      const tarStream: stream.Readable = tar.create(\n        {\n          gzip: true,\n          portable: true,\n          strict: true,\n          cwd: projectFolderPath\n        },\n        filesToCache.outputFilePaths\n      );\n      cacheEntryBuffer = await Utilities.readStreamToBufferAsync(tarStream);\n      setLocalCacheEntryPromise = this._localBuildCacheProvider.trySetCacheEntryBufferAsync(\n        terminal,\n        cacheId,\n        cacheEntryBuffer\n      );\n    } else {\n      setLocalCacheEntryPromise = Promise.resolve(localCacheEntryPath);\n    }\n\n    let setCloudCacheEntryPromise: Promise<boolean> | undefined;\n\n    // Note that \"writeAllowed\" settings (whether in config or environment) always apply to\n    // the configured CLOUD cache. If the cache is enabled, rush is always allowed to read from and\n    // write to the local build cache.\n\n    if (this._cloudBuildCacheProvider?.isCacheWriteAllowed) {\n      if (!cacheEntryBuffer) {\n        if (localCacheEntryPath) {\n          cacheEntryBuffer = await FileSystem.readFileToBufferAsync(localCacheEntryPath);\n        } else {\n          throw new Error('Expected the local cache entry path to be set.');\n        }\n      }\n\n      setCloudCacheEntryPromise = this._cloudBuildCacheProvider?.trySetCacheEntryBufferAsync(\n        terminal,\n        cacheId,\n        cacheEntryBuffer\n      );\n    }\n\n    let localCachePath: string;\n    let updateCloudCacheSuccess: boolean;\n    if (setCloudCacheEntryPromise) {\n      [updateCloudCacheSuccess, localCachePath] = await Promise.all([\n        setCloudCacheEntryPromise,\n        setLocalCacheEntryPromise\n      ]);\n    } else {\n      updateCloudCacheSuccess = true;\n      localCachePath = await setLocalCacheEntryPromise;\n    }\n\n    const success: boolean = updateCloudCacheSuccess && !!localCachePath;\n    if (success) {\n      terminal.writeLine('Successfully set cache entry.');\n    } else if (!localCachePath && updateCloudCacheSuccess) {\n      terminal.writeWarningLine('Unable to set local cache entry.');\n    } else if (localCachePath && !updateCloudCacheSuccess) {\n      terminal.writeWarningLine('Unable to set cloud cache entry.');\n    } else {\n      terminal.writeWarningLine('Unable to set both cloud and local cache entries.');\n    }\n\n    return success;\n  }\n\n  /**\n   * Walks the declared output folders of the project and collects a list of files.\n   * @returns The list of output files as project-relative paths, or `undefined` if a\n   *   symbolic link was encountered.\n   */\n  private async _tryCollectPathsToCacheAsync(terminal: ITerminal): Promise<IPathsToCache | undefined> {\n    const projectFolderPath: string = this._project.projectFolder;\n    const outputFilePaths: string[] = [];\n    const queue: [string, string][] = [];\n\n    const filteredOutputFolderNames: string[] = [];\n\n    let hasSymbolicLinks: boolean = false;\n\n    // Adds child directories to the queue, files to the path list, and bails on symlinks\n    function processChildren(relativePath: string, diskPath: string, children: FolderItem[]): void {\n      for (const child of children) {\n        const childRelativePath: string = `${relativePath}/${child.name}`;\n        if (child.isSymbolicLink()) {\n          terminal.writeError(\n            `Unable to include \"${childRelativePath}\" in build cache. It is a symbolic link.`\n          );\n          hasSymbolicLinks = true;\n        } else if (child.isDirectory()) {\n          queue.push([childRelativePath, `${diskPath}/${child.name}`]);\n        } else {\n          outputFilePaths.push(childRelativePath);\n        }\n      }\n    }\n\n    // Handle declared output folders.\n    for (const outputFolder of this._projectOutputFolderNames) {\n      const diskPath: string = `${projectFolderPath}/${outputFolder}`;\n      try {\n        const children: FolderItem[] = await FileSystem.readFolderItemsAsync(diskPath);\n        processChildren(outputFolder, diskPath, children);\n        // The folder exists, record it\n        filteredOutputFolderNames.push(outputFolder);\n      } catch (error) {\n        if (!FileSystem.isNotExistError(error as Error)) {\n          throw error;\n        }\n\n        // If the folder does not exist, ignore it.\n      }\n    }\n\n    for (const [relativePath, diskPath] of queue) {\n      const children: FolderItem[] = await FileSystem.readFolderItemsAsync(diskPath);\n      processChildren(relativePath, diskPath, children);\n    }\n\n    if (hasSymbolicLinks) {\n      // Symbolic links do not round-trip safely.\n      return undefined;\n    }\n\n    // Ensure stable output path order.\n    outputFilePaths.sort();\n\n    return {\n      outputFilePaths,\n      filteredOutputFolderNames\n    };\n  }\n\n  private _getTarLogFilePath(): string {\n    return path.join(this._project.projectRushTempFolder, `${this._cacheId}.log`);\n  }\n\n  private static async _getCacheId(options: IProjectBuildCacheOptions): Promise<string | undefined> {\n    // The project state hash is calculated in the following method:\n    // - The current project's hash (see ProjectChangeAnalyzer.getProjectStateHash) is\n    //   calculated and appended to an array\n    // - The current project's recursive dependency projects' hashes are calculated\n    //   and appended to the array\n    // - A SHA1 hash is created and the following data is fed into it, in order:\n    //   1. The JSON-serialized list of output folder names for this\n    //      project (see ProjectBuildCache._projectOutputFolderNames)\n    //   2. The command that will be run in the project\n    //   3. Each dependency project hash (from the array constructed in previous steps),\n    //      in sorted alphanumerical-sorted order\n    // - A hex digest of the hash is returned\n    const projectChangeAnalyzer: ProjectChangeAnalyzer = options.projectChangeAnalyzer;\n    const projectStates: string[] = [];\n    const projectsThatHaveBeenProcessed: Set<RushConfigurationProject> = new Set<RushConfigurationProject>();\n    let projectsToProcess: Set<RushConfigurationProject> = new Set<RushConfigurationProject>();\n    projectsToProcess.add(options.projectConfiguration.project);\n\n    while (projectsToProcess.size > 0) {\n      const newProjectsToProcess: Set<RushConfigurationProject> = new Set<RushConfigurationProject>();\n      for (const projectToProcess of projectsToProcess) {\n        projectsThatHaveBeenProcessed.add(projectToProcess);\n\n        const projectState: string | undefined = await projectChangeAnalyzer._tryGetProjectStateHashAsync(\n          projectToProcess,\n          options.terminal\n        );\n        if (!projectState) {\n          // If we hit any projects with unknown state, return unknown cache ID\n          return undefined;\n        } else {\n          projectStates.push(projectState);\n          for (const dependency of projectToProcess.dependencyProjects) {\n            if (!projectsThatHaveBeenProcessed.has(dependency)) {\n              newProjectsToProcess.add(dependency);\n            }\n          }\n        }\n      }\n\n      projectsToProcess = newProjectsToProcess;\n    }\n\n    const sortedProjectStates: string[] = projectStates.sort();\n    const hash: crypto.Hash = crypto.createHash('sha1');\n    // This value is used to force cache bust when the build cache algorithm changes\n    hash.update(`${RushConstants.buildCacheVersion}`);\n    hash.update(RushConstants.hashDelimiter);\n    const serializedOutputFolders: string = JSON.stringify(options.projectOutputFolderNames);\n    hash.update(serializedOutputFolders);\n    hash.update(RushConstants.hashDelimiter);\n    hash.update(options.command);\n    hash.update(RushConstants.hashDelimiter);\n    for (const projectHash of sortedProjectStates) {\n      hash.update(projectHash);\n      hash.update(RushConstants.hashDelimiter);\n    }\n\n    const projectStateHash: string = hash.digest('hex');\n\n    return options.buildCacheConfiguration.getCacheEntryId({\n      projectName: options.projectConfiguration.project.packageName,\n      projectStateHash,\n      phaseName: options.phaseName\n    });\n  }\n}\n"]}