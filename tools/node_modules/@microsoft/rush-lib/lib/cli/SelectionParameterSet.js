"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectionParameterSet = void 0;
const node_core_library_1 = require("@rushstack/node-core-library");
const Selection_1 = require("../logic/Selection");
const GitChangedProjectSelectorParser_1 = require("../logic/selectors/GitChangedProjectSelectorParser");
const NamedProjectSelectorParser_1 = require("../logic/selectors/NamedProjectSelectorParser");
const TagProjectSelectorParser_1 = require("../logic/selectors/TagProjectSelectorParser");
const VersionPolicyProjectSelectorParser_1 = require("../logic/selectors/VersionPolicyProjectSelectorParser");
/**
 * This class is provides the set of command line parameters used to select projects
 * based on dependencies.
 *
 * It is a separate component such that unrelated actions can share the same parameters.
 */
class SelectionParameterSet {
    constructor(rushConfiguration, action, gitOptions) {
        this._rushConfiguration = rushConfiguration;
        const selectorParsers = new Map();
        const nameSelectorParser = new NamedProjectSelectorParser_1.NamedProjectSelectorParser(rushConfiguration);
        selectorParsers.set('name', nameSelectorParser);
        selectorParsers.set('git', new GitChangedProjectSelectorParser_1.GitChangedProjectSelectorParser(rushConfiguration, gitOptions));
        selectorParsers.set('tag', new TagProjectSelectorParser_1.TagProjectSelectorParser(rushConfiguration));
        selectorParsers.set('version-policy', new VersionPolicyProjectSelectorParser_1.VersionPolicyProjectSelectorParser(rushConfiguration));
        this._selectorParserByScope = selectorParsers;
        const getSpecifierCompletions = async () => {
            const completions = ['.'];
            for (const [prefix, selector] of selectorParsers) {
                for (const completion of selector.getCompletions()) {
                    completions.push(`${prefix}:${completion}`);
                }
            }
            // Include completions from the name parser without a scope
            for (const completion of nameSelectorParser.getCompletions()) {
                completions.push(completion);
            }
            return completions;
        };
        this._toProject = action.defineStringListParameter({
            parameterLongName: '--to',
            parameterShortName: '-t',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--to" parameter expands this selection to include PROJECT and all its dependencies.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getSpecifierCompletions
        });
        this._toExceptProject = action.defineStringListParameter({
            parameterLongName: '--to-except',
            parameterShortName: '-T',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--to-except" parameter expands this selection to include all dependencies of PROJECT,' +
                ' but not PROJECT itself.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getSpecifierCompletions
        });
        this._fromProject = action.defineStringListParameter({
            parameterLongName: '--from',
            parameterShortName: '-f',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--from" parameter expands this selection to include PROJECT and all projects that depend on it,' +
                ' plus all dependencies of this set.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getSpecifierCompletions
        });
        this._onlyProject = action.defineStringListParameter({
            parameterLongName: '--only',
            parameterShortName: '-o',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--only" parameter expands this selection to include PROJECT; its dependencies are not added.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' Note that this parameter is "unsafe" as it may produce a selection that excludes some dependencies.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getSpecifierCompletions
        });
        this._impactedByProject = action.defineStringListParameter({
            parameterLongName: '--impacted-by',
            parameterShortName: '-i',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--impacted-by" parameter expands this selection to include PROJECT and any projects that' +
                ' depend on PROJECT (and thus might be broken by changes to PROJECT).' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' Note that this parameter is "unsafe" as it may produce a selection that excludes some dependencies.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getSpecifierCompletions
        });
        this._impactedByExceptProject = action.defineStringListParameter({
            parameterLongName: '--impacted-by-except',
            parameterShortName: '-I',
            argumentName: 'PROJECT',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' Each "--impacted-by-except" parameter works the same as "--impacted-by" except that PROJECT itself' +
                ' is not added to the selection.' +
                ' "." can be used as shorthand for the project in the current working directory.' +
                ' Note that this parameter is "unsafe" as it may produce a selection that excludes some dependencies.' +
                ' For details, refer to the website article "Selecting subsets of projects".',
            completions: getSpecifierCompletions
        });
        this._toVersionPolicy = action.defineStringListParameter({
            parameterLongName: '--to-version-policy',
            argumentName: 'VERSION_POLICY_NAME',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' The "--to-version-policy" parameter is equivalent to specifying "--to" for each of the projects' +
                ' belonging to VERSION_POLICY_NAME.' +
                ' For details, refer to the website article "Selecting subsets of projects".'
        });
        this._fromVersionPolicy = action.defineStringListParameter({
            parameterLongName: '--from-version-policy',
            argumentName: 'VERSION_POLICY_NAME',
            description: 'Normally all projects in the monorepo will be processed;' +
                ' adding this parameter will instead select a subset of projects.' +
                ' The "--from-version-policy" parameter is equivalent to specifying "--from" for each of the projects' +
                ' belonging to VERSION_POLICY_NAME.' +
                ' For details, refer to the website article "Selecting subsets of projects".'
        });
    }
    /**
     * Computes the set of selected projects based on all parameter values.
     *
     * If no parameters are specified, returns all projects in the Rush config file.
     */
    async getSelectedProjectsAsync(terminal) {
        // Hack out the old version-policy parameters
        for (const value of this._fromVersionPolicy.values) {
            this._fromProject.values.push(`version-policy:${value}`);
        }
        for (const value of this._toVersionPolicy.values) {
            this._toProject.values.push(`version-policy:${value}`);
        }
        const selectors = [
            this._onlyProject,
            this._fromProject,
            this._toProject,
            this._toExceptProject,
            this._impactedByProject,
            this._impactedByExceptProject
        ];
        // Check if any of the selection parameters have a value specified on the command line
        const isSelectionSpecified = selectors.some((param) => param.values.length > 0);
        // If no selection parameters are specified, return everything
        if (!isSelectionSpecified) {
            return new Set(this._rushConfiguration.projects);
        }
        const [
        // Include exactly these projects (--only)
        onlyProjects, 
        // Include all projects that depend on these projects, and all dependencies thereof
        fromProjects, 
        // --to
        toRaw, 
        // --to-except
        toExceptProjects, 
        // --impacted-by
        impactedByProjects, 
        // --impacted-by-except
        impactedByExceptProjects] = await Promise.all(selectors.map((param) => {
            return this._evaluateProjectParameterAsync(param, terminal);
        }));
        const selection = Selection_1.Selection.union(
        // Safe command line options
        Selection_1.Selection.expandAllDependencies(Selection_1.Selection.union(toRaw, Selection_1.Selection.directDependenciesOf(toExceptProjects), 
        // --from / --from-version-policy
        Selection_1.Selection.expandAllConsumers(fromProjects))), 
        // Unsafe command line option: --only
        onlyProjects, 
        // Unsafe command line options: --impacted-by, --impacted-by-except
        Selection_1.Selection.expandAllConsumers(Selection_1.Selection.union(impactedByProjects, Selection_1.Selection.directConsumersOf(impactedByExceptProjects))));
        return selection;
    }
    /**
     * Represents the selection as `--filter` parameters to pnpm.
     *
     * @remarks
     * This is a separate from the selection to allow the filters to be represented more concisely.
     *
     * @see https://pnpm.js.org/en/filtering
     */
    async getPnpmFilterArgumentsAsync(terminal) {
        const args = [];
        // Include exactly these projects (--only)
        for (const project of await this._evaluateProjectParameterAsync(this._onlyProject, terminal)) {
            args.push('--filter', project.packageName);
        }
        // Include all projects that depend on these projects, and all dependencies thereof
        const fromProjects = Selection_1.Selection.union(
        // --from
        await this._evaluateProjectParameterAsync(this._fromProject, terminal));
        // All specified projects and all projects that they depend on
        for (const project of Selection_1.Selection.union(
        // --to
        await this._evaluateProjectParameterAsync(this._toProject, terminal), 
        // --from / --from-version-policy
        Selection_1.Selection.expandAllConsumers(fromProjects))) {
            args.push('--filter', `${project.packageName}...`);
        }
        // --to-except
        // All projects that the project directly or indirectly declares as a dependency
        for (const project of await this._evaluateProjectParameterAsync(this._toExceptProject, terminal)) {
            args.push('--filter', `${project.packageName}^...`);
        }
        // --impacted-by
        // The project and all projects directly or indirectly declare it as a dependency
        for (const project of await this._evaluateProjectParameterAsync(this._impactedByProject, terminal)) {
            args.push('--filter', `...${project.packageName}`);
        }
        // --impacted-by-except
        // All projects that directly or indirectly declare the specified project as a dependency
        for (const project of await this._evaluateProjectParameterAsync(this._impactedByExceptProject, terminal)) {
            args.push('--filter', `...^${project.packageName}`);
        }
        return args;
    }
    /**
     * Usage telemetry for selection parameters. Only saved locally, and if requested in the config.
     */
    getTelemetry() {
        return {
            command_from: `${this._fromProject.values.length > 0}`,
            command_impactedBy: `${this._impactedByProject.values.length > 0}`,
            command_impactedByExcept: `${this._impactedByExceptProject.values.length > 0}`,
            command_only: `${this._onlyProject.values.length > 0}`,
            command_to: `${this._toProject.values.length > 0}`,
            command_toExcept: `${this._toExceptProject.values.length > 0}`,
            command_fromVersionPolicy: `${this._fromVersionPolicy.values.length > 0}`,
            command_toVersionPolicy: `${this._toVersionPolicy.values.length > 0}`
        };
    }
    /**
     * Computes the referents of parameters that accept a project identifier.
     * Handles '.', unscoped names, and scoped names.
     */
    async _evaluateProjectParameterAsync(listParameter, terminal) {
        const parameterName = listParameter.longName;
        const selection = new Set();
        for (const rawSelector of listParameter.values) {
            // Handle the special case of "current project" without a scope
            if (rawSelector === '.') {
                const packageJsonLookup = node_core_library_1.PackageJsonLookup.instance;
                const packageJson = packageJsonLookup.tryLoadPackageJsonFor(process.cwd());
                if (packageJson) {
                    const project = this._rushConfiguration.getProjectByName(packageJson.name);
                    if (project) {
                        selection.add(project);
                    }
                    else {
                        terminal.writeErrorLine('Rush is not currently running in a project directory specified in rush.json. ' +
                            `The "." value for the ${parameterName} parameter is not allowed.`);
                        throw new node_core_library_1.AlreadyReportedError();
                    }
                }
                else {
                    terminal.writeErrorLine('Rush is not currently running in a project directory. ' +
                        `The "." value for the ${parameterName} parameter is not allowed.`);
                    throw new node_core_library_1.AlreadyReportedError();
                }
                continue;
            }
            const scopeIndex = rawSelector.indexOf(':');
            const scope = scopeIndex < 0 ? 'name' : rawSelector.slice(0, scopeIndex);
            const unscopedSelector = scopeIndex < 0 ? rawSelector : rawSelector.slice(scopeIndex + 1);
            const handler = this._selectorParserByScope.get(scope);
            if (!handler) {
                terminal.writeErrorLine(`Unsupported selector prefix "${scope}" passed to "${parameterName}": "${rawSelector}".` +
                    ` Supported prefixes: ${Array.from(this._selectorParserByScope.keys(), (scope) => `"${scope}:"`).join(', ')}`);
                throw new node_core_library_1.AlreadyReportedError();
            }
            for (const project of await handler.evaluateSelectorAsync({
                unscopedSelector,
                terminal,
                parameterName
            })) {
                selection.add(project);
            }
        }
        return selection;
    }
}
exports.SelectionParameterSet = SelectionParameterSet;
//# sourceMappingURL=SelectionParameterSet.js.map