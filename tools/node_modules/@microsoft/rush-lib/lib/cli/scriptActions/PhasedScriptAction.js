"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PhasedScriptAction = void 0;
const os = __importStar(require("os"));
const safe_1 = __importDefault(require("colors/safe"));
const node_core_library_1 = require("@rushstack/node-core-library");
const PhasedCommandHooks_1 = require("../../pluginFramework/PhasedCommandHooks");
const SetupChecks_1 = require("../../logic/SetupChecks");
const Stopwatch_1 = require("../../utilities/Stopwatch");
const BaseScriptAction_1 = require("./BaseScriptAction");
const OperationExecutionManager_1 = require("../../logic/operations/OperationExecutionManager");
const RushConstants_1 = require("../../logic/RushConstants");
const EnvironmentConfiguration_1 = require("../../api/EnvironmentConfiguration");
const LastLinkFlag_1 = require("../../api/LastLinkFlag");
const BuildCacheConfiguration_1 = require("../../api/BuildCacheConfiguration");
const SelectionParameterSet_1 = require("../SelectionParameterSet");
const PhasedOperationPlugin_1 = require("../../logic/operations/PhasedOperationPlugin");
const ShellOperationRunnerPlugin_1 = require("../../logic/operations/ShellOperationRunnerPlugin");
const EventHooks_1 = require("../../api/EventHooks");
const ProjectChangeAnalyzer_1 = require("../../logic/ProjectChangeAnalyzer");
const OperationStatus_1 = require("../../logic/operations/OperationStatus");
const OperationResultSummarizerPlugin_1 = require("../../logic/operations/OperationResultSummarizerPlugin");
/**
 * This class implements phased commands which are run individually for each project in the repo,
 * possibly in parallel, and which may define multiple phases.
 *
 * @remarks
 * Phased commands can be defined via common/config/command-line.json.  Rush's predefined "build"
 * and "rebuild" commands are also modeled as phased commands with a single phase that invokes the npm
 * "build" script for each project.
 */
class PhasedScriptAction extends BaseScriptAction_1.BaseScriptAction {
    constructor(options) {
        super(options);
        this._enableParallelism = options.enableParallelism;
        this._isIncrementalBuildAllowed = options.incremental;
        this._disableBuildCache = options.disableBuildCache;
        this._initialPhases = options.initialPhases;
        this._watchPhases = options.watchPhases;
        this._alwaysWatch = options.alwaysWatch;
        this._alwaysInstall = options.alwaysInstall;
        this._knownPhases = options.phases;
        this.hooks = new PhasedCommandHooks_1.PhasedCommandHooks();
        // Generates the default operation graph
        new PhasedOperationPlugin_1.PhasedOperationPlugin().apply(this.hooks);
        // Applies the Shell Operation Runner to selected operations
        new ShellOperationRunnerPlugin_1.ShellOperationRunnerPlugin().apply(this.hooks);
    }
    async runAsync() {
        var _a, _b;
        if (this._alwaysInstall || ((_a = this._installParameter) === null || _a === void 0 ? void 0 : _a.value)) {
            const { doBasicInstallAsync } = await Promise.resolve().then(() => __importStar(require('../../logic/installManager/doBasicInstallAsync')));
            await doBasicInstallAsync({
                rushConfiguration: this.rushConfiguration,
                rushGlobalFolder: this.rushGlobalFolder,
                isDebug: this.parser.isDebug
            });
        }
        // TODO: Replace with last-install.flag when "rush link" and "rush unlink" are deprecated
        const lastLinkFlag = LastLinkFlag_1.LastLinkFlagFactory.getCommonTempFlag(this.rushConfiguration);
        if (!lastLinkFlag.isValid()) {
            const useWorkspaces = this.rushConfiguration.pnpmOptions && this.rushConfiguration.pnpmOptions.useWorkspaces;
            if (useWorkspaces) {
                throw new Error(`Link flag invalid.${os.EOL}Did you run "rush install" or "rush update"?`);
            }
            else {
                throw new Error(`Link flag invalid.${os.EOL}Did you run "rush link"?`);
            }
        }
        this._doBeforeTask();
        const stopwatch = Stopwatch_1.Stopwatch.start();
        const terminal = new node_core_library_1.Terminal(this.rushSession.terminalProvider);
        const showTimeline = this._timelineParameter ? this._timelineParameter.value : false;
        if (showTimeline) {
            const { ConsoleTimelinePlugin } = await Promise.resolve().then(() => __importStar(require('../../logic/operations/ConsoleTimelinePlugin')));
            new ConsoleTimelinePlugin(terminal).apply(this.hooks);
        }
        // Enable the standard summary
        new OperationResultSummarizerPlugin_1.OperationResultSummarizerPlugin(terminal).apply(this.hooks);
        const { hooks: sessionHooks } = this.rushSession;
        if (sessionHooks.runAnyPhasedCommand.isUsed()) {
            // Avoid the cost of compiling the hook if it wasn't tapped.
            await sessionHooks.runAnyPhasedCommand.promise(this);
        }
        const hookForAction = sessionHooks.runPhasedCommand.get(this.actionName);
        if (hookForAction) {
            // Run the more specific hook for a command with this name after the general hook
            await hookForAction.promise(this);
        }
        const isQuietMode = !this._verboseParameter.value;
        // if this is parallelizable, then use the value from the flag (undefined or a number),
        // if parallelism is not enabled, then restrict to 1 core
        const parallelism = this._enableParallelism ? this._parallelismParameter.value : '1';
        const changedProjectsOnly = this._isIncrementalBuildAllowed && this._changedProjectsOnly.value;
        let buildCacheConfiguration;
        if (!this._disableBuildCache) {
            buildCacheConfiguration = await BuildCacheConfiguration_1.BuildCacheConfiguration.tryLoadAsync(terminal, this.rushConfiguration, this.rushSession);
        }
        const projectSelection = await this._selectionParameters.getSelectedProjectsAsync(terminal);
        if (!projectSelection.size) {
            terminal.writeLine(safe_1.default.yellow(`The command line selection parameters did not match any projects.`));
            return;
        }
        const isWatch = ((_b = this._watchParameter) === null || _b === void 0 ? void 0 : _b.value) || this._alwaysWatch;
        const customParametersByName = new Map();
        for (const [configParameter, parserParameter] of this.customParameters) {
            customParametersByName.set(configParameter.longName, parserParameter);
        }
        const initialCreateOperationsContext = {
            buildCacheConfiguration,
            customParameters: customParametersByName,
            isIncrementalBuildAllowed: this._isIncrementalBuildAllowed,
            isInitial: true,
            isWatch,
            rushConfiguration: this.rushConfiguration,
            phaseSelection: new Set(this._initialPhases),
            projectChangeAnalyzer: new ProjectChangeAnalyzer_1.ProjectChangeAnalyzer(this.rushConfiguration),
            projectSelection,
            projectsInUnknownState: projectSelection
        };
        const executionManagerOptions = {
            quietMode: isQuietMode,
            debugMode: this.parser.isDebug,
            parallelism,
            changedProjectsOnly
        };
        const internalOptions = {
            initialCreateOperationsContext,
            executionManagerOptions,
            stopwatch,
            terminal
        };
        await this._runInitialPhases(internalOptions);
        if (isWatch) {
            if (buildCacheConfiguration) {
                // Cache writes are not supported during watch mode, only reads.
                buildCacheConfiguration.cacheWriteEnabled = false;
            }
            await this._runWatchPhases(internalOptions);
        }
    }
    async _runInitialPhases(options) {
        const { initialCreateOperationsContext, executionManagerOptions, stopwatch, terminal } = options;
        const operations = await this.hooks.createOperations.promise(new Set(), initialCreateOperationsContext);
        const initialOptions = {
            createOperationsContext: initialCreateOperationsContext,
            ignoreHooks: false,
            operations,
            stopwatch,
            executionManagerOptions,
            terminal
        };
        await this._executeOperations(initialOptions);
    }
    /**
     * Runs the command in watch mode. Fundamentally is a simple loop:
     * 1) Wait for a change to one or more projects in the selection
     * 2) Invoke the command on the changed projects, and, if applicable, impacted projects
     *    Uses the same algorithm as --impacted-by
     * 3) Goto (1)
     */
    async _runWatchPhases(options) {
        const { initialCreateOperationsContext, executionManagerOptions, stopwatch, terminal } = options;
        const phaseSelection = new Set(this._watchPhases);
        const { projectChangeAnalyzer: initialState, projectSelection: projectsToWatch } = initialCreateOperationsContext;
        // Use async import so that we don't pay the cost for sync builds
        const { ProjectWatcher } = await Promise.resolve().then(() => __importStar(require('../../logic/ProjectWatcher')));
        const projectWatcher = new ProjectWatcher({
            debounceMilliseconds: 1000,
            rushConfiguration: this.rushConfiguration,
            projectsToWatch,
            terminal,
            initialState
        });
        const onWaitingForChanges = () => {
            // Allow plugins to display their own messages when waiting for changes.
            this.hooks.waitingForChanges.call();
            // Report so that the developer can always see that it is in watch mode as the latest console line.
            terminal.writeLine(`Watching for changes to ${projectsToWatch.size} ${projectsToWatch.size === 1 ? 'project' : 'projects'}. Press Ctrl+C to exit.`);
        };
        // Loop until Ctrl+C
        // eslint-disable-next-line no-constant-condition
        while (true) {
            // On the initial invocation, this promise will return immediately with the full set of projects
            const { changedProjects, state } = await projectWatcher.waitForChange(onWaitingForChanges);
            if (stopwatch.state === Stopwatch_1.StopwatchState.Stopped) {
                // Clear and reset the stopwatch so that we only report time from a single execution at a time
                stopwatch.reset();
                stopwatch.start();
            }
            terminal.writeLine(`Detected changes in ${changedProjects.size} project${changedProjects.size === 1 ? '' : 's'}:`);
            const names = [...changedProjects].map((x) => x.packageName).sort();
            for (const name of names) {
                terminal.writeLine(`    ${safe_1.default.cyan(name)}`);
            }
            // Account for consumer relationships
            const createOperationsContext = Object.assign(Object.assign({}, initialCreateOperationsContext), { isInitial: false, projectChangeAnalyzer: state, projectsInUnknownState: changedProjects, phaseSelection });
            const operations = await this.hooks.createOperations.promise(new Set(), createOperationsContext);
            const executeOptions = {
                createOperationsContext,
                // For now, don't run pre-build or post-build in watch mode
                ignoreHooks: true,
                operations,
                stopwatch,
                executionManagerOptions,
                terminal
            };
            try {
                // Delegate the the underlying command, for only the projects that need reprocessing
                await this._executeOperations(executeOptions);
            }
            catch (err) {
                // In watch mode, we want to rebuild even if the original build failed.
                if (!(err instanceof node_core_library_1.AlreadyReportedError)) {
                    throw err;
                }
            }
        }
    }
    onDefineParameters() {
        if (this._enableParallelism) {
            this._parallelismParameter = this.defineStringParameter({
                parameterLongName: '--parallelism',
                parameterShortName: '-p',
                argumentName: 'COUNT',
                environmentVariable: EnvironmentConfiguration_1.EnvironmentVariableNames.RUSH_PARALLELISM,
                description: 'Specifies the maximum number of concurrent processes to launch during a build.' +
                    ' The COUNT should be a positive integer, a percentage value (eg. "50%%") or the word "max"' +
                    ' to specify a count that is equal to the number of CPU cores. If this parameter is omitted,' +
                    ' then the default value depends on the operating system and number of CPU cores.'
            });
            this._timelineParameter = this.defineFlagParameter({
                parameterLongName: '--timeline',
                description: 'After the build is complete, print additional statistics and CPU usage information,' +
                    ' including an ASCII chart of the start and stop times for each operation.'
            });
        }
        this._selectionParameters = new SelectionParameterSet_1.SelectionParameterSet(this.rushConfiguration, this, {
            // Include lockfile processing since this expands the selection, and we need to select
            // at least the same projects selected with the same query to "rush build"
            includeExternalDependencies: true,
            // Enable filtering to reduce evaluation cost
            enableFiltering: true
        });
        this._verboseParameter = this.defineFlagParameter({
            parameterLongName: '--verbose',
            parameterShortName: '-v',
            description: 'Display the logs during the build, rather than just displaying the build status summary'
        });
        if (this._isIncrementalBuildAllowed) {
            this._changedProjectsOnly = this.defineFlagParameter({
                parameterLongName: '--changed-projects-only',
                parameterShortName: '-c',
                description: 'Normally the incremental build logic will rebuild changed projects as well as' +
                    ' any projects that directly or indirectly depend on a changed project. Specify "--changed-projects-only"' +
                    ' to ignore dependent projects, only rebuilding those projects whose files were changed.' +
                    ' Note that this parameter is "unsafe"; it is up to the developer to ensure that the ignored projects' +
                    ' are okay to ignore.'
            });
        }
        this._ignoreHooksParameter = this.defineFlagParameter({
            parameterLongName: '--ignore-hooks',
            description: `Skips execution of the "eventHooks" scripts defined in rush.json. Make sure you know what you are skipping.`
        });
        if (this._watchPhases.size > 0 && !this._alwaysWatch) {
            // Only define the parameter if it has an effect.
            this._watchParameter = this.defineFlagParameter({
                parameterLongName: '--watch',
                description: `Starts a file watcher after initial execution finishes. Will run the following phases on affected projects: ${Array.from(this._watchPhases, (phase) => phase.name).join(', ')}`
            });
        }
        // If `this._alwaysInstall === undefined`, Rush does not define the parameter
        // but a repository may still define a custom parameter with the same name.
        if (this._alwaysInstall === false) {
            this._installParameter = this.defineFlagParameter({
                parameterLongName: '--install',
                description: 'Normally a phased command expects "rush install" to have been manually run first. If this flag is specified, ' +
                    'Rush will automatically perform an install before processing the current command.'
            });
        }
        this.defineScriptParameters();
        for (const [{ associatedPhases }, tsCommandLineParameter] of this.customParameters) {
            if (associatedPhases) {
                for (const phaseName of associatedPhases) {
                    const phase = this._knownPhases.get(phaseName);
                    if (!phase) {
                        throw new node_core_library_1.InternalError(`Could not find a phase matching ${phaseName}.`);
                    }
                    phase.associatedParameters.add(tsCommandLineParameter);
                }
            }
        }
    }
    /**
     * Runs a set of operations and reports the results.
     */
    async _executeOperations(options) {
        var _a;
        const { executionManagerOptions, ignoreHooks, operations, stopwatch, terminal } = options;
        const executionManager = new OperationExecutionManager_1.OperationExecutionManager(operations, executionManagerOptions);
        const { isInitial, isWatch } = options.createOperationsContext;
        let success = false;
        let result;
        try {
            result = await executionManager.executeAsync();
            success = result.status === OperationStatus_1.OperationStatus.Success;
            await this.hooks.afterExecuteOperations.promise(result, options.createOperationsContext);
            stopwatch.stop();
            const message = `rush ${this.actionName} (${stopwatch.toString()})`;
            if (result.status === OperationStatus_1.OperationStatus.Success) {
                terminal.writeLine(safe_1.default.green(message));
            }
            else {
                terminal.writeLine(message);
            }
        }
        catch (error) {
            success = false;
            stopwatch.stop();
            if (error instanceof node_core_library_1.AlreadyReportedError) {
                terminal.writeLine(`rush ${this.actionName} (${stopwatch.toString()})`);
            }
            else {
                if (error && error.message) {
                    if (this.parser.isDebug) {
                        terminal.writeErrorLine('Error: ' + error.stack);
                    }
                    else {
                        terminal.writeErrorLine('Error: ' + error.message);
                    }
                }
                terminal.writeErrorLine(safe_1.default.red(`rush ${this.actionName} - Errors! (${stopwatch.toString()})`));
            }
        }
        if (!ignoreHooks) {
            this._doAfterTask();
        }
        if (this.parser.telemetry) {
            const extraData = Object.assign(Object.assign(Object.assign({}, this._selectionParameters.getTelemetry()), this.getParameterStringMap()), { isWatch,
                // Fields specific to the current operation set
                isInitial, countAll: 0, countSuccess: 0, countSuccessWithWarnings: 0, countFailure: 0, countBlocked: 0, countFromCache: 0, countSkipped: 0, countNoOp: 0 });
            if (result) {
                for (const [operation, operationResult] of result.operationResults) {
                    if ((_a = operation.runner) === null || _a === void 0 ? void 0 : _a.silent) {
                        // Architectural operation. Ignore.
                        continue;
                    }
                    extraData.countAll++;
                    switch (operationResult.status) {
                        case OperationStatus_1.OperationStatus.Success:
                            extraData.countSuccess++;
                            break;
                        case OperationStatus_1.OperationStatus.SuccessWithWarning:
                            extraData.countSuccessWithWarnings++;
                            break;
                        case OperationStatus_1.OperationStatus.Failure:
                            extraData.countFailure++;
                            break;
                        case OperationStatus_1.OperationStatus.Blocked:
                            extraData.countBlocked++;
                            break;
                        case OperationStatus_1.OperationStatus.FromCache:
                            extraData.countFromCache++;
                            break;
                        case OperationStatus_1.OperationStatus.Skipped:
                            extraData.countSkipped++;
                            break;
                        case OperationStatus_1.OperationStatus.NoOp:
                            extraData.countNoOp++;
                            break;
                        default:
                            // Do nothing.
                            break;
                    }
                }
            }
            this.parser.telemetry.log({
                name: this.actionName,
                durationInSeconds: stopwatch.duration,
                result: success ? 'Succeeded' : 'Failed',
                extraData
            });
            this.parser.flushTelemetry();
        }
        if (!success && !isWatch) {
            throw new node_core_library_1.AlreadyReportedError();
        }
    }
    _doBeforeTask() {
        if (this.actionName !== RushConstants_1.RushConstants.buildCommandName &&
            this.actionName !== RushConstants_1.RushConstants.rebuildCommandName) {
            // Only collects information for built-in commands like build or rebuild.
            return;
        }
        SetupChecks_1.SetupChecks.validate(this.rushConfiguration);
        this.eventHooksManager.handle(EventHooks_1.Event.preRushBuild, this.parser.isDebug, this._ignoreHooksParameter.value);
    }
    _doAfterTask() {
        if (this.actionName !== RushConstants_1.RushConstants.buildCommandName &&
            this.actionName !== RushConstants_1.RushConstants.rebuildCommandName) {
            // Only collects information for built-in commands like build or rebuild.
            return;
        }
        this.eventHooksManager.handle(EventHooks_1.Event.postRushBuild, this.parser.isDebug, this._ignoreHooksParameter.value);
    }
}
exports.PhasedScriptAction = PhasedScriptAction;
//# sourceMappingURL=PhasedScriptAction.js.map