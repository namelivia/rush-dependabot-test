"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rush = void 0;
const node_core_library_1 = require("@rushstack/node-core-library");
const RushCommandLineParser_1 = require("../cli/RushCommandLineParser");
const RushStartupBanner_1 = require("../cli/RushStartupBanner");
const RushXCommandLine_1 = require("../cli/RushXCommandLine");
const CommandLineMigrationAdvisor_1 = require("../cli/CommandLineMigrationAdvisor");
const EnvironmentConfiguration_1 = require("./EnvironmentConfiguration");
const RushPnpmCommandLine_1 = require("../cli/RushPnpmCommandLine");
/**
 * General operations for the Rush engine.
 *
 * @public
 */
class Rush {
    /**
     * This API is used by the `@microsoft/rush` front end to launch the "rush" command-line.
     * Third-party tools should not use this API.  Instead, they should execute the "rush" binary
     * and start a new Node.js process.
     *
     * @remarks
     * Earlier versions of the rush frontend used a different API contract. In the old contract,
     * the second argument was the `isManaged` value of the {@link ILaunchOptions} object.
     *
     * Even though this API isn't documented, it is still supported for legacy compatibility.
     */
    static launch(launcherVersion, arg) {
        const options = Rush._normalizeLaunchOptions(arg);
        if (!RushCommandLineParser_1.RushCommandLineParser.shouldRestrictConsoleOutput()) {
            RushStartupBanner_1.RushStartupBanner.logBanner(Rush.version, options.isManaged);
        }
        if (!CommandLineMigrationAdvisor_1.CommandLineMigrationAdvisor.checkArgv(process.argv)) {
            // The migration advisor recognized an obsolete command-line
            process.exitCode = 1;
            return;
        }
        Rush._assignRushInvokedFolder();
        const parser = new RushCommandLineParser_1.RushCommandLineParser({
            alreadyReportedNodeTooNewError: options.alreadyReportedNodeTooNewError,
            builtInPluginConfigurations: options.builtInPluginConfigurations
        });
        parser.execute().catch(console.error); // CommandLineParser.execute() should never reject the promise
    }
    /**
     * This API is used by the `@microsoft/rush` front end to launch the "rushx" command-line.
     * Third-party tools should not use this API.  Instead, they should execute the "rushx" binary
     * and start a new Node.js process.
     */
    static launchRushX(launcherVersion, options) {
        options = Rush._normalizeLaunchOptions(options);
        Rush._assignRushInvokedFolder();
        RushXCommandLine_1.RushXCommandLine._launchRushXInternal(launcherVersion, Object.assign({}, options));
    }
    /**
     * This API is used by the `@microsoft/rush` front end to launch the "rush-pnpm" command-line.
     * Third-party tools should not use this API.  Instead, they should execute the "rush-pnpm" binary
     * and start a new Node.js process.
     */
    static launchRushPnpm(launcherVersion, options) {
        Rush._assignRushInvokedFolder();
        RushPnpmCommandLine_1.RushPnpmCommandLine.launch(launcherVersion, Object.assign({}, options));
    }
    /**
     * The currently executing version of the "rush-lib" library.
     * This is the same as the Rush tool version for that release.
     */
    static get version() {
        if (!this._version) {
            this._version = node_core_library_1.PackageJsonLookup.loadOwnPackageJson(__dirname).version;
        }
        return this._version;
    }
    /**
     * Assign the `RUSH_INVOKED_FOLDER` environment variable during startup.  This is only applied when
     * Rush is invoked via the CLI, not via the `@microsoft/rush-lib` automation API.
     *
     * @remarks
     * Modifying the parent process's environment is not a good design.  The better design is (1) to consolidate
     * Rush's code paths that invoke scripts, and (2) to pass down the invoked folder with each code path,
     * so that it can finally be applied in a centralized helper like `Utilities._createEnvironmentForRushCommand()`.
     * The natural time to do that refactoring is when we rework `Utilities.executeCommand()` to use
     * `Executable.spawn()` or rushell.
     */
    static _assignRushInvokedFolder() {
        process.env[EnvironmentConfiguration_1.EnvironmentVariableNames.RUSH_INVOKED_FOLDER] = process.cwd();
    }
    /**
     * This function normalizes legacy options to the current {@link ILaunchOptions} object.
     */
    static _normalizeLaunchOptions(arg) {
        return typeof arg === 'boolean'
            ? { isManaged: arg } // In older versions of Rush, this the `launch` functions took a boolean arg for "isManaged"
            : arg;
    }
}
exports.Rush = Rush;
Rush._version = undefined;
//# sourceMappingURL=Rush.js.map