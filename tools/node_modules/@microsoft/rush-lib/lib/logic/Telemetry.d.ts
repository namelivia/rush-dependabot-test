import { RushConfiguration } from '../api/RushConfiguration';
import { RushSession } from '../pluginFramework/RushSession';
/**
 * @beta
 */
export interface ITelemetryData {
    /**
     * Command name
     * @example 'build'
     */
    readonly name: string;
    /**
     * Duration in seconds
     */
    readonly durationInSeconds: number;
    /**
     * The result of the command
     */
    readonly result: 'Succeeded' | 'Failed';
    /**
     * The timestamp of the telemetry logging
     * @example 1648001893024
     */
    readonly timestamp?: number;
    /**
     * The platform the command was executed on, reads from process.platform
     * @example darwin, win32, linux...
     */
    readonly platform?: string;
    /**
     * The rush version
     * @example 5.63.0
     */
    readonly rushVersion?: string;
    readonly extraData?: {
        [key: string]: string | number | boolean;
    };
}
export declare class Telemetry {
    private _enabled;
    private _store;
    private _dataFolder;
    private _rushConfiguration;
    private _rushSession;
    private _flushAsyncTasks;
    constructor(rushConfiguration: RushConfiguration, rushSession: RushSession);
    log(telemetryData: ITelemetryData): void;
    flush(): void;
    /**
     * There are some async tasks that are not finished when the process is exiting.
     */
    ensureFlushedAsync(): Promise<void>;
    get store(): ITelemetryData[];
    /**
     * When there are too many log files, delete the old ones.
     */
    private _cleanUp;
    private _getFilePath;
}
//# sourceMappingURL=Telemetry.d.ts.map