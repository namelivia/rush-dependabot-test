import { TerminalWritable } from '@rushstack/terminal';
import { Operation } from './Operation';
import { IExecutionResult } from './IOperationExecutionResult';
export interface IOperationExecutionManagerOptions {
    quietMode: boolean;
    debugMode: boolean;
    parallelism: string | undefined;
    changedProjectsOnly: boolean;
    destination?: TerminalWritable;
}
/**
 * A class which manages the execution of a set of tasks with interdependencies.
 * Initially, and at the end of each task execution, all unblocked tasks
 * are added to a ready queue which is then executed. This is done continually until all
 * tasks are complete, or prematurely fails if any of the tasks fail.
 */
export declare class OperationExecutionManager {
    private readonly _changedProjectsOnly;
    private readonly _executionRecords;
    private readonly _quietMode;
    private readonly _parallelism;
    private readonly _totalOperations;
    private readonly _outputWritable;
    private readonly _colorsNewlinesTransform;
    private readonly _streamCollator;
    private readonly _terminal;
    private _hasAnyFailures;
    private _hasAnyNonAllowedWarnings;
    private _completedOperations;
    constructor(operations: Set<Operation>, options: IOperationExecutionManagerOptions);
    private _streamCollator_onWriterActive;
    /**
     * Executes all operations which have been registered, returning a promise which is resolved when all the
     * operations are completed successfully, or rejects when any operation fails.
     */
    executeAsync(): Promise<IExecutionResult>;
    /**
     * Handles the result of the operation and propagates any relevant effects.
     */
    private _onOperationComplete;
}
//# sourceMappingURL=OperationExecutionManager.d.ts.map