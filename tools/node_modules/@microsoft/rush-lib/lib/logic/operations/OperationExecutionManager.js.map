{"version":3,"file":"OperationExecutionManager.js","sourceRoot":"","sources":["../../../src/logic/operations/OperationExecutionManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as os from 'os';\nimport colors from 'colors/safe';\nimport { TerminalWritable, StdioWritable, TextRewriterTransform } from '@rushstack/terminal';\nimport { StreamCollator, CollatedTerminal, CollatedWriter } from '@rushstack/stream-collator';\nimport { NewlineKind, Async } from '@rushstack/node-core-library';\n\nimport { AsyncOperationQueue, IOperationSortFunction } from './AsyncOperationQueue';\nimport { Operation } from './Operation';\nimport { OperationStatus } from './OperationStatus';\nimport { IOperationExecutionRecordContext, OperationExecutionRecord } from './OperationExecutionRecord';\nimport { IExecutionResult } from './IOperationExecutionResult';\n\nexport interface IOperationExecutionManagerOptions {\n  quietMode: boolean;\n  debugMode: boolean;\n  parallelism: string | undefined;\n  changedProjectsOnly: boolean;\n  destination?: TerminalWritable;\n}\n\n/**\n * Format \"======\" lines for a shell window with classic 80 columns\n */\nconst ASCII_HEADER_WIDTH: number = 79;\n\n/**\n * A class which manages the execution of a set of tasks with interdependencies.\n * Initially, and at the end of each task execution, all unblocked tasks\n * are added to a ready queue which is then executed. This is done continually until all\n * tasks are complete, or prematurely fails if any of the tasks fail.\n */\nexport class OperationExecutionManager {\n  private readonly _changedProjectsOnly: boolean;\n  private readonly _executionRecords: Map<Operation, OperationExecutionRecord>;\n  private readonly _quietMode: boolean;\n  private readonly _parallelism: number;\n  private readonly _totalOperations: number;\n\n  private readonly _outputWritable: TerminalWritable;\n  private readonly _colorsNewlinesTransform: TextRewriterTransform;\n  private readonly _streamCollator: StreamCollator;\n\n  private readonly _terminal: CollatedTerminal;\n\n  // Variables for current status\n  private _hasAnyFailures: boolean;\n  private _hasAnyNonAllowedWarnings: boolean;\n  private _completedOperations: number;\n\n  public constructor(operations: Set<Operation>, options: IOperationExecutionManagerOptions) {\n    const { quietMode, debugMode, parallelism, changedProjectsOnly } = options;\n    this._completedOperations = 0;\n    this._quietMode = quietMode;\n    this._hasAnyFailures = false;\n    this._hasAnyNonAllowedWarnings = false;\n    this._changedProjectsOnly = changedProjectsOnly;\n\n    // TERMINAL PIPELINE:\n    //\n    // streamCollator --> colorsNewlinesTransform --> StdioWritable\n    //\n    this._outputWritable = options.destination || StdioWritable.instance;\n    this._colorsNewlinesTransform = new TextRewriterTransform({\n      destination: this._outputWritable,\n      normalizeNewlines: NewlineKind.OsDefault,\n      removeColors: !colors.enabled\n    });\n    this._streamCollator = new StreamCollator({\n      destination: this._colorsNewlinesTransform,\n      onWriterActive: this._streamCollator_onWriterActive\n    });\n    this._terminal = this._streamCollator.terminal;\n\n    // Convert the developer graph to the mutable execution graph\n    const executionRecordContext: IOperationExecutionRecordContext = {\n      streamCollator: this._streamCollator,\n      debugMode,\n      quietMode\n    };\n\n    let totalOperations: number = 0;\n    const executionRecords: Map<Operation, OperationExecutionRecord> = (this._executionRecords = new Map());\n    for (const operation of operations) {\n      const executionRecord: OperationExecutionRecord = new OperationExecutionRecord(\n        operation,\n        executionRecordContext\n      );\n\n      executionRecords.set(operation, executionRecord);\n      if (!executionRecord.runner.silent) {\n        // Only count non-silent operations\n        totalOperations++;\n      }\n    }\n    this._totalOperations = totalOperations;\n\n    for (const [operation, consumer] of executionRecords) {\n      for (const dependency of operation.dependencies) {\n        const dependencyRecord: OperationExecutionRecord | undefined = executionRecords.get(dependency);\n        if (!dependencyRecord) {\n          throw new Error(\n            `Operation \"${consumer.name}\" declares a dependency on operation \"${dependency.name}\" that is not in the set of operations to execute.`\n          );\n        }\n        consumer.dependencies.add(dependencyRecord);\n        dependencyRecord.consumers.add(consumer);\n      }\n    }\n\n    const numberOfCores: number = os.cpus().length;\n\n    if (parallelism) {\n      if (parallelism === 'max') {\n        this._parallelism = numberOfCores;\n      } else {\n        const parallelismAsNumber: number = Number(parallelism);\n\n        if (typeof parallelism === 'string' && parallelism.trim().endsWith('%')) {\n          const parsedPercentage: number = Number(parallelism.trim().replace(/\\%$/, ''));\n\n          if (parsedPercentage <= 0 || parsedPercentage > 100) {\n            throw new Error(\n              `Invalid percentage value of '${parallelism}', value cannot be less than '0%' or more than '100%'`\n            );\n          }\n\n          const workers: number = Math.floor((parallelismAsNumber / 100) * numberOfCores);\n          this._parallelism = Math.max(workers, 1);\n        } else if (!isNaN(parallelismAsNumber)) {\n          this._parallelism = Math.max(parallelismAsNumber, 1);\n        } else {\n          throw new Error(\n            `Invalid parallelism value of '${parallelism}', expected a number, a percentage, or 'max'`\n          );\n        }\n      }\n    } else {\n      // If an explicit parallelism number wasn't provided, then choose a sensible\n      // default.\n      if (os.platform() === 'win32') {\n        // On desktop Windows, some people have complained that their system becomes\n        // sluggish if Rush is using all the CPU cores.  Leave one thread for\n        // other operations. For CI environments, you can use the \"max\" argument to use all available cores.\n        this._parallelism = Math.max(numberOfCores - 1, 1);\n      } else {\n        // Unix-like operating systems have more balanced scheduling, so default\n        // to the number of CPU cores\n        this._parallelism = numberOfCores;\n      }\n    }\n  }\n\n  private _streamCollator_onWriterActive = (writer: CollatedWriter | undefined): void => {\n    if (writer) {\n      this._completedOperations++;\n\n      // Format a header like this\n      //\n      // ==[ @rushstack/the-long-thing ]=================[ 1 of 1000 ]==\n\n      // leftPart: \"==[ @rushstack/the-long-thing \"\n      const leftPart: string = colors.gray('==[') + ' ' + colors.cyan(writer.taskName) + ' ';\n      const leftPartLength: number = 4 + writer.taskName.length + 1;\n\n      // rightPart: \" 1 of 1000 ]==\"\n      const completedOfTotal: string = `${this._completedOperations} of ${this._totalOperations}`;\n      const rightPart: string = ' ' + colors.white(completedOfTotal) + ' ' + colors.gray(']==');\n      const rightPartLength: number = 1 + completedOfTotal.length + 4;\n\n      // middlePart: \"]=================[\"\n      const twoBracketsLength: number = 2;\n      const middlePartLengthMinusTwoBrackets: number = Math.max(\n        ASCII_HEADER_WIDTH - (leftPartLength + rightPartLength + twoBracketsLength),\n        0\n      );\n\n      const middlePart: string = colors.gray(']' + '='.repeat(middlePartLengthMinusTwoBrackets) + '[');\n\n      this._terminal.writeStdoutLine('\\n' + leftPart + middlePart + rightPart);\n\n      if (!this._quietMode) {\n        this._terminal.writeStdoutLine('');\n      }\n    }\n  };\n\n  /**\n   * Executes all operations which have been registered, returning a promise which is resolved when all the\n   * operations are completed successfully, or rejects when any operation fails.\n   */\n  public async executeAsync(): Promise<IExecutionResult> {\n    this._completedOperations = 0;\n    const totalOperations: number = this._totalOperations;\n\n    if (!this._quietMode) {\n      const plural: string = totalOperations === 1 ? '' : 's';\n      this._terminal.writeStdoutLine(`Selected ${totalOperations} operation${plural}:`);\n      const nonSilentOperations: string[] = [];\n      for (const record of this._executionRecords.values()) {\n        if (!record.runner.silent) {\n          nonSilentOperations.push(record.name);\n        }\n      }\n      nonSilentOperations.sort();\n      for (const name of nonSilentOperations) {\n        this._terminal.writeStdoutLine(`  ${name}`);\n      }\n      this._terminal.writeStdoutLine('');\n    }\n\n    this._terminal.writeStdoutLine(`Executing a maximum of ${this._parallelism} simultaneous processes...`);\n\n    const maxParallelism: number = Math.min(totalOperations, this._parallelism);\n    const prioritySort: IOperationSortFunction = (\n      a: OperationExecutionRecord,\n      b: OperationExecutionRecord\n    ): number => {\n      return a.criticalPathLength! - b.criticalPathLength!;\n    };\n    const executionQueue: AsyncOperationQueue = new AsyncOperationQueue(\n      this._executionRecords.values(),\n      prioritySort\n    );\n\n    // This function is a callback because it may write to the collatedWriter before\n    // operation.executeAsync returns (and cleans up the writer)\n    const onOperationComplete: (record: OperationExecutionRecord) => void = (\n      record: OperationExecutionRecord\n    ) => {\n      this._onOperationComplete(record);\n    };\n\n    await Async.forEachAsync(\n      executionQueue,\n      async (operation: OperationExecutionRecord) => {\n        await operation.executeAsync(onOperationComplete);\n      },\n      {\n        concurrency: maxParallelism\n      }\n    );\n\n    const status: OperationStatus = this._hasAnyFailures\n      ? OperationStatus.Failure\n      : this._hasAnyNonAllowedWarnings\n      ? OperationStatus.SuccessWithWarning\n      : OperationStatus.Success;\n\n    return {\n      operationResults: this._executionRecords,\n      status\n    };\n  }\n\n  /**\n   * Handles the result of the operation and propagates any relevant effects.\n   */\n  private _onOperationComplete(record: OperationExecutionRecord): void {\n    const { runner, name, status } = record;\n\n    let blockCacheWrite: boolean = !runner.isCacheWriteAllowed;\n    let blockSkip: boolean = !runner.isSkipAllowed;\n\n    const silent: boolean = runner.silent;\n\n    switch (status) {\n      /**\n       * This operation failed. Mark it as such and all reachable dependents as blocked.\n       */\n      case OperationStatus.Failure: {\n        // Failed operations get reported, even if silent.\n        // Generally speaking, silent operations shouldn't be able to fail, so this is a safety measure.\n        const message: string | undefined = record.error?.message;\n        // This creates the writer, so don't do this globally\n        const { terminal } = record.collatedWriter;\n        if (message) {\n          terminal.writeStderrLine(message);\n        }\n        terminal.writeStderrLine(colors.red(`\"${name}\" failed to build.`));\n        const blockedQueue: Set<OperationExecutionRecord> = new Set(record.consumers);\n        for (const blockedRecord of blockedQueue) {\n          if (blockedRecord.status === OperationStatus.Ready) {\n            this._completedOperations++;\n\n            // Now that we have the concept of architectural no-ops, we could implement this by replacing\n            // {blockedRecord.runner} with a no-op that sets status to Blocked and logs the blocking\n            // operations. However, the existing behavior is a bit simpler, so keeping that for now.\n            if (!blockedRecord.runner.silent) {\n              terminal.writeStdoutLine(`\"${blockedRecord.name}\" is blocked by \"${name}\".`);\n            }\n            blockedRecord.status = OperationStatus.Blocked;\n\n            for (const dependent of blockedRecord.consumers) {\n              blockedQueue.add(dependent);\n            }\n          }\n        }\n        this._hasAnyFailures = true;\n        break;\n      }\n\n      /**\n       * This operation was restored from the build cache.\n       */\n      case OperationStatus.FromCache: {\n        if (!silent) {\n          record.collatedWriter.terminal.writeStdoutLine(\n            colors.green(`\"${name}\" was restored from the build cache.`)\n          );\n        }\n        break;\n      }\n\n      /**\n       * This operation was skipped via legacy change detection.\n       */\n      case OperationStatus.Skipped: {\n        if (!silent) {\n          record.collatedWriter.terminal.writeStdoutLine(colors.green(`\"${name}\" was skipped.`));\n        }\n        // Skipping means cannot guarantee integrity, so prevent cache writes in dependents.\n        blockCacheWrite = true;\n        break;\n      }\n\n      /**\n       * This operation intentionally didn't do anything.\n       */\n      case OperationStatus.NoOp: {\n        if (!silent) {\n          record.collatedWriter.terminal.writeStdoutLine(colors.gray(`\"${name}\" did not define any work.`));\n        }\n        break;\n      }\n\n      case OperationStatus.Success: {\n        if (!silent) {\n          record.collatedWriter.terminal.writeStdoutLine(\n            colors.green(`\"${name}\" completed successfully in ${record.stopwatch.toString()}.`)\n          );\n        }\n        // Legacy incremental build, if asked, prevent skip in dependents if the operation executed.\n        blockSkip ||= !this._changedProjectsOnly;\n        break;\n      }\n\n      case OperationStatus.SuccessWithWarning: {\n        if (!silent) {\n          record.collatedWriter.terminal.writeStderrLine(\n            colors.yellow(`\"${name}\" completed with warnings in ${record.stopwatch.toString()}.`)\n          );\n        }\n        // Legacy incremental build, if asked, prevent skip in dependents if the operation executed.\n        blockSkip ||= !this._changedProjectsOnly;\n        this._hasAnyNonAllowedWarnings = this._hasAnyNonAllowedWarnings || !runner.warningsAreAllowed;\n        break;\n      }\n    }\n\n    // Apply status changes to direct dependents\n    for (const item of record.consumers) {\n      if (blockCacheWrite) {\n        item.runner.isCacheWriteAllowed = false;\n      }\n\n      if (blockSkip) {\n        item.runner.isSkipAllowed = false;\n      }\n\n      // Remove this operation from the dependencies, to unblock the scheduler\n      item.dependencies.delete(record);\n    }\n  }\n}\n"]}