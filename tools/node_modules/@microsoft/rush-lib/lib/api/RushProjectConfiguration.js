"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RushProjectConfiguration = exports.RUSH_PROJECT_CONFIGURATION_FILE = void 0;
const path = __importStar(require("path"));
const node_core_library_1 = require("@rushstack/node-core-library");
const heft_config_file_1 = require("@rushstack/heft-config-file");
const rig_package_1 = require("@rushstack/rig-package");
const RushConstants_1 = require("../logic/RushConstants");
const OverlappingPathAnalyzer_1 = require("../utilities/OverlappingPathAnalyzer");
exports.RUSH_PROJECT_CONFIGURATION_FILE = new heft_config_file_1.ConfigurationFile({
    projectRelativeFilePath: `config/${RushConstants_1.RushConstants.rushProjectConfigFilename}`,
    jsonSchemaPath: path.resolve(__dirname, '..', 'schemas', 'rush-project.schema.json'),
    propertyInheritance: {
        operationSettings: {
            inheritanceType: heft_config_file_1.InheritanceType.custom,
            inheritanceFunction: (child, parent) => {
                if (!child) {
                    return parent;
                }
                else if (!parent) {
                    return child;
                }
                else {
                    // Merge the outputFolderNames arrays
                    const resultOperationSettingsByOperationName = new Map();
                    for (const parentOperationSettings of parent) {
                        resultOperationSettingsByOperationName.set(parentOperationSettings.operationName, parentOperationSettings);
                    }
                    const childEncounteredOperationNames = new Set();
                    for (const childOperationSettings of child) {
                        const operationName = childOperationSettings.operationName;
                        if (childEncounteredOperationNames.has(operationName)) {
                            // If the operation settings already exist, but didn't come from the parent, then
                            // it shows up multiple times in the child.
                            const childSourceFilePath = exports.RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(child);
                            throw new Error(`The operation "${operationName}" occurs multiple times in the "operationSettings" array ` +
                                `in "${childSourceFilePath}".`);
                        }
                        childEncounteredOperationNames.add(operationName);
                        let mergedOperationSettings = resultOperationSettingsByOperationName.get(operationName);
                        if (mergedOperationSettings) {
                            // The parent operation settings object already exists, so append to the outputFolderNames
                            const outputFolderNames = mergedOperationSettings.outputFolderNames && childOperationSettings.outputFolderNames
                                ? [
                                    ...mergedOperationSettings.outputFolderNames,
                                    ...childOperationSettings.outputFolderNames
                                ]
                                : mergedOperationSettings.outputFolderNames || childOperationSettings.outputFolderNames;
                            mergedOperationSettings = Object.assign(Object.assign(Object.assign({}, mergedOperationSettings), childOperationSettings), { outputFolderNames });
                            resultOperationSettingsByOperationName.set(operationName, mergedOperationSettings);
                        }
                        else {
                            resultOperationSettingsByOperationName.set(operationName, childOperationSettings);
                        }
                    }
                    return Array.from(resultOperationSettingsByOperationName.values());
                }
            }
        },
        incrementalBuildIgnoredGlobs: {
            inheritanceType: heft_config_file_1.InheritanceType.replace
        }
    }
});
const OLD_RUSH_PROJECT_CONFIGURATION_FILE = new heft_config_file_1.ConfigurationFile({
    projectRelativeFilePath: exports.RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath,
    jsonSchemaPath: path.resolve(__dirname, '..', 'schemas', 'anything.schema.json')
});
/**
 * Use this class to load the "config/rush-project.json" config file.
 *
 * This file provides project-specific configuration options.
 * @public
 */
class RushProjectConfiguration {
    constructor(project, rushProjectJson, operationSettingsByOperationName) {
        this._validationCache = new WeakSet();
        this.project = project;
        this.incrementalBuildIgnoredGlobs = rushProjectJson.incrementalBuildIgnoredGlobs || [];
        this.disableBuildCacheForProject = rushProjectJson.disableBuildCacheForProject || false;
        this.operationSettingsByOperationName = operationSettingsByOperationName;
    }
    /**
     * Validates that the requested phases are compatible.
     * Deferral of this logic to its own method means that Rush no longer eagerly validates
     * all defined commands in command-line.json. As such, while validation will be run for a given
     * command upon invoking that command, defining overlapping phases in "rush custom-command"
     * that are not used by "rush build" will not cause "rush build" to exit with an error.
     */
    validatePhaseConfiguration(phases, terminal) {
        // Don't repeatedly validate the same set of phases for the same project.
        if (this._validationCache.has(phases)) {
            return;
        }
        const overlappingPathAnalyzer = new OverlappingPathAnalyzer_1.OverlappingPathAnalyzer();
        const { operationSettingsByOperationName, project } = this;
        let hasErrors = false;
        for (const phase of phases) {
            const operationName = phase.name;
            const operationSettings = operationSettingsByOperationName.get(operationName);
            if (operationSettings) {
                if (operationSettings.outputFolderNames) {
                    for (const outputFolderName of operationSettings.outputFolderNames) {
                        const overlappingOperationNames = overlappingPathAnalyzer.addPathAndGetFirstEncounteredLabels(outputFolderName, operationName);
                        if (overlappingOperationNames) {
                            const overlapsWithOwnOperation = overlappingOperationNames === null || overlappingOperationNames === void 0 ? void 0 : overlappingOperationNames.includes(operationName);
                            if (overlapsWithOwnOperation) {
                                terminal.writeErrorLine(`The project "${project.packageName}" has a ` +
                                    `"${exports.RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}" configuration that defines an ` +
                                    `operation with overlapping paths in the "outputFolderNames" list. The operation is ` +
                                    `"${operationName}", and the conflicting path is "${outputFolderName}".`);
                            }
                            else {
                                terminal.writeErrorLine(`The project "${project.packageName}" has a ` +
                                    `"${exports.RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}" configuration that defines ` +
                                    'two operations in the same command whose "outputFolderNames" would overlap. ' +
                                    'Operations outputs in the same command must be disjoint so that they can be independently cached.' +
                                    `\n\n` +
                                    `The "${outputFolderName}" path overlaps between these operations: ` +
                                    overlappingOperationNames.map((operationName) => `"${operationName}"`).join(', '));
                            }
                            hasErrors = true;
                        }
                    }
                }
            }
        }
        this._validationCache.add(phases);
        if (hasErrors) {
            throw new node_core_library_1.AlreadyReportedError();
        }
    }
    /**
     * Loads the rush-project.json data for the specified project.
     */
    static async tryLoadForProjectAsync(project, terminal) {
        // false is a signal that the project config does not exist
        const cacheEntry = RushProjectConfiguration._configCache.get(project);
        if (cacheEntry !== undefined) {
            return cacheEntry || undefined;
        }
        const rushProjectJson = await this._tryLoadJsonForProjectAsync(project, terminal);
        if (rushProjectJson) {
            const result = RushProjectConfiguration._getRushProjectConfiguration(project, rushProjectJson, terminal);
            RushProjectConfiguration._configCache.set(project, result);
            return result;
        }
        else {
            RushProjectConfiguration._configCache.set(project, false);
            return undefined;
        }
    }
    /**
     * Load only the `incrementalBuildIgnoredGlobs` property from the rush-project.json file, skipping
     * validation of other parts of the config file.
     *
     * @remarks
     * This function exists to allow the ProjectChangeAnalyzer to load just the ignore globs without
     * having to validate the rest of the `rush-project.json` file against the repo's command-line configuration.
     */
    static async tryLoadIgnoreGlobsForProjectAsync(project, terminal) {
        const rushProjectJson = await this._tryLoadJsonForProjectAsync(project, terminal);
        return rushProjectJson === null || rushProjectJson === void 0 ? void 0 : rushProjectJson.incrementalBuildIgnoredGlobs;
    }
    static async _tryLoadJsonForProjectAsync(project, terminal) {
        const rigConfig = await rig_package_1.RigConfig.loadForProjectFolderAsync({
            projectFolderPath: project.projectFolder
        });
        try {
            return await exports.RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(terminal, project.projectFolder, rigConfig);
        }
        catch (e) {
            // Detect if the project is using the old rush-project.json schema
            let oldRushProjectJson;
            try {
                oldRushProjectJson =
                    await OLD_RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(terminal, project.projectFolder, rigConfig);
            }
            catch (e) {
                // Ignore
            }
            if ((oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.projectOutputFolderNames) ||
                (oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.phaseOptions) ||
                (oldRushProjectJson === null || oldRushProjectJson === void 0 ? void 0 : oldRushProjectJson.buildCacheOptions)) {
                throw new Error(`The ${exports.RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file appears to be ` +
                    'in an outdated format. Please see the UPGRADING.md notes for details. ' +
                    'Quick link: https://rushjs.io/link/upgrading');
            }
            else {
                throw e;
            }
        }
    }
    static _getRushProjectConfiguration(project, rushProjectJson, terminal) {
        const operationSettingsByOperationName = new Map();
        let hasErrors = false;
        if (rushProjectJson.operationSettings) {
            for (const operationSettings of rushProjectJson.operationSettings) {
                const operationName = operationSettings.operationName;
                const existingOperationSettings = operationSettingsByOperationName.get(operationName);
                if (existingOperationSettings) {
                    const existingOperationSettingsJsonPath = exports.RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(existingOperationSettings);
                    const operationSettingsJsonPath = exports.RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(operationSettings);
                    hasErrors = true;
                    let errorMessage = `The operation "${operationName}" appears multiple times in the "${project.packageName}" project's ` +
                        `${exports.RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file's ` +
                        'operationSettings property.';
                    if (existingOperationSettingsJsonPath && operationSettingsJsonPath) {
                        if (existingOperationSettingsJsonPath !== operationSettingsJsonPath) {
                            errorMessage +=
                                ` It first appears in "${existingOperationSettingsJsonPath}" and again ` +
                                    `in "${operationSettingsJsonPath}".`;
                        }
                        else if (!node_core_library_1.Path.convertToSlashes(existingOperationSettingsJsonPath).startsWith(node_core_library_1.Path.convertToSlashes(project.projectFolder))) {
                            errorMessage += ` It appears multiple times in "${operationSettingsJsonPath}".`;
                        }
                    }
                    terminal.writeErrorLine(errorMessage);
                }
                else {
                    operationSettingsByOperationName.set(operationName, operationSettings);
                }
            }
        }
        if (hasErrors) {
            throw new node_core_library_1.AlreadyReportedError();
        }
        return new RushProjectConfiguration(project, rushProjectJson, operationSettingsByOperationName);
    }
}
exports.RushProjectConfiguration = RushProjectConfiguration;
RushProjectConfiguration._configCache = new Map();
//# sourceMappingURL=RushProjectConfiguration.js.map