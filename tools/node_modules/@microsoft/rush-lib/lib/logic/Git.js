"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Git = exports.DEFAULT_GIT_TAG_SEPARATOR = void 0;
const gitInfo = require("git-repo-info");
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const url = __importStar(require("url"));
const safe_1 = __importDefault(require("colors/safe"));
const true_case_path_1 = require("true-case-path");
const node_core_library_1 = require("@rushstack/node-core-library");
const package_deps_hash_1 = require("@rushstack/package-deps-hash");
const Utilities_1 = require("../utilities/Utilities");
const GitEmailPolicy_1 = require("./policy/GitEmailPolicy");
const EnvironmentConfiguration_1 = require("../api/EnvironmentConfiguration");
const GitStatusParser_1 = require("./GitStatusParser");
exports.DEFAULT_GIT_TAG_SEPARATOR = '_';
class Git {
    constructor(rushConfiguration) {
        this._checkedGitPath = false;
        this._checkedGitInfo = false;
        this._gitEmailResult = undefined;
        this._gitHooksPath = undefined;
        this._rushConfiguration = rushConfiguration;
    }
    /**
     * Returns the path to the Git binary if found. Otherwise, return undefined.
     */
    get gitPath() {
        if (!this._checkedGitPath) {
            this._gitPath = EnvironmentConfiguration_1.EnvironmentConfiguration.gitBinaryPath || node_core_library_1.Executable.tryResolve('git');
            this._checkedGitPath = true;
        }
        return this._gitPath;
    }
    getGitPathOrThrow() {
        const gitPath = this.gitPath;
        if (!gitPath) {
            throw new Error('Git is not present');
        }
        else {
            return gitPath;
        }
    }
    /**
     * Returns true if the Git binary can be found.
     */
    isGitPresent() {
        return !!this.gitPath;
    }
    /**
     * Returns true if the Git binary was found and the current path is under a Git working tree.
     * @param repoInfo - If provided, do the check based on this Git repo info. If not provided,
     * the result of `this.getGitInfo()` is used.
     */
    isPathUnderGitWorkingTree(repoInfo) {
        if (this.isGitPresent()) {
            // Do we even have a Git binary?
            if (!repoInfo) {
                repoInfo = this.getGitInfo();
            }
            return !!(repoInfo && repoInfo.sha);
        }
        else {
            return false;
        }
    }
    /**
     * If a Git email address is configured and is nonempty, this returns it.
     * Otherwise, undefined is returned.
     */
    tryGetGitEmail() {
        const emailResult = this._tryGetGitEmail();
        if (emailResult.result !== undefined && emailResult.result.length > 0) {
            return emailResult.result;
        }
        return undefined;
    }
    /**
     * If a Git email address is configured and is nonempty, this returns it.
     * Otherwise, configuration instructions are printed to the console,
     * and AlreadyReportedError is thrown.
     */
    getGitEmail() {
        // Determine the user's account
        // Ex: "bob@example.com"
        const emailResult = this._tryGetGitEmail();
        if (emailResult.error) {
            console.log([
                `Error: ${emailResult.error.message}`,
                'Unable to determine your Git configuration using this command:',
                '',
                '    git config user.email',
                ''
            ].join(os.EOL));
            throw new node_core_library_1.AlreadyReportedError();
        }
        if (emailResult.result === undefined || emailResult.result.length === 0) {
            console.log([
                'This operation requires that a Git email be specified.',
                '',
                `If you didn't configure your email yet, try something like this:`,
                '',
                ...GitEmailPolicy_1.GitEmailPolicy.getEmailExampleLines(this._rushConfiguration),
                ''
            ].join(os.EOL));
            throw new node_core_library_1.AlreadyReportedError();
        }
        return emailResult.result;
    }
    /**
     * Get the folder where Git hooks should go for the current working tree.
     * Returns undefined if the current path is not under a Git working tree.
     */
    getHooksFolder() {
        const repoInfo = this.getGitInfo();
        if (repoInfo && repoInfo.worktreeGitDir) {
            return path.join(repoInfo.worktreeGitDir, 'hooks');
        }
        return undefined;
    }
    isHooksPathDefault() {
        const repoInfo = this.getGitInfo();
        if (!(repoInfo === null || repoInfo === void 0 ? void 0 : repoInfo.commonGitDir)) {
            // This should have never been called in a non-Git environment
            return true;
        }
        let commonGitDir = repoInfo.commonGitDir;
        try {
            commonGitDir = (0, true_case_path_1.trueCasePathSync)(commonGitDir);
        }
        catch (error) {
            /* ignore errors from true-case-path */
        }
        const defaultHooksPath = path.resolve(commonGitDir, 'hooks');
        const hooksResult = this._tryGetGitHooksPath();
        if (hooksResult.error) {
            console.log([
                `Error: ${hooksResult.error.message}`,
                'Unable to determine your Git configuration using this command:',
                '',
                '    git rev-parse --git-path hooks',
                '',
                'Assuming hooks can still be installed in the default location'
            ].join(os.EOL));
            return true;
        }
        if (hooksResult.result) {
            const absoluteHooksPath = path.resolve(this._rushConfiguration.rushJsonFolder, hooksResult.result);
            return absoluteHooksPath === defaultHooksPath;
        }
        // No error, but also empty result? Not sure it's possible.
        return true;
    }
    getConfigHooksPath() {
        let configHooksPath = '';
        const gitPath = this.getGitPathOrThrow();
        try {
            configHooksPath = this._executeGitCommandAndCaptureOutput(gitPath, ['config', 'core.hooksPath']).trim();
        }
        catch (e) {
            // git config returns error code 1 if core.hooksPath is not set.
        }
        return configHooksPath;
    }
    /**
     * Get information about the current Git working tree.
     * Returns undefined if the current path is not under a Git working tree.
     */
    getGitInfo() {
        if (!this._checkedGitInfo) {
            let repoInfo;
            try {
                // gitInfo() shouldn't usually throw, but wrapping in a try/catch just in case
                repoInfo = gitInfo();
            }
            catch (ex) {
                // if there's an error, assume we're not in a Git working tree
            }
            if (repoInfo && this.isPathUnderGitWorkingTree(repoInfo)) {
                this._gitInfo = repoInfo;
            }
            this._checkedGitInfo = true;
        }
        return this._gitInfo;
    }
    getMergeBase(targetBranch, terminal, shouldFetch = false) {
        if (shouldFetch) {
            this._fetchRemoteBranch(targetBranch, terminal);
        }
        const gitPath = this.getGitPathOrThrow();
        const output = this._executeGitCommandAndCaptureOutput(gitPath, [
            '--no-optional-locks',
            'merge-base',
            '--',
            'HEAD',
            targetBranch
        ]);
        const result = output.trim();
        return result;
    }
    getBlobContent({ blobSpec, repositoryRoot }) {
        const gitPath = this.getGitPathOrThrow();
        const output = this._executeGitCommandAndCaptureOutput(gitPath, ['cat-file', 'blob', blobSpec, '--'], repositoryRoot);
        return output;
    }
    /**
     * @param pathPrefix - An optional path prefix "git diff"s should be filtered by.
     * @returns
     * An array of paths of repo-root-relative paths of files that are different from
     * those in the provided {@param targetBranch}. If a {@param pathPrefix} is provided,
     * this function only returns results under the that path.
     */
    getChangedFiles(targetBranch, terminal, skipFetch = false, pathPrefix) {
        if (!skipFetch) {
            this._fetchRemoteBranch(targetBranch, terminal);
        }
        const gitPath = this.getGitPathOrThrow();
        const output = this._executeGitCommandAndCaptureOutput(gitPath, [
            'diff',
            `${targetBranch}...`,
            '--name-only',
            '--no-renames',
            '--diff-filter=A'
        ]);
        return output
            .split('\n')
            .map((line) => {
            if (line) {
                const trimmedLine = line.trim();
                if (!pathPrefix || node_core_library_1.Path.isUnderOrEqual(trimmedLine, pathPrefix)) {
                    return trimmedLine;
                }
            }
            else {
                return undefined;
            }
        })
            .filter((line) => {
            return line && line.length > 0;
        });
    }
    /**
     * Gets the remote default branch that maps to the provided repository url.
     * This method is used by 'Rush change' to find the default remote branch to compare against.
     * If repository url is not provided or if there is no match, returns the default remote's
     * default branch 'origin/main'.
     * If there are more than one matches, returns the first remote's default branch.
     *
     * @param rushConfiguration - rush configuration
     */
    getRemoteDefaultBranch() {
        const repositoryUrls = this._rushConfiguration.repositoryUrls;
        if (repositoryUrls.length > 0) {
            const gitPath = this.getGitPathOrThrow();
            const output = this._executeGitCommandAndCaptureOutput(gitPath, ['remote']).trim();
            const normalizedRepositoryUrls = new Set();
            for (const repositoryUrl of repositoryUrls) {
                // Apply toUpperCase() for a case-insensitive comparison
                normalizedRepositoryUrls.add(Git.normalizeGitUrlForComparison(repositoryUrl).toUpperCase());
            }
            const matchingRemotes = output.split('\n').filter((remoteName) => {
                if (remoteName) {
                    const remoteUrl = this._executeGitCommandAndCaptureOutput(gitPath, [
                        'remote',
                        'get-url',
                        '--',
                        remoteName
                    ]).trim();
                    if (!remoteUrl) {
                        return false;
                    }
                    // Also apply toUpperCase() for a case-insensitive comparison
                    const normalizedRemoteUrl = Git.normalizeGitUrlForComparison(remoteUrl).toUpperCase();
                    if (normalizedRepositoryUrls.has(normalizedRemoteUrl)) {
                        return true;
                    }
                }
                return false;
            });
            if (matchingRemotes.length > 0) {
                if (matchingRemotes.length > 1) {
                    console.log(`More than one git remote matches the repository URL. Using the first remote (${matchingRemotes[0]}).`);
                }
                return `${matchingRemotes[0]}/${this._rushConfiguration.repositoryDefaultBranch}`;
            }
            else {
                const errorMessage = repositoryUrls.length > 1
                    ? `Unable to find a git remote matching one of the repository URLs (${repositoryUrls.join(', ')}). `
                    : `Unable to find a git remote matching the repository URL (${repositoryUrls[0]}). `;
                console.log(safe_1.default.yellow(errorMessage + 'Detected changes are likely to be incorrect.'));
                return this._rushConfiguration.repositoryDefaultFullyQualifiedRemoteBranch;
            }
        }
        else {
            console.log(safe_1.default.yellow('A git remote URL has not been specified in rush.json. Setting the baseline remote URL is recommended.'));
            return this._rushConfiguration.repositoryDefaultFullyQualifiedRemoteBranch;
        }
    }
    hasUncommittedChanges() {
        const gitStatusEntries = this.getGitStatus();
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const gitStatusEntry of gitStatusEntries) {
            // If there are any changes, return true. We only need to evaluate the first iterator entry
            return true;
        }
        return false;
    }
    hasUnstagedChanges() {
        const gitStatusEntries = this.getGitStatus();
        for (const gitStatusEntry of gitStatusEntries) {
            if (gitStatusEntry.kind === 'untracked' ||
                gitStatusEntry.unstagedChangeType !== undefined) {
                return true;
            }
        }
        return false;
    }
    /**
     * The list of files changed but not committed
     */
    getUncommittedChanges() {
        const result = [];
        const gitStatusEntries = this.getGitStatus();
        for (const gitStatusEntry of gitStatusEntries) {
            result.push(gitStatusEntry.path);
        }
        return result;
    }
    getTagSeparator() {
        return this._rushConfiguration.gitTagSeparator || exports.DEFAULT_GIT_TAG_SEPARATOR;
    }
    getGitStatus() {
        const gitPath = this.getGitPathOrThrow();
        // See Git.test.ts for example output
        const output = this._executeGitCommandAndCaptureOutput(gitPath, [
            'status',
            '--porcelain=2',
            '--null',
            '--ignored=no'
        ]);
        return (0, GitStatusParser_1.parseGitStatus)(output);
    }
    /**
     * Git remotes can use different URL syntaxes; this converts them all to a normalized HTTPS
     * representation for matching purposes.  IF THE INPUT IS NOT ALREADY HTTPS, THE OUTPUT IS
     * NOT NECESSARILY A VALID GIT URL.
     *
     * @example
     * `git@github.com:ExampleOrg/ExampleProject.git` --> `https://github.com/ExampleOrg/ExampleProject`
     */
    static normalizeGitUrlForComparison(gitUrl) {
        // Git URL formats are documented here: https://www.git-scm.com/docs/git-clone#_git_urls
        let result = gitUrl.trim();
        // [user@]host.xz:path/to/repo.git/
        // "This syntax is only recognized if there are no slashes before the first colon. This helps
        // differentiate a local path that contains a colon."
        //
        // Match patterns like this:
        //   user@host.ext:path/to/repo
        //   host.ext:path/to/repo
        //   localhost:/~user/path/to/repo
        //
        // But not:
        //   http://blah
        //   c:/windows/path.txt
        //
        const scpLikeSyntaxRegExp = /^(?:[^@:\/]+\@)?([^:\/]{2,})\:((?!\/\/).+)$/;
        // Example: "user@host.ext:path/to/repo"
        const scpLikeSyntaxMatch = scpLikeSyntaxRegExp.exec(gitUrl);
        if (scpLikeSyntaxMatch) {
            // Example: "host.ext"
            const host = scpLikeSyntaxMatch[1];
            // Example: "path/to/repo"
            const path = scpLikeSyntaxMatch[2];
            if (path.startsWith('/')) {
                result = `https://${host}${path}`;
            }
            else {
                result = `https://${host}/${path}`;
            }
        }
        const parsedUrl = url.parse(result);
        // Only convert recognized schemes
        switch (parsedUrl.protocol) {
            case 'http:':
            case 'https:':
            case 'ssh:':
            case 'ftp:':
            case 'ftps:':
            case 'git:':
            case 'git+http:':
            case 'git+https:':
            case 'git+ssh:':
            case 'git+ftp:':
            case 'git+ftps:':
                // Assemble the parts we want:
                result = `https://${parsedUrl.host}${parsedUrl.pathname}`;
                break;
        }
        // Trim ".git" or ".git/" from the end
        result = result.replace(/.git\/?$/, '');
        return result;
    }
    _tryGetGitEmail() {
        if (this._gitEmailResult === undefined) {
            const gitPath = this.getGitPathOrThrow();
            try {
                this._gitEmailResult = {
                    result: this._executeGitCommandAndCaptureOutput(gitPath, ['config', 'user.email']).trim()
                };
            }
            catch (e) {
                this._gitEmailResult = {
                    error: e
                };
            }
        }
        return this._gitEmailResult;
    }
    _tryGetGitHooksPath() {
        if (this._gitHooksPath === undefined) {
            const gitPath = this.getGitPathOrThrow();
            try {
                this._gitHooksPath = {
                    result: this._executeGitCommandAndCaptureOutput(gitPath, [
                        'rev-parse',
                        '--git-path',
                        'hooks'
                    ]).trim()
                };
            }
            catch (e) {
                this._gitHooksPath = {
                    error: e
                };
            }
        }
        return this._gitHooksPath;
    }
    _tryFetchRemoteBranch(remoteBranchName) {
        const firstSlashIndex = remoteBranchName.indexOf('/');
        if (firstSlashIndex === -1) {
            throw new Error(`Unexpected git remote branch format: ${remoteBranchName}. ` +
                'Expected branch to be in the <remote>/<branch name> format.');
        }
        const remoteName = remoteBranchName.substr(0, firstSlashIndex);
        const branchName = remoteBranchName.substr(firstSlashIndex + 1);
        const gitPath = this.getGitPathOrThrow();
        const spawnResult = node_core_library_1.Executable.spawnSync(gitPath, ['fetch', '--', remoteName, branchName], {
            stdio: 'ignore'
        });
        return spawnResult.status === 0;
    }
    _fetchRemoteBranch(remoteBranchName, terminal) {
        console.log(`Checking for updates to ${remoteBranchName}...`);
        const fetchResult = this._tryFetchRemoteBranch(remoteBranchName);
        if (!fetchResult) {
            terminal.writeWarningLine(`Error fetching git remote branch ${remoteBranchName}. Detected changed files may be incorrect.`);
        }
    }
    /**
     * @internal
     */
    _executeGitCommandAndCaptureOutput(gitPath, args, repositoryRoot = this._rushConfiguration.rushJsonFolder) {
        try {
            return Utilities_1.Utilities.executeCommandAndCaptureOutput(gitPath, args, repositoryRoot);
        }
        catch (e) {
            (0, package_deps_hash_1.ensureGitMinimumVersion)(gitPath);
            throw e;
        }
    }
}
exports.Git = Git;
//# sourceMappingURL=Git.js.map