{"version":3,"file":"CommandLineConfiguration.js","sourceRoot":"","sources":["../../src/api/CommandLineConfiguration.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport { JsonFile, JsonSchema, FileSystem } from '@rushstack/node-core-library';\nimport type { CommandLineParameter } from '@rushstack/ts-command-line';\n\nimport { RushConstants } from '../logic/RushConstants';\nimport type {\n  CommandJson,\n  ICommandLineJson,\n  IBulkCommandJson,\n  IGlobalCommandJson,\n  IFlagParameterJson,\n  IChoiceParameterJson,\n  IStringParameterJson,\n  IPhasedCommandWithoutPhasesJson\n} from './CommandLineJson';\n\nexport interface IShellCommandTokenContext {\n  packageFolder: string;\n}\n\n/**\n * Metadata about a phase.\n * @alpha\n */\nexport interface IPhase {\n  /**\n   * The name of this phase.\n   */\n  name: string;\n\n  /**\n   * If set to \"true,\" this this phase was generated from a bulk command, and\n   * was not explicitly defined in the command-line.json file.\n   */\n  isSynthetic: boolean;\n\n  /**\n   * This property is used in the name of the filename for the logs generated by this\n   * phase. This is a filesystem-safe version of the phase name. For example,\n   * a phase with name \"_phase:compile\" has a `logFilenameIdentifier` of \"_phase_compile\".\n   */\n  logFilenameIdentifier: string;\n\n  /**\n   * The set of custom command line parameters that are relevant to this phase.\n   */\n  associatedParameters: Set<CommandLineParameter>;\n\n  /**\n   * The resolved dependencies of the phase\n   */\n  dependencies: {\n    self: Set<IPhase>;\n    upstream: Set<IPhase>;\n  };\n\n  /**\n   * Normally Rush requires that each project's package.json has a \\\"scripts\\\" entry matching the phase name. To disable this check, set \\\"ignoreMissingScript\\\" to true.\n   */\n  ignoreMissingScript: boolean;\n\n  /**\n   * By default, Rush returns a nonzero exit code if errors or warnings occur during a command. If this option is set to \\\"true\\\", Rush will return a zero exit code if warnings occur during the execution of this phase.\n   */\n  allowWarningsOnSuccess: boolean;\n}\n\nexport interface ICommandWithParameters {\n  associatedParameters: Set<IParameterJson>;\n}\n\nexport interface IPhasedCommandConfig extends IPhasedCommandWithoutPhasesJson, ICommandWithParameters {\n  /**\n   * If set to `true`, then this phased command was generated from a bulk command, and\n   * was not explicitly defined in the command-line.json file.\n   */\n  isSynthetic: boolean;\n  disableBuildCache?: boolean;\n\n  phases: Set<IPhase>;\n\n  /**\n   * If set to `true`, this phased command will always run in watch mode, regardless of CLI flags.\n   */\n  alwaysWatch: boolean;\n  /**\n   * The set of phases to execute when running this phased command in watch mode.\n   */\n  watchPhases: Set<IPhase>;\n  /**\n   * If set to `true`, then this phased command will always perform an install before executing, regardless of CLI flags.\n   * If set to `false`, then Rush will define a built-in \"--install\" CLI flag for this command.\n   * If undefined, then Rush does not define a built-in \"--install\" CLI flag for this command and no installation is performed.\n   */\n  alwaysInstall: boolean | undefined;\n}\n\nexport interface IGlobalCommandConfig extends IGlobalCommandJson, ICommandWithParameters {}\n\nexport type Command = IGlobalCommandConfig | IPhasedCommandConfig;\n\n/**\n * Metadata about a custom parameter defined in command-line.json\n * @alpha\n */\nexport type IParameterJson = IFlagParameterJson | IChoiceParameterJson | IStringParameterJson;\n\nconst DEFAULT_BUILD_COMMAND_JSON: IBulkCommandJson = {\n  commandKind: RushConstants.bulkCommandKind,\n  name: RushConstants.buildCommandName,\n  summary: \"Build all projects that haven't been built, or have changed since they were last built.\",\n  description:\n    'This command is similar to \"rush rebuild\", except that \"rush build\" performs' +\n    ' an incremental build. In other words, it only builds projects whose source files have changed' +\n    ' since the last successful build. The analysis requires a Git working tree, and only considers' +\n    ' source files that are tracked by Git and whose path is under the project folder. (For more details' +\n    ' about this algorithm, see the documentation for the \"package-deps-hash\" NPM package.) The incremental' +\n    ' build state is tracked in a per-project folder called \".rush/temp\" which should NOT be added to Git. The' +\n    ' build command is tracked by the \"arguments\" field in the \"package-deps_build.json\" file contained' +\n    ' therein; a full rebuild is forced whenever the command has changed (e.g. \"--production\" or not).',\n  safeForSimultaneousRushProcesses: false,\n  enableParallelism: true,\n  incremental: true\n};\n\nconst DEFAULT_REBUILD_COMMAND_JSON: IBulkCommandJson = {\n  commandKind: RushConstants.bulkCommandKind,\n  name: RushConstants.rebuildCommandName,\n  summary: 'Clean and rebuild the entire set of projects.',\n  description:\n    'This command assumes that the package.json file for each project contains' +\n    ' a \"scripts\" entry for \"npm run build\" that performs a full clean build.' +\n    ' Rush invokes this script to build each project that is registered in rush.json.' +\n    ' Projects are built in parallel where possible, but always respecting the dependency' +\n    ' graph for locally linked projects.  The number of simultaneous processes will be' +\n    ' based on the number of machine cores unless overridden by the --parallelism flag.' +\n    ' (For an incremental build, see \"rush build\" instead of \"rush rebuild\".)',\n  safeForSimultaneousRushProcesses: false,\n  enableParallelism: true,\n  incremental: false\n};\n\ninterface ICommandLineConfigurationOptions {\n  /**\n   * If true, do not include default build and rebuild commands.\n   */\n  doNotIncludeDefaultBuildCommands?: boolean;\n}\n\n/**\n * Custom Commands and Options for the Rush Command Line\n */\nexport class CommandLineConfiguration {\n  private static _jsonSchema: JsonSchema = JsonSchema.fromFile(\n    path.join(__dirname, '../schemas/command-line.schema.json')\n  );\n\n  public readonly commands: Map<string, Command> = new Map();\n  public readonly phases: Map<string, IPhase> = new Map();\n  public readonly parameters: IParameterJson[] = [];\n\n  /**\n   * shellCommand from plugin custom command line configuration needs to be expanded with tokens\n   */\n  public shellCommandTokenContext: IShellCommandTokenContext | undefined;\n\n  /**\n   * These path will be prepended to the PATH environment variable\n   */\n  private readonly _additionalPathFolders: string[] = [];\n\n  /**\n   * A map of bulk command names to their corresponding synthetic phase identifiers\n   */\n  private readonly _syntheticPhasesByTranslatedBulkCommandName: Map<string, IPhase> = new Map();\n\n  /**\n   * Use CommandLineConfiguration.loadFromFile()\n   *\n   * @internal\n   */\n  public constructor(\n    commandLineJson: ICommandLineJson | undefined,\n    options: ICommandLineConfigurationOptions = {}\n  ) {\n    const phasesJson: ICommandLineJson['phases'] = commandLineJson?.phases;\n    if (phasesJson) {\n      const phaseNameRegexp: RegExp = new RegExp(\n        `^${RushConstants.phaseNamePrefix}[a-z][a-z0-9]*([-][a-z0-9]+)*$`\n      );\n      for (const phase of phasesJson) {\n        if (this.phases.has(phase.name)) {\n          throw new Error(\n            `In ${RushConstants.commandLineFilename}, the phase \"${phase.name}\" is specified ` +\n              'more than once.'\n          );\n        }\n\n        if (!phase.name.match(phaseNameRegexp)) {\n          throw new Error(\n            `In ${RushConstants.commandLineFilename}, the phase \"${phase.name}\"'s name ` +\n              'is not a valid phase name. Phase names must begin with the ' +\n              `required prefix \"${RushConstants.phaseNamePrefix}\" followed by a name containing ` +\n              'lowercase letters, numbers, or hyphens. The name must start with a letter and ' +\n              'must not end with a hyphen.'\n          );\n        }\n\n        // This is a completely fresh object. Avoid use of the `...` operator in its construction\n        // to guarantee monomorphism.\n        const processedPhase: IPhase = {\n          name: phase.name,\n          isSynthetic: false,\n          logFilenameIdentifier: this._normalizeNameForLogFilenameIdentifiers(phase.name),\n          associatedParameters: new Set(),\n          dependencies: {\n            self: new Set(),\n            upstream: new Set()\n          },\n          ignoreMissingScript: !!phase.ignoreMissingScript,\n          allowWarningsOnSuccess: !!phase.allowWarningsOnSuccess\n        };\n\n        this.phases.set(phase.name, processedPhase);\n      }\n\n      // Resolve phase names to the underlying objects\n      for (const rawPhase of phasesJson) {\n        // The named phase not existing was already handled in the loop above\n        const phase: IPhase = this.phases.get(rawPhase.name)!;\n\n        const selfDependencies: string[] | undefined = rawPhase.dependencies?.self;\n        const upstreamDependencies: string[] | undefined = rawPhase.dependencies?.upstream;\n\n        if (selfDependencies) {\n          for (const dependencyName of selfDependencies) {\n            const dependency: IPhase | undefined = this.phases.get(dependencyName);\n            if (!dependency) {\n              throw new Error(\n                `In ${RushConstants.commandLineFilename}, in the phase \"${phase.name}\", the self ` +\n                  `dependency phase \"${dependencyName}\" does not exist.`\n              );\n            }\n            phase.dependencies.self.add(dependency);\n          }\n        }\n\n        if (upstreamDependencies) {\n          for (const dependencyName of upstreamDependencies) {\n            const dependency: IPhase | undefined = this.phases.get(dependencyName);\n            if (!dependency) {\n              throw new Error(\n                `In ${RushConstants.commandLineFilename}, in the phase \"${phase.name}\", ` +\n                  `the upstream dependency phase \"${dependencyName}\" does not exist.`\n              );\n            }\n            phase.dependencies.upstream.add(dependency);\n          }\n        }\n      }\n\n      // Do the recursive stuff after the dependencies have been converted\n      const safePhases: Set<IPhase> = new Set();\n      const cycleDetector: Set<IPhase> = new Set();\n      for (const phase of this.phases.values()) {\n        this._checkForPhaseSelfCycles(phase, cycleDetector, safePhases);\n      }\n    }\n\n    const commandsJson: ICommandLineJson['commands'] = commandLineJson?.commands;\n    let buildCommandPhases: IPhasedCommandConfig['phases'] | undefined;\n    if (commandsJson) {\n      for (const command of commandsJson) {\n        if (this.commands.has(command.name)) {\n          throw new Error(\n            `In ${RushConstants.commandLineFilename}, the command \"${command.name}\" is specified ` +\n              'more than once.'\n          );\n        }\n\n        let normalizedCommand: Command;\n        switch (command.commandKind) {\n          case RushConstants.phasedCommandKind: {\n            const commandPhases: Set<IPhase> = new Set();\n            const watchPhases: Set<IPhase> = new Set();\n\n            normalizedCommand = {\n              ...command,\n              isSynthetic: false,\n              associatedParameters: new Set<IParameterJson>(),\n              phases: commandPhases,\n              watchPhases,\n              alwaysWatch: false,\n              alwaysInstall: undefined\n            };\n\n            for (const phaseName of command.phases) {\n              const phase: IPhase | undefined = this.phases.get(phaseName);\n              if (!phase) {\n                throw new Error(\n                  `In ${RushConstants.commandLineFilename}, in the \"phases\" property of the ` +\n                    `\"${normalizedCommand.name}\" command, the phase \"${phaseName}\" does not exist.`\n                );\n              }\n\n              commandPhases.add(phase);\n            }\n\n            // Apply implicit phase dependency expansion\n            // The equivalent of the \"--to\" operator used for projects\n            // Appending to the set while iterating it accomplishes a full breadth-first search\n            for (const phase of commandPhases) {\n              for (const dependency of phase.dependencies.self) {\n                commandPhases.add(dependency);\n              }\n\n              for (const dependency of phase.dependencies.upstream) {\n                commandPhases.add(dependency);\n              }\n            }\n\n            const { watchOptions, installOptions } = command;\n\n            if (watchOptions) {\n              normalizedCommand.alwaysWatch = watchOptions.alwaysWatch;\n\n              // No implicit phase dependency expansion for watch mode.\n              for (const phaseName of watchOptions.watchPhases) {\n                const phase: IPhase | undefined = this.phases.get(phaseName);\n                if (!phase) {\n                  throw new Error(\n                    `In ${RushConstants.commandLineFilename}, in the \"watchPhases\" property of the ` +\n                      `\"${normalizedCommand.name}\" command, the phase \"${phaseName}\" does not exist.`\n                  );\n                }\n\n                watchPhases.add(phase);\n              }\n            }\n\n            if (installOptions) {\n              normalizedCommand.alwaysInstall = installOptions.alwaysInstall;\n            }\n\n            break;\n          }\n\n          case RushConstants.globalCommandKind: {\n            normalizedCommand = {\n              ...command,\n              associatedParameters: new Set<IParameterJson>()\n            };\n            break;\n          }\n\n          case RushConstants.bulkCommandKind: {\n            // Translate the bulk command into a phased command\n            normalizedCommand = this._translateBulkCommandToPhasedCommand(command);\n            break;\n          }\n        }\n\n        if (\n          normalizedCommand.name === RushConstants.buildCommandName ||\n          normalizedCommand.name === RushConstants.rebuildCommandName\n        ) {\n          if (normalizedCommand.commandKind === RushConstants.globalCommandKind) {\n            throw new Error(\n              `${RushConstants.commandLineFilename} defines a command \"${normalizedCommand.name}\" using ` +\n                `the command kind \"${RushConstants.globalCommandKind}\". This command can only be designated as a command ` +\n                `kind \"${RushConstants.bulkCommandKind}\" or \"${RushConstants.phasedCommandKind}\".`\n            );\n          } else if (command.safeForSimultaneousRushProcesses) {\n            throw new Error(\n              `${RushConstants.commandLineFilename} defines a command \"${normalizedCommand.name}\" using ` +\n                `\"safeForSimultaneousRushProcesses=true\". This configuration is not supported for \"${normalizedCommand.name}\".`\n            );\n          } else if (normalizedCommand.name === RushConstants.buildCommandName) {\n            // Record the build command phases in case we need to construct a synthetic \"rebuild\" command\n            buildCommandPhases = normalizedCommand.phases;\n          }\n        }\n\n        this.commands.set(normalizedCommand.name, normalizedCommand);\n      }\n    }\n\n    if (!options.doNotIncludeDefaultBuildCommands) {\n      let buildCommand: Command | undefined = this.commands.get(RushConstants.buildCommandName);\n      if (!buildCommand) {\n        // If the build command was not specified in the config file, add the default build command\n        buildCommand = this._translateBulkCommandToPhasedCommand(DEFAULT_BUILD_COMMAND_JSON);\n        buildCommand.disableBuildCache = DEFAULT_BUILD_COMMAND_JSON.disableBuildCache;\n        buildCommandPhases = buildCommand.phases;\n        this.commands.set(buildCommand.name, buildCommand);\n      }\n\n      if (!this.commands.has(RushConstants.rebuildCommandName)) {\n        // If a rebuild command was not specified in the config file, add the default rebuild command\n        if (!buildCommandPhases) {\n          throw new Error(`Phases for the \"${RushConstants.buildCommandName}\" were not found.`);\n        }\n\n        const rebuildCommand: IPhasedCommandConfig = {\n          ...DEFAULT_REBUILD_COMMAND_JSON,\n          commandKind: RushConstants.phasedCommandKind,\n          isSynthetic: true,\n          phases: buildCommandPhases,\n          disableBuildCache: DEFAULT_REBUILD_COMMAND_JSON.disableBuildCache,\n          associatedParameters: buildCommand.associatedParameters, // rebuild should share build's parameters in this case,\n          watchPhases: new Set(),\n          alwaysWatch: false,\n          alwaysInstall: undefined\n        };\n        this.commands.set(rebuildCommand.name, rebuildCommand);\n      }\n    }\n\n    const parametersJson: ICommandLineJson['parameters'] = commandLineJson?.parameters;\n    if (parametersJson) {\n      for (const parameter of parametersJson) {\n        const normalizedParameter: IParameterJson = {\n          ...parameter,\n          associatedPhases: parameter.associatedPhases ? [...parameter.associatedPhases] : [],\n          associatedCommands: parameter.associatedCommands ? [...parameter.associatedCommands] : []\n        };\n\n        this.parameters.push(normalizedParameter);\n\n        // Do some basic validation\n        switch (normalizedParameter.parameterKind) {\n          case 'choice': {\n            const alternativeNames: string[] = normalizedParameter.alternatives.map((x) => x.name);\n\n            if (\n              normalizedParameter.defaultValue &&\n              alternativeNames.indexOf(normalizedParameter.defaultValue) < 0\n            ) {\n              throw new Error(\n                `In ${RushConstants.commandLineFilename}, the parameter \"${normalizedParameter.longName}\",` +\n                  ` specifies a default value \"${normalizedParameter.defaultValue}\"` +\n                  ` which is not one of the defined alternatives: \"${alternativeNames.toString()}\"`\n              );\n            }\n\n            break;\n          }\n        }\n\n        let parameterHasAssociatedCommands: boolean = false;\n        if (normalizedParameter.associatedCommands) {\n          for (const associatedCommandName of normalizedParameter.associatedCommands) {\n            const syntheticPhase: IPhase | undefined =\n              this._syntheticPhasesByTranslatedBulkCommandName.get(associatedCommandName);\n            if (syntheticPhase) {\n              // If this parameter was associated with a bulk command, include the association\n              // with the synthetic phase\n              normalizedParameter.associatedPhases!.push(syntheticPhase.name);\n            }\n\n            const associatedCommand: Command | undefined = this.commands.get(associatedCommandName);\n            if (!associatedCommand) {\n              throw new Error(\n                `${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\" ` +\n                  `that is associated with a command \"${associatedCommandName}\" that does not exist or does ` +\n                  'not support custom parameters.'\n              );\n            } else {\n              associatedCommand.associatedParameters.add(normalizedParameter);\n              parameterHasAssociatedCommands = true;\n            }\n          }\n        }\n\n        if (normalizedParameter.associatedPhases) {\n          for (const associatedPhaseName of normalizedParameter.associatedPhases) {\n            const associatedPhase: IPhase | undefined = this.phases.get(associatedPhaseName);\n            if (!associatedPhase) {\n              throw new Error(\n                `${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\" ` +\n                  `that is associated with a phase \"${associatedPhaseName}\" that does not exist.`\n              );\n            }\n          }\n        }\n\n        if (!parameterHasAssociatedCommands) {\n          throw new Error(\n            `${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\"` +\n              ` that lists no associated commands.`\n          );\n        }\n\n        // In the presence of plugins, there is utility to defining parameters that are associated with a phased\n        // command but no phases. Don't enforce that a parameter is associated with at least one phase.\n      }\n    }\n  }\n\n  /**\n   * Performs a depth-first search to detect cycles in the directed graph of phase \"self\" dependencies.\n   *\n   * @param phase The phase node currently being checked\n   * @param phasesInPath The current path from the start node to `phase`\n   * @param cycleFreePhases Phases that have already been fully walked and confirmed to not be in any cycles\n   */\n  private _checkForPhaseSelfCycles(\n    phase: IPhase,\n    phasesInPath: Set<IPhase>,\n    cycleFreePhases: Set<IPhase>\n  ): void {\n    if (cycleFreePhases.has(phase)) {\n      // phase is known to not be reachable from itself, i.e. not in a cycle. Skip.\n      return;\n    }\n\n    for (const dependency of phase.dependencies.self) {\n      if (phasesInPath.has(dependency)) {\n        throw new Error(\n          `In ${RushConstants.commandLineFilename}, there exists a cycle within the ` +\n            `set of ${dependency.name} dependencies: ${Array.from(\n              phasesInPath,\n              (phase: IPhase) => phase.name\n            ).join(', ')}`\n        );\n      } else {\n        phasesInPath.add(dependency);\n        this._checkForPhaseSelfCycles(dependency, phasesInPath, cycleFreePhases);\n        phasesInPath.delete(dependency);\n      }\n    }\n\n    // phase is not reachable from itself, mark for skipping\n    cycleFreePhases.add(phase);\n  }\n\n  /**\n   * Load the command-line.json configuration file from the specified path. Note that this\n   * does not include the default build settings. This option is intended to be used to load\n   * command-line.json files from plugins. To load a common/config/rush/command-line.json file,\n   * use {@see loadFromFileOrDefault} instead.\n   *\n   * If the file does not exist, this function returns `undefined`\n   */\n  public static tryLoadFromFile(jsonFilePath: string): CommandLineConfiguration | undefined {\n    let commandLineJson: ICommandLineJson | undefined;\n    try {\n      commandLineJson = JsonFile.loadAndValidate(jsonFilePath, CommandLineConfiguration._jsonSchema);\n    } catch (e) {\n      if (!FileSystem.isNotExistError(e as Error)) {\n        throw e;\n      }\n    }\n\n    if (commandLineJson) {\n      return new CommandLineConfiguration(commandLineJson, { doNotIncludeDefaultBuildCommands: true });\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Loads the configuration from the specified file and applies any omitted default build\n   * settings.  If the file does not exist, then a default instance is returned.\n   * If the file contains errors, then an exception is thrown.\n   */\n  public static loadFromFileOrDefault(jsonFilePath?: string): CommandLineConfiguration {\n    let commandLineJson: ICommandLineJson | undefined = undefined;\n    if (jsonFilePath) {\n      try {\n        commandLineJson = JsonFile.load(jsonFilePath);\n      } catch (e) {\n        if (!FileSystem.isNotExistError(e as Error)) {\n          throw e;\n        }\n      }\n\n      // merge commands specified in command-line.json and default (re)build settings\n      // Ensure both build commands are included and preserve any other commands specified\n      if (commandLineJson?.commands) {\n        for (let i: number = 0; i < commandLineJson.commands.length; i++) {\n          const command: CommandJson = commandLineJson.commands[i];\n\n          // Determine if we have a set of default parameters\n          let commandDefaultDefinition: CommandJson | {} = {};\n          switch (command.commandKind) {\n            case RushConstants.phasedCommandKind:\n            case RushConstants.bulkCommandKind: {\n              switch (command.name) {\n                case RushConstants.buildCommandName: {\n                  commandDefaultDefinition = DEFAULT_BUILD_COMMAND_JSON;\n                  break;\n                }\n\n                case RushConstants.rebuildCommandName: {\n                  commandDefaultDefinition = DEFAULT_REBUILD_COMMAND_JSON;\n                  break;\n                }\n              }\n              break;\n            }\n          }\n\n          // Merge the default parameters into the repo-specified parameters\n          commandLineJson.commands[i] = {\n            ...commandDefaultDefinition,\n            ...command\n          };\n        }\n\n        CommandLineConfiguration._jsonSchema.validateObject(commandLineJson, jsonFilePath);\n      }\n    }\n\n    return new CommandLineConfiguration(commandLineJson, { doNotIncludeDefaultBuildCommands: false });\n  }\n\n  public get additionalPathFolders(): Readonly<string[]> {\n    return this._additionalPathFolders;\n  }\n\n  public prependAdditionalPathFolder(pathFolder: string): void {\n    this._additionalPathFolders.unshift(pathFolder);\n  }\n\n  /**\n   * This function replaces colons (\":\") with underscores (\"_\").\n   *\n   * ts-command-line restricts command names to lowercase letters, numbers, underscores, and colons.\n   * Replacing colons with underscores produces a filesystem-safe name.\n   */\n  private _normalizeNameForLogFilenameIdentifiers(name: string): string {\n    return name.replace(/:/g, '_'); // Replace colons with underscores to be filesystem-safe\n  }\n\n  private _translateBulkCommandToPhasedCommand(command: IBulkCommandJson): IPhasedCommandConfig {\n    const phaseName: string = command.name;\n    const phase: IPhase = {\n      name: phaseName,\n      isSynthetic: true,\n      logFilenameIdentifier: this._normalizeNameForLogFilenameIdentifiers(command.name),\n      associatedParameters: new Set(),\n      dependencies: {\n        self: new Set(),\n        upstream: new Set()\n      },\n      ignoreMissingScript: !!command.ignoreMissingScript,\n      allowWarningsOnSuccess: !!command.allowWarningsInSuccessfulBuild\n    };\n\n    if (!command.ignoreDependencyOrder) {\n      phase.dependencies.upstream.add(phase);\n    }\n\n    this.phases.set(phaseName, phase);\n    this._syntheticPhasesByTranslatedBulkCommandName.set(command.name, phase);\n\n    const phases: Set<IPhase> = new Set([phase]);\n\n    const translatedCommand: IPhasedCommandConfig = {\n      ...command,\n      commandKind: 'phased',\n      isSynthetic: true,\n      associatedParameters: new Set<IParameterJson>(),\n      phases,\n      // Bulk commands used the same phases for watch as for regular execution. Preserve behavior.\n      watchPhases: command.watchForChanges ? phases : new Set(),\n      alwaysWatch: !!command.watchForChanges,\n      alwaysInstall: undefined\n    };\n\n    return translatedCommand;\n  }\n}\n"]}