{"version":3,"file":"LookupByPath.js","sourceRoot":"","sources":["../../src/logic/LookupByPath.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/**\n * A node in the path tree used in LookupByPath\n */\ninterface IPathTreeNode<TItem> {\n  /**\n   * The value that exactly matches the current relative path\n   */\n  value: TItem | undefined;\n  /**\n   * Child nodes by subfolder\n   */\n  children: Map<string, IPathTreeNode<TItem>> | undefined;\n}\n\n/**\n * This class is used to associate POSIX relative paths, such as those returned by `git` commands,\n * with entities that correspond with ancestor folders, such as Rush Projects.\n *\n * It is optimized for efficiently locating the nearest ancestor path with an associated value.\n *\n * @example\n * ```ts\n * const tree = new LookupByPath([['foo', 1], ['bar', 2], ['foo/bar', 3]]);\n * tree.getNearestAncestor('foo'); // returns 1\n * tree.getNearestAncestor('foo/baz'); // returns 1\n * tree.getNearestAncestor('baz'); // returns undefined\n * tree.getNearestAncestor('foo/bar/baz'); returns 3\n * tree.getNearestAncestor('bar/foo/bar'); returns 2\n * ```\n * @beta\n */\nexport class LookupByPath<TItem> {\n  /**\n   * The delimiter used to split paths\n   */\n  public readonly delimiter: string;\n  /**\n   * The root node of the tree, corresponding to the path ''\n   */\n  private readonly _root: IPathTreeNode<TItem>;\n\n  /**\n   * Constructs a new `LookupByPath`\n   *\n   * @param entries - Initial path-value pairs to populate the tree.\n   */\n  public constructor(entries?: Iterable<[string, TItem]>, delimiter?: string) {\n    this._root = {\n      value: undefined,\n      children: undefined\n    };\n\n    this.delimiter = delimiter ?? '/';\n\n    if (entries) {\n      for (const [path, item] of entries) {\n        this.setItem(path, item);\n      }\n    }\n  }\n\n  /**\n   * Iterates over the segments of a serialized path.\n   *\n   * @example\n   *\n   * `LookupByPath.iteratePathSegments('foo/bar/baz')` yields 'foo', 'bar', 'baz'\n   *\n   * `LookupByPath.iteratePathSegments('foo\\\\bar\\\\baz', '\\\\')` yields 'foo', 'bar', 'baz'\n   */\n  public static *iteratePathSegments(serializedPath: string, delimiter: string = '/'): Iterable<string> {\n    if (!serializedPath) {\n      return;\n    }\n\n    let nextIndex: number = serializedPath.indexOf(delimiter);\n    let previousIndex: number = 0;\n    while (nextIndex >= 0) {\n      yield serializedPath.slice(previousIndex, nextIndex);\n\n      previousIndex = nextIndex + 1;\n      nextIndex = serializedPath.indexOf(delimiter, previousIndex);\n    }\n\n    if (previousIndex + 1 < serializedPath.length) {\n      yield serializedPath.slice(previousIndex);\n    }\n  }\n\n  /**\n   * Associates the value with the specified serialized path.\n   * If a value is already associated, will overwrite.\n   *\n   * @returns this, for chained calls\n   */\n  public setItem(serializedPath: string, value: TItem): this {\n    return this.setItemFromSegments(LookupByPath.iteratePathSegments(serializedPath, this.delimiter), value);\n  }\n\n  /**\n   * Associates the value with the specified path.\n   * If a value is already associated, will overwrite.\n   *\n   * @returns this, for chained calls\n   */\n  public setItemFromSegments(pathSegments: Iterable<string>, value: TItem): this {\n    let node: IPathTreeNode<TItem> = this._root;\n    for (const segment of pathSegments) {\n      if (!node.children) {\n        node.children = new Map();\n      }\n      let child: IPathTreeNode<TItem> | undefined = node.children.get(segment);\n      if (!child) {\n        node.children.set(\n          segment,\n          (child = {\n            value: undefined,\n            children: undefined\n          })\n        );\n      }\n      node = child;\n    }\n    node.value = value;\n\n    return this;\n  }\n\n  /**\n   * Searches for the item associated with `childPath`, or the nearest ancestor of that path that\n   * has an associated item.\n   *\n   * @returns the found item, or `undefined` if no item was found\n   *\n   * @example\n   * ```ts\n   * const tree = new LookupByPath([['foo', 1], ['foo/bar', 2]]);\n   * tree.findChildPath('foo/baz'); // returns 1\n   * tree.findChildPath('foo/bar/baz'); // returns 2\n   * ```\n   */\n  public findChildPath(childPath: string): TItem | undefined {\n    return this.findChildPathFromSegments(LookupByPath.iteratePathSegments(childPath, this.delimiter));\n  }\n\n  /**\n   * Searches for the item associated with `childPathSegments`, or the nearest ancestor of that path that\n   * has an associated item.\n   *\n   * @returns the found item, or `undefined` if no item was found\n   *\n   * @example\n   * ```ts\n   * const tree = new LookupByPath([['foo', 1], ['foo/bar', 2]]);\n   * tree.findChildPathFromSegments(['foo', 'baz']); // returns 1\n   * tree.findChildPathFromSegments(['foo','bar', 'baz']); // returns 2\n   * ```\n   */\n  public findChildPathFromSegments(childPathSegments: Iterable<string>): TItem | undefined {\n    let node: IPathTreeNode<TItem> = this._root;\n    let best: TItem | undefined = node.value;\n    // Trivial cases\n    if (node.children) {\n      for (const segment of childPathSegments) {\n        const child: IPathTreeNode<TItem> | undefined = node.children.get(segment);\n        if (!child) {\n          break;\n        }\n        node = child;\n        best = node.value ?? best;\n        if (!node.children) {\n          break;\n        }\n      }\n    }\n\n    return best;\n  }\n}\n"]}