"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertSlashesForWindows = exports.ShellOperationRunner = void 0;
const path = __importStar(require("path"));
const node_core_library_1 = require("@rushstack/node-core-library");
const terminal_1 = require("@rushstack/terminal");
const stream_collator_1 = require("@rushstack/stream-collator");
const Utilities_1 = require("../../utilities/Utilities");
const OperationStatus_1 = require("./OperationStatus");
const OperationError_1 = require("./OperationError");
const ProjectLogWritable_1 = require("./ProjectLogWritable");
const ProjectBuildCache_1 = require("../buildCache/ProjectBuildCache");
const RushProjectConfiguration_1 = require("../../api/RushProjectConfiguration");
const CollatedTerminalProvider_1 = require("../../utilities/CollatedTerminalProvider");
const RushConstants_1 = require("../RushConstants");
const EnvironmentConfiguration_1 = require("../../api/EnvironmentConfiguration");
function _areShallowEqual(object1, object2) {
    for (const n in object1) {
        if (!(n in object2) || object1[n] !== object2[n]) {
            return false;
        }
    }
    for (const n in object2) {
        if (!(n in object1)) {
            return false;
        }
    }
    return true;
}
/**
 * An `IOperationRunner` subclass that performs an operation via a shell command.
 * Currently contains the build cache logic, pending extraction as separate operations.
 * Supports skipping an operation if allowed and it is already up-to-date.
 */
class ShellOperationRunner {
    constructor(options) {
        // This runner supports cache writes by default.
        this.isCacheWriteAllowed = true;
        this.reportTiming = true;
        this.silent = false;
        /**
         * UNINITIALIZED === we haven't tried to initialize yet
         * undefined === we didn't create one because the feature is not enabled
         */
        this._projectBuildCache = Utilities_1.UNINITIALIZED;
        const { phase } = options;
        this.name = options.displayName;
        this._rushProject = options.rushProject;
        this._phase = phase;
        this._rushConfiguration = options.rushConfiguration;
        this._buildCacheConfiguration = options.buildCacheConfiguration;
        this._commandName = phase.name;
        this._commandToRun = options.commandToRun;
        this._isCacheReadAllowed = options.isIncrementalBuildAllowed;
        this.isSkipAllowed = options.isIncrementalBuildAllowed;
        this._projectChangeAnalyzer = options.projectChangeAnalyzer;
        this._packageDepsFilename = `package-deps_${phase.logFilenameIdentifier}.json`;
        this.warningsAreAllowed =
            EnvironmentConfiguration_1.EnvironmentConfiguration.allowWarningsInSuccessfulBuild || phase.allowWarningsOnSuccess || false;
        this._logFilenameIdentifier = phase.logFilenameIdentifier;
        this._selectedPhases = options.selectedPhases;
    }
    async executeAsync(context) {
        try {
            return await this._executeAsync(context);
        }
        catch (error) {
            throw new OperationError_1.OperationError('executing', error.message);
        }
    }
    async _executeAsync(context) {
        var _a;
        // TERMINAL PIPELINE:
        //
        //                             +--> quietModeTransform? --> collatedWriter
        //                             |
        // normalizeNewlineTransform --1--> stderrLineTransform --2--> removeColorsTransform --> projectLogWritable
        //                                                        |
        //                                                        +--> stdioSummarizer
        const projectLogWritable = new ProjectLogWritable_1.ProjectLogWritable(this._rushProject, context.collatedWriter.terminal, this._logFilenameIdentifier);
        try {
            const removeColorsTransform = new terminal_1.TextRewriterTransform({
                destination: projectLogWritable,
                removeColors: true,
                normalizeNewlines: node_core_library_1.NewlineKind.OsDefault
            });
            const splitterTransform2 = new terminal_1.SplitterTransform({
                destinations: [removeColorsTransform, context.stdioSummarizer]
            });
            const stderrLineTransform = new terminal_1.StderrLineTransform({
                destination: splitterTransform2,
                newlineKind: node_core_library_1.NewlineKind.Lf // for StdioSummarizer
            });
            const discardTransform = new terminal_1.DiscardStdoutTransform({
                destination: context.collatedWriter
            });
            const splitterTransform1 = new terminal_1.SplitterTransform({
                destinations: [context.quietMode ? discardTransform : context.collatedWriter, stderrLineTransform]
            });
            const normalizeNewlineTransform = new terminal_1.TextRewriterTransform({
                destination: splitterTransform1,
                normalizeNewlines: node_core_library_1.NewlineKind.Lf,
                ensureNewlineAtEnd: true
            });
            const collatedTerminal = new stream_collator_1.CollatedTerminal(normalizeNewlineTransform);
            const terminalProvider = new CollatedTerminalProvider_1.CollatedTerminalProvider(collatedTerminal, {
                debugEnabled: context.debugMode
            });
            const terminal = new node_core_library_1.Terminal(terminalProvider);
            let hasWarningOrError = false;
            const projectFolder = this._rushProject.projectFolder;
            let lastProjectDeps = undefined;
            const currentDepsPath = path.join(this._rushProject.projectRushTempFolder, this._packageDepsFilename);
            if (node_core_library_1.FileSystem.exists(currentDepsPath)) {
                try {
                    lastProjectDeps = node_core_library_1.JsonFile.load(currentDepsPath);
                }
                catch (e) {
                    // Warn and ignore - treat failing to load the file as the project being not built.
                    terminal.writeWarningLine(`Warning: error parsing ${this._packageDepsFilename}: ${e}. Ignoring and ` +
                        `treating the command "${this._commandToRun}" as not run.`);
                }
            }
            let projectDeps;
            let trackedFiles;
            try {
                const fileHashes = await this._projectChangeAnalyzer._tryGetProjectDependenciesAsync(this._rushProject, terminal);
                if (fileHashes) {
                    const files = {};
                    trackedFiles = [];
                    for (const [filePath, fileHash] of fileHashes) {
                        files[filePath] = fileHash;
                        trackedFiles.push(filePath);
                    }
                    projectDeps = {
                        files,
                        arguments: this._commandToRun
                    };
                }
                else if (this.isSkipAllowed) {
                    // To test this code path:
                    // Remove the `.git` folder then run "rush build --verbose"
                    terminal.writeLine({
                        text: terminal_1.PrintUtilities.wrapWords('This workspace does not appear to be tracked by Git. ' +
                            'Rush will proceed without incremental execution, caching, and change detection.'),
                        foregroundColor: node_core_library_1.ColorValue.Cyan
                    });
                }
            }
            catch (error) {
                // To test this code path:
                // Delete a project's ".rush/temp/shrinkwrap-deps.json" then run "rush build --verbose"
                terminal.writeLine('Unable to calculate incremental state: ' + error.toString());
                terminal.writeLine({
                    text: 'Rush will proceed without incremental execution, caching, and change detection.',
                    foregroundColor: node_core_library_1.ColorValue.Cyan
                });
            }
            // If possible, we want to skip this operation -- either by restoring it from the
            // cache, if caching is enabled, or determining that the project
            // is unchanged (using the older incremental execution logic). These two approaches,
            // "caching" and "skipping", are incompatible, so only one applies.
            //
            // Note that "caching" and "skipping" take two different approaches
            // to tracking dependents:
            //
            //   - For caching, "isCacheReadAllowed" is set if a project supports
            //     incremental builds, and determining whether this project or a dependent
            //     has changed happens inside the hashing logic.
            //
            //   - For skipping, "isSkipAllowed" is set to true initially, and during
            //     the process of running dependents, it will be changed by OperationExecutionManager to
            //     false if a dependency wasn't able to be skipped.
            //
            let buildCacheReadAttempted = false;
            if (this._isCacheReadAllowed) {
                const projectBuildCache = await this._tryGetProjectBuildCacheAsync(terminal, trackedFiles);
                buildCacheReadAttempted = !!projectBuildCache;
                const restoreFromCacheSuccess = await (projectBuildCache === null || projectBuildCache === void 0 ? void 0 : projectBuildCache.tryRestoreFromCacheAsync(terminal));
                if (restoreFromCacheSuccess) {
                    return OperationStatus_1.OperationStatus.FromCache;
                }
            }
            if (this.isSkipAllowed && !buildCacheReadAttempted) {
                const isPackageUnchanged = !!(lastProjectDeps &&
                    projectDeps &&
                    projectDeps.arguments === lastProjectDeps.arguments &&
                    _areShallowEqual(projectDeps.files, lastProjectDeps.files));
                if (isPackageUnchanged) {
                    return OperationStatus_1.OperationStatus.Skipped;
                }
            }
            // If the deps file exists, remove it before starting execution.
            node_core_library_1.FileSystem.deleteFile(currentDepsPath);
            // TODO: Remove legacyDepsPath with the next major release of Rush
            const legacyDepsPath = path.join(this._rushProject.projectFolder, 'package-deps.json');
            // Delete the legacy package-deps.json
            node_core_library_1.FileSystem.deleteFile(legacyDepsPath);
            if (!this._commandToRun) {
                // Write deps on success.
                if (projectDeps) {
                    node_core_library_1.JsonFile.save(projectDeps, currentDepsPath, {
                        ensureFolderExists: true
                    });
                }
                return OperationStatus_1.OperationStatus.Success;
            }
            // Run the operation
            terminal.writeLine('Invoking: ' + this._commandToRun);
            const subProcess = Utilities_1.Utilities.executeLifecycleCommandAsync(this._commandToRun, {
                rushConfiguration: this._rushConfiguration,
                workingDirectory: projectFolder,
                initCwd: this._rushConfiguration.commonTempFolder,
                handleOutput: true,
                environmentPathOptions: {
                    includeProjectBin: true
                }
            });
            // Hook into events, in order to get live streaming of the log
            if (subProcess.stdout !== null) {
                subProcess.stdout.on('data', (data) => {
                    const text = data.toString();
                    collatedTerminal.writeChunk({ text, kind: "O" /* Stdout */ });
                });
            }
            if (subProcess.stderr !== null) {
                subProcess.stderr.on('data', (data) => {
                    const text = data.toString();
                    collatedTerminal.writeChunk({ text, kind: "E" /* Stderr */ });
                    hasWarningOrError = true;
                });
            }
            let status = await new Promise((resolve, reject) => {
                subProcess.on('close', (code) => {
                    try {
                        if (code !== 0) {
                            reject(new OperationError_1.OperationError('error', `Returned error code: ${code}`));
                        }
                        else if (hasWarningOrError) {
                            resolve(OperationStatus_1.OperationStatus.SuccessWithWarning);
                        }
                        else {
                            resolve(OperationStatus_1.OperationStatus.Success);
                        }
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            });
            const taskIsSuccessful = status === OperationStatus_1.OperationStatus.Success ||
                (status === OperationStatus_1.OperationStatus.SuccessWithWarning &&
                    this.warningsAreAllowed &&
                    !!this._rushConfiguration.experimentsConfiguration.configuration
                        .buildCacheWithAllowWarningsInSuccessfulBuild);
            if (taskIsSuccessful && projectDeps) {
                // Write deps on success.
                const writeProjectStatePromise = node_core_library_1.JsonFile.saveAsync(projectDeps, currentDepsPath, {
                    ensureFolderExists: true
                });
                // If the command is successful, we can calculate project hash, and no dependencies were skipped,
                // write a new cache entry.
                const setCacheEntryPromise = this.isCacheWriteAllowed
                    ? (_a = (await this._tryGetProjectBuildCacheAsync(terminal, trackedFiles))) === null || _a === void 0 ? void 0 : _a.trySetCacheEntryAsync(terminal)
                    : undefined;
                const [, cacheWriteSuccess] = await Promise.all([writeProjectStatePromise, setCacheEntryPromise]);
                if (terminalProvider.hasErrors) {
                    status = OperationStatus_1.OperationStatus.Failure;
                }
                else if (cacheWriteSuccess === false) {
                    status = OperationStatus_1.OperationStatus.SuccessWithWarning;
                }
            }
            normalizeNewlineTransform.close();
            // If the pipeline is wired up correctly, then closing normalizeNewlineTransform should
            // have closed projectLogWritable.
            if (projectLogWritable.isOpen) {
                throw new node_core_library_1.InternalError('The output file handle was not closed');
            }
            return status;
        }
        finally {
            projectLogWritable.close();
        }
    }
    async _tryGetProjectBuildCacheAsync(terminal, trackedProjectFiles) {
        if (this._projectBuildCache === Utilities_1.UNINITIALIZED) {
            this._projectBuildCache = undefined;
            if (this._buildCacheConfiguration && this._buildCacheConfiguration.buildCacheEnabled) {
                // Disable legacy skip logic if the build cache is in play
                this.isSkipAllowed = false;
                const projectConfiguration = await RushProjectConfiguration_1.RushProjectConfiguration.tryLoadForProjectAsync(this._rushProject, terminal);
                if (projectConfiguration) {
                    projectConfiguration.validatePhaseConfiguration(this._selectedPhases, terminal);
                    if (projectConfiguration.disableBuildCacheForProject) {
                        terminal.writeVerboseLine('Caching has been disabled for this project.');
                    }
                    else {
                        const operationSettings = projectConfiguration.operationSettingsByOperationName.get(this._commandName);
                        if (!operationSettings) {
                            terminal.writeVerboseLine(`This project does not define the caching behavior of the "${this._commandName}" command, so caching has been disabled.`);
                        }
                        else if (operationSettings.disableBuildCacheForOperation) {
                            terminal.writeVerboseLine(`Caching has been disabled for this project's "${this._commandName}" command.`);
                        }
                        else {
                            const projectOutputFolderNames = operationSettings.outputFolderNames || [];
                            this._projectBuildCache = await ProjectBuildCache_1.ProjectBuildCache.tryGetProjectBuildCache({
                                projectConfiguration,
                                projectOutputFolderNames,
                                buildCacheConfiguration: this._buildCacheConfiguration,
                                terminal,
                                command: this._commandToRun,
                                trackedProjectFiles: trackedProjectFiles,
                                projectChangeAnalyzer: this._projectChangeAnalyzer,
                                phaseName: this._phase.name
                            });
                        }
                    }
                }
                else {
                    terminal.writeVerboseLine(`Project does not have a ${RushConstants_1.RushConstants.rushProjectConfigFilename} configuration file, ` +
                        'or one provided by a rig, so it does not support caching.');
                }
            }
        }
        return this._projectBuildCache;
    }
}
exports.ShellOperationRunner = ShellOperationRunner;
/**
 * When running a command from the "scripts" block in package.json, if the command
 * contains Unix-style path slashes and the OS is Windows, the package managers will
 * convert slashes to backslashes.  This is a complicated undertaking.  For example, they
 * need to convert "node_modules/bin/this && ./scripts/that --name keep/this"
 * to "node_modules\bin\this && .\scripts\that --name keep/this", and they don't want to
 * convert ANY of the slashes in "cmd.exe /c echo a/b".  NPM and PNPM use npm-lifecycle for this,
 * but it unfortunately has a dependency on the entire node-gyp kitchen sink.  Yarn has a
 * simplified implementation in fix-cmd-win-slashes.js, but it's not exposed as a library.
 *
 * Fundamentally NPM's whole feature seems misguided:  They start by inviting people to write
 * shell scripts that will be executed by wildly different shell languages (e.g. cmd.exe and Bash).
 * It's very tricky for a developer to guess what's safe to do without testing every OS.
 * Even simple path separators are not portable, so NPM added heuristics to figure out which
 * slashes are part of a path or not, and convert them.  These workarounds end up having tons
 * of special cases.  They probably could have implemented their own entire minimal cross-platform
 * shell language with less code and less confusion than npm-lifecycle's approach.
 *
 * We've deprecated shell operators inside package.json.  Instead, we advise people to move their
 * scripts into conventional script files, and put only a file path in package.json.  So, for
 * Rush's workaround here, we really only care about supporting the small set of cases seen in the
 * unit tests.  For anything that doesn't fit those patterns, we leave the string untouched
 * (i.e. err on the side of not breaking anything).  We could revisit this later if someone
 * complains about it, but so far nobody has.  :-)
 */
function convertSlashesForWindows(command) {
    // The first group will match everything up to the first space, "&", "|", "<", ">", or quote.
    // The second group matches the remainder.
    const commandRegExp = /^([^\s&|<>"]+)(.*)$/;
    const match = commandRegExp.exec(command);
    if (match) {
        // Example input: "bin/blarg --path ./config/blah.json && a/b"
        // commandPart="bin/blarg"
        // remainder=" --path ./config/blah.json && a/b"
        const commandPart = match[1];
        const remainder = match[2];
        // If the command part already contains a backslash, then leave it alone
        if (commandPart.indexOf('\\') < 0) {
            // Replace all the slashes with backslashes, e.g. to produce:
            // "bin\blarg --path ./config/blah.json && a/b"
            //
            // NOTE: we don't attempt to process the path parameter or stuff after "&&"
            return node_core_library_1.Text.replaceAll(commandPart, '/', '\\') + remainder;
        }
    }
    // Don't change anything
    return command;
}
exports.convertSlashesForWindows = convertSlashesForWindows;
//# sourceMappingURL=ShellOperationRunner.js.map