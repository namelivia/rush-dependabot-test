"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._printTimeline = exports.ConsoleTimelinePlugin = void 0;
const safe_1 = __importDefault(require("colors/safe"));
const OperationStatus_1 = require("./OperationStatus");
const PLUGIN_NAME = 'ConsoleTimelinePlugin';
/* Sample output:
==============================================================================================================================
          @rushstack/tree-pattern (build) ###########-------------------------------------------------------------------- 3.3s
          @rushstack/eslint-patch (build) ########----------------------------------------------------------------------- 2.2s
           @rushstack/eslint-patch (test) -------%----------------------------------------------------------------------- 0.0s
@rushstack/eslint-plugin-security (build) ----------########################--------------------------------------------- 6.8s
@rushstack/eslint-plugin-packlets (build) ----------############################----------------------------------------- 8.1s
         @rushstack/eslint-plugin (build) ----------##############################--------------------------------------- 8.7s
           @rushstack/tree-pattern (test) ----------#####---------------------------------------------------------------- 1.2s
 @rushstack/eslint-plugin-security (test) ---------------------------------############---------------------------------- 3.3s
 @rushstack/eslint-plugin-packlets (test) -------------------------------------#####------------------------------------- 1.1s
         @rushstack/eslint-config (build) ---------------------------------------%--------------------------------------- 0.0s
          @rushstack/eslint-plugin (test) ---------------------------------------#############--------------------------- 3.8s
          @rushstack/eslint-config (test) ---------------------------------------%--------------------------------------- 0.0s
     @rushstack/node-core-library (build) ---------------------------------------################################-------- 9.5s
      @rushstack/node-core-library (test) ----------------------------------------------------------------------######### 2.2s
==============================================================================================================================
LEGEND:                                                                                                      Total Work: 50.3s
  [#] Success  [!] Failed/warnings  [%] Skipped/cached/no-op                                                 Wall Clock: 23.7s
                                                                                                       Max Parallelism Used: 5
                                                                                                     Avg Parallelism Used: 2.1
BY PHASE:
      _phase:build 38.6s
       _phase:test 11.7s
*/
/**
 * Phased command plugin that emits a timeline to the console.
 */
class ConsoleTimelinePlugin {
    constructor(terminal) {
        this._terminal = terminal;
    }
    apply(hooks) {
        hooks.afterExecuteOperations.tap(PLUGIN_NAME, (result, context) => {
            _printTimeline(this._terminal, result);
        });
    }
}
exports.ConsoleTimelinePlugin = ConsoleTimelinePlugin;
/**
 * Timeline - a wider column width for printing the timeline summary
 */
const TIMELINE_WIDTH = 109;
/**
 * Timeline - symbols representing each operation status
 */
const TIMELINE_CHART_SYMBOLS = {
    [OperationStatus_1.OperationStatus.Ready]: '?',
    [OperationStatus_1.OperationStatus.Executing]: '?',
    [OperationStatus_1.OperationStatus.Success]: '#',
    [OperationStatus_1.OperationStatus.SuccessWithWarning]: '!',
    [OperationStatus_1.OperationStatus.Failure]: '!',
    [OperationStatus_1.OperationStatus.Blocked]: '.',
    [OperationStatus_1.OperationStatus.Skipped]: '%',
    [OperationStatus_1.OperationStatus.FromCache]: '%',
    [OperationStatus_1.OperationStatus.NoOp]: '%'
};
/**
 * Timeline - colorizer for each operation status
 */
const TIMELINE_CHART_COLORIZER = {
    [OperationStatus_1.OperationStatus.Ready]: safe_1.default.yellow,
    [OperationStatus_1.OperationStatus.Executing]: safe_1.default.yellow,
    [OperationStatus_1.OperationStatus.Success]: safe_1.default.green,
    [OperationStatus_1.OperationStatus.SuccessWithWarning]: safe_1.default.yellow,
    [OperationStatus_1.OperationStatus.Failure]: safe_1.default.red,
    [OperationStatus_1.OperationStatus.Blocked]: safe_1.default.red,
    [OperationStatus_1.OperationStatus.Skipped]: safe_1.default.green,
    [OperationStatus_1.OperationStatus.FromCache]: safe_1.default.green,
    [OperationStatus_1.OperationStatus.NoOp]: safe_1.default.gray
};
/**
 * Print a more detailed timeline and analysis of CPU usage for the build.
 * @internal
 */
function _printTimeline(terminal, result) {
    //
    // Gather the operation records we'll be displaying. Do some inline max()
    // finding to reduce the number of times we need to loop through operations.
    //
    var _a, _b;
    const durationByPhase = new Map();
    const data = [];
    let longestNameLength = 0;
    let longestDurationLength = 0;
    let allStart = Infinity;
    let allEnd = -Infinity;
    let workDuration = 0;
    for (const [operation, operationResult] of result.operationResults) {
        if ((_a = operation.runner) === null || _a === void 0 ? void 0 : _a.silent) {
            continue;
        }
        const { stopwatch } = operationResult;
        const { startTime, endTime } = stopwatch;
        if (startTime && endTime) {
            const nameLength = ((_b = operation.name) === null || _b === void 0 ? void 0 : _b.length) || 0;
            if (nameLength > longestNameLength) {
                longestNameLength = nameLength;
            }
            const { duration } = stopwatch;
            const durationString = duration.toFixed(1);
            const durationLength = durationString.length;
            if (durationLength > longestDurationLength) {
                longestDurationLength = durationLength;
            }
            if (endTime > allEnd) {
                allEnd = endTime;
            }
            if (startTime < allStart) {
                allStart = startTime;
            }
            workDuration += duration;
            const { associatedPhase } = operation;
            if (associatedPhase) {
                durationByPhase.set(associatedPhase, (durationByPhase.get(associatedPhase) || 0) + duration);
            }
            data.push({
                startTime,
                endTime,
                durationString,
                name: operation.name,
                status: operationResult.status
            });
        }
    }
    data.sort((a, b) => a.startTime - b.startTime);
    //
    // Determine timing for all tasks (wall clock and execution times)
    //
    const allDuration = allEnd - allStart;
    const allDurationSeconds = allDuration / 1000;
    //
    // Do some calculations to determine what size timeline chart we need.
    //
    const maxWidth = process.stdout.columns || TIMELINE_WIDTH;
    const chartWidth = maxWidth - longestNameLength - longestDurationLength - 4;
    //
    // Loop through all operations, assembling some statistics about operations and
    // phases, if applicable.
    //
    const busyCpus = [];
    function getOpenCPU(time) {
        const len = busyCpus.length;
        for (let i = 0; i < len; i++) {
            if (busyCpus[i] <= time) {
                return i;
            }
        }
        return len;
    }
    // Start with a newline
    terminal.writeLine('');
    terminal.writeLine('='.repeat(maxWidth));
    for (const { startTime, endTime, durationString, name, status } of data) {
        // Track busy CPUs
        const openCpu = getOpenCPU(startTime);
        busyCpus[openCpu] = endTime;
        // Build timeline chart
        const startIdx = Math.floor(((startTime - allStart) * chartWidth) / allDuration);
        const endIdx = Math.floor(((endTime - allStart) * chartWidth) / allDuration);
        const length = endIdx - startIdx + 1;
        const chart = safe_1.default.gray('-'.repeat(startIdx)) +
            TIMELINE_CHART_COLORIZER[status](TIMELINE_CHART_SYMBOLS[status].repeat(length)) +
            safe_1.default.gray('-'.repeat(chartWidth - endIdx));
        terminal.writeLine(`${safe_1.default.cyan(name.padStart(longestNameLength))} ${chart} ${safe_1.default.white(durationString.padStart(longestDurationLength) + 's')}`);
    }
    terminal.writeLine('='.repeat(maxWidth));
    //
    // Format legend and summary areas
    //
    const usedCpus = busyCpus.length;
    const legend = ['LEGEND:', '  [#] Success  [!] Failed/warnings  [%] Skipped/cached/no-op'];
    const summary = [
        `Total Work: ${workDuration.toFixed(1)}s`,
        `Wall Clock: ${allDurationSeconds.toFixed(1)}s`
    ];
    terminal.writeLine(legend[0] + summary[0].padStart(maxWidth - legend[0].length));
    terminal.writeLine(legend[1] + summary[1].padStart(maxWidth - legend[1].length));
    terminal.writeLine(`Max Parallelism Used: ${usedCpus}`.padStart(maxWidth));
    terminal.writeLine(`Avg Parallelism Used: ${(workDuration / allDurationSeconds).toFixed(1)}`.padStart(maxWidth));
    //
    // Include time-by-phase, if phases are enabled
    //
    if (durationByPhase.size > 0) {
        terminal.writeLine('BY PHASE:');
        let maxPhaseName = 16;
        for (const phase of durationByPhase.keys()) {
            const len = phase.name.length;
            if (len > maxPhaseName) {
                maxPhaseName = len;
            }
        }
        for (const [phase, duration] of durationByPhase.entries()) {
            terminal.writeLine(`  ${safe_1.default.cyan(phase.name.padStart(maxPhaseName))} ${duration.toFixed(1)}s`);
        }
    }
    terminal.writeLine('');
}
exports._printTimeline = _printTimeline;
//# sourceMappingURL=ConsoleTimelinePlugin.js.map