"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.OperationExecutionRecord = void 0;
const terminal_1 = require("@rushstack/terminal");
const node_core_library_1 = require("@rushstack/node-core-library");
const OperationStatus_1 = require("./OperationStatus");
const Stopwatch_1 = require("../../utilities/Stopwatch");
/**
 * Internal class representing everything about executing an operation
 */
class OperationExecutionRecord {
    constructor(operation, context) {
        var _a, _b;
        /**
         * The current execution status of an operation. Operations start in the 'ready' state,
         * but can be 'blocked' if an upstream operation failed. It is 'executing' when
         * the operation is executing. Once execution is complete, it is either 'success' or
         * 'failure'.
         */
        this.status = OperationStatus_1.OperationStatus.Ready;
        /**
         * The error which occurred while executing this operation, this is stored in case we need
         * it later (for example to re-print errors at end of execution).
         */
        this.error = undefined;
        /**
         * This number represents how far away this Operation is from the furthest "root" operation (i.e.
         * an operation with no consumers). This helps us to calculate the critical path (i.e. the
         * longest chain of projects which must be executed in order, thereby limiting execution speed
         * of the entire operation tree.
         *
         * This number is calculated via a memoized depth-first search, and when choosing the next
         * operation to execute, the operation with the highest criticalPathLength is chosen.
         *
         * Example:
         *        (0) A
         *             \
         *          (1) B     C (0)         (applications)
         *               \   /|\
         *                \ / | \
         *             (2) D  |  X (1)      (utilities)
         *                    | / \
         *                    |/   \
         *                (2) Y     Z (2)   (other utilities)
         *
         * All roots (A & C) have a criticalPathLength of 0.
         * B has a score of 1, since A depends on it.
         * D has a score of 2, since we look at the longest chain (e.g D->B->A is longer than D->C)
         * X has a score of 1, since the only package which depends on it is A
         * Z has a score of 2, since only X depends on it, and X has a score of 1
         * Y has a score of 2, since the chain Y->X->C is longer than Y->C
         *
         * The algorithm is implemented in AsyncOperationQueue.ts as calculateCriticalPathLength()
         */
        this.criticalPathLength = undefined;
        /**
         * The set of operations that must complete before this operation executes.
         */
        this.dependencies = new Set();
        /**
         * The set of operations that depend on this operation.
         */
        this.consumers = new Set();
        this.stopwatch = new Stopwatch_1.Stopwatch();
        this.stdioSummarizer = new terminal_1.StdioSummarizer();
        this._collatedWriter = undefined;
        const { runner } = operation;
        if (!runner) {
            throw new node_core_library_1.InternalError(`Operation for phase '${(_a = operation.associatedPhase) === null || _a === void 0 ? void 0 : _a.name}' and project '${(_b = operation.associatedProject) === null || _b === void 0 ? void 0 : _b.packageName}' has no runner.`);
        }
        this.runner = runner;
        this.weight = operation.weight;
        this._context = context;
    }
    get name() {
        return this.runner.name;
    }
    get debugMode() {
        return this._context.debugMode;
    }
    get quietMode() {
        return this._context.quietMode;
    }
    get collatedWriter() {
        // Lazy instantiate because the registerTask() call affects display ordering
        if (!this._collatedWriter) {
            this._collatedWriter = this._context.streamCollator.registerTask(this.name);
        }
        return this._collatedWriter;
    }
    async executeAsync(onResult) {
        var _a;
        this.status = OperationStatus_1.OperationStatus.Executing;
        this.stopwatch.start();
        try {
            this.status = await this.runner.executeAsync(this);
            // Delegate global state reporting
            onResult(this);
        }
        catch (error) {
            this.status = OperationStatus_1.OperationStatus.Failure;
            this.error = error;
            // Delegate global state reporting
            onResult(this);
        }
        finally {
            (_a = this._collatedWriter) === null || _a === void 0 ? void 0 : _a.close();
            this.stdioSummarizer.close();
            this.stopwatch.stop();
        }
    }
}
exports.OperationExecutionRecord = OperationExecutionRecord;
//# sourceMappingURL=OperationExecutionRecord.js.map