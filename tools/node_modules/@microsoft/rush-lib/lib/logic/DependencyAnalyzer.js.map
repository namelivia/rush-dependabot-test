{"version":3,"file":"DependencyAnalyzer.js","sourceRoot":"","sources":["../../src/logic/DependencyAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as semver from 'semver';\nimport { CommonVersionsConfiguration } from '../api/CommonVersionsConfiguration';\nimport { DependencyType, PackageJsonDependency } from '../api/PackageJsonEditor';\nimport { RushConfiguration } from '../api/RushConfiguration';\nimport { RushConfigurationProject } from '../api/RushConfigurationProject';\n\nexport interface IDependencyAnalysis {\n  /**\n   * The common versions configuration from the repo's rush configuration.\n   */\n  commonVersionsConfiguration: CommonVersionsConfiguration;\n\n  /**\n   * A map of all direct dependencies that only have a single semantic version specifier,\n   * unless the variant has the {@link CommonVersionsConfiguration.implicitlyPreferredVersions} option\n   * set to `false`.\n   */\n  implicitlyPreferredVersionByPackageName: Map<string, string>;\n\n  /**\n   * A map of dependency name to the set of version specifiers used in the repo.\n   */\n  allVersionsByPackageName: Map<string, Set<string>>;\n}\n\nexport class DependencyAnalyzer {\n  private static _dependencyAnalyzerByRushConfiguration:\n    | WeakMap<RushConfiguration, DependencyAnalyzer>\n    | undefined;\n\n  private _rushConfiguration: RushConfiguration;\n  private _analysisByVariant: Map<string, IDependencyAnalysis> = new Map();\n\n  private constructor(rushConfiguration: RushConfiguration) {\n    this._rushConfiguration = rushConfiguration;\n  }\n\n  public static forRushConfiguration(rushConfiguration: RushConfiguration): DependencyAnalyzer {\n    if (!DependencyAnalyzer._dependencyAnalyzerByRushConfiguration) {\n      DependencyAnalyzer._dependencyAnalyzerByRushConfiguration = new WeakMap();\n    }\n\n    let analyzer: DependencyAnalyzer | undefined =\n      DependencyAnalyzer._dependencyAnalyzerByRushConfiguration.get(rushConfiguration);\n    if (!analyzer) {\n      analyzer = new DependencyAnalyzer(rushConfiguration);\n      DependencyAnalyzer._dependencyAnalyzerByRushConfiguration.set(rushConfiguration, analyzer);\n    }\n\n    return analyzer;\n  }\n\n  public getAnalysis(variant?: string): IDependencyAnalysis {\n    // Use an empty string as the key when no variant provided. Anything else would possibly conflict\n    // with a variant created by the user\n    const variantKey: string = variant || '';\n    let analysis: IDependencyAnalysis | undefined = this._analysisByVariant.get(variantKey);\n    if (!analysis) {\n      analysis = this._getAnalysisInternal(variant);\n      this._analysisByVariant.set(variantKey, analysis);\n    }\n\n    return analysis;\n  }\n\n  /**\n   * Generates the {@link IDependencyAnalysis} for a variant.\n   *\n   * @remarks\n   * The result of this function is not cached.\n   */\n  private _getAnalysisInternal(variant: string | undefined): IDependencyAnalysis {\n    const commonVersionsConfiguration: CommonVersionsConfiguration =\n      this._rushConfiguration.getCommonVersions(variant);\n    const allVersionsByPackageName: Map<string, Set<string>> = new Map();\n    const allowedAlternativeVersions: Map<\n      string,\n      ReadonlyArray<string>\n    > = commonVersionsConfiguration.allowedAlternativeVersions;\n\n    for (const project of this._rushConfiguration.projects) {\n      const dependencies: PackageJsonDependency[] = [\n        ...project.packageJsonEditor.dependencyList,\n        ...project.packageJsonEditor.devDependencyList\n      ];\n      for (const { name: dependencyName, version: dependencyVersion, dependencyType } of dependencies) {\n        if (dependencyType === DependencyType.Peer) {\n          // If this is a peer dependency, it isn't a real dependency in this context, so it shouldn't\n          // be included in the list of dependency versions.\n          continue;\n        }\n\n        // Is it a local project?\n        const localProject: RushConfigurationProject | undefined =\n          this._rushConfiguration.getProjectByName(dependencyName);\n        if (localProject) {\n          if (\n            !project.cyclicDependencyProjects.has(dependencyName) &&\n            semver.satisfies(localProject.packageJson.version, dependencyVersion)\n          ) {\n            // For now, ignore local dependencies (that aren't cyclic dependencies).\n            continue;\n          }\n        }\n\n        let allVersionForDependency: Set<string> | undefined = allVersionsByPackageName.get(dependencyName);\n        if (!allVersionForDependency) {\n          allVersionForDependency = new Set<string>();\n          allVersionsByPackageName.set(dependencyName, allVersionForDependency);\n        }\n\n        allVersionForDependency.add(dependencyVersion);\n      }\n    }\n\n    const implicitlyPreferredVersionByPackageName: Map<string, string> = new Map();\n    // Only generate implicitly preferred versions for variants that request it\n    const useImplicitlyPreferredVersions: boolean =\n      commonVersionsConfiguration.implicitlyPreferredVersions ?? true;\n    if (useImplicitlyPreferredVersions) {\n      for (const [dependencyName, versions] of allVersionsByPackageName) {\n        // For each dependency, we're collecting the set of all version specifiers that appear across the repo.\n        // If there is only one version specifier, then that's the \"preferred\" one.\n\n        const alternativesForThisDependency: ReadonlySet<string> = new Set(\n          allowedAlternativeVersions.get(dependencyName)\n        );\n\n        let implicitlyPreferredVersion: string | undefined = undefined;\n        for (const version of versions) {\n          // Versions listed in the common-versions.json's \"allowedAlternativeVersions\" property\n          // can be safely ignored in determining the set of implicitly preferred versions.\n          // (Even if it's the only version specifier anywhere in the repo, we still ignore it, because\n          // otherwise the rule would be difficult to explain.)\n          if (!alternativesForThisDependency.has(version)) {\n            if (implicitlyPreferredVersion === undefined) {\n              // There isn't a candidate for an implicitly preferred version yet. Set this value as a candidate.\n              implicitlyPreferredVersion = version;\n            } else {\n              // There was already another version that was a candidate. Clear that out and break.\n              // This dependency does not have an implicitly preferred version because there are at least\n              // two candidates.\n              implicitlyPreferredVersion = undefined;\n              break;\n            }\n          }\n        }\n\n        if (implicitlyPreferredVersion !== undefined) {\n          implicitlyPreferredVersionByPackageName.set(dependencyName, implicitlyPreferredVersion);\n        }\n      }\n    }\n\n    return {\n      commonVersionsConfiguration,\n      implicitlyPreferredVersionByPackageName,\n      allVersionsByPackageName\n    };\n  }\n}\n"]}